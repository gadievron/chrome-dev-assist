# Implementation Roadmap: P1/P2 Issues

**Date**: 2025-10-27
**Total Effort**: 5.5-6.5 hours (6 sessions)
**Reviewers**: Architect, QA Engineer, Code Logician, Security Hacker
**Status**: ✅ **APPROVED** (unanimous)

---

## Executive Summary

**16 issues reduced to 17 total → Implementing 6 highest-priority improvements**

### P1 Issues (High Priority - 2 hours)

1. **P1-1**: Add 1MB metadata size limit (30 min) - **CRITICAL SECURITY**
2. **P1-2**: Un-skip 2 critical tests (1 hour) - Coverage improvement
3. **P1-3**: Document race conditions (30 min) - Maintainability

### P2 Issues (Medium Priority - 3.5-4.5 hours)

1. **P2-1**: Remove dead code (5 min) - Quick cleanup
2. **P2-2**: Fix quality float validation (15 min) - Consistency
3. **P2-3**: Add 33 missing tests (3-4 hours) - Comprehensive coverage

### Impact

- **Security**: Closes critical DoS vector (P1-1)
- **Reliability**: 85% test coverage (P2-3)
- **Consistency**: Aligns validation patterns (P2-2)
- **Maintainability**: Documents race conditions (P1-3)

---

## Session-by-Session Breakdown

### 📋 SESSION 1: Critical Security + Quick Win (35 min)

**Priority**: 🔴 CRITICAL (Security fix)
**Risk**: 🟢 LOW
**Files**: `extension/background.js`

#### Tasks

1. **P1-1**: Add metadata size limit (30 min)
2. **P2-1**: Remove dead code (5 min)

#### Implementation Steps

```bash
# Step 1: Add size limit (P1-1)
# File: extension/background.js
# Location: handleGetPageMetadataCommand (lines 656-712)

# After line 665 (after tab validation):
const MAX_METADATA_SIZE = 1024 * 1024; // 1MB

# After line 690 (after metadata extraction):
const metadataStr = JSON.stringify(metadata);
const sizeBytes = new TextEncoder().encode(metadataStr).length;

if (sizeBytes > MAX_METADATA_SIZE) {
  throw new Error(
    `Metadata too large: ${Math.round(sizeBytes/1024)}KB exceeds 1MB limit. ` +
    `Reduce page complexity or use smaller testMetadata object.`
  );
}

# Step 2: Remove dead code (P2-1)
# File: extension/background.js
# Location: handleCaptureScreenshotCommand (lines 733-735)

# DELETE these lines:
# if (result === null || result === undefined) {
#   throw new Error('Screenshot capture returned null or undefined');
# }

# Step 3: Add tests
# File: tests/unit/page-metadata.test.js

test('should accept metadata at 1MB limit', async () => {
  const largeMetadata = { data: 'x'.repeat(1024 * 1024 - 100) };
  // Create fixture with ~1MB metadata
  const result = await getPageMetadata(tabId);
  expect(result.metadata).toBeDefined();
});

test('should reject metadata exceeding 1MB', async () => {
  const hugeMetadata = { data: 'x'.repeat(1024 * 1024 + 1) };
  await expect(getPageMetadata(tabId))
    .rejects.toThrow(/exceeds size limit/i);
});

# Step 4: Run tests
npm test

# Step 5: Commit
git add extension/background.js tests/unit/page-metadata.test.js
git commit -m "feat: Add 1MB metadata size limit, remove dead code

- Add MAX_METADATA_SIZE validation (1MB) in handleGetPageMetadataCommand
- Prevents DoS via memory exhaustion (critical security fix)
- Remove unreachable null check in handleCaptureScreenshotCommand
- Add 2 boundary tests (at-limit, over-limit)

Security: Closes DoS vector identified by multi-persona review
Code quality: Removes 3 lines of dead code (improves coverage to 100%)
Testing: 2 new tests verify size limit enforcement"
```

#### Success Criteria

- ✅ All tests pass (npm test)
- ✅ Metadata > 1MB rejected with clear error
- ✅ Dead code removed (3 lines)
- ✅ Test coverage at 100%

#### Deliverables

- Modified: `extension/background.js` (+10 lines, -3 lines)
- Modified: `tests/unit/page-metadata.test.js` (+20 lines, 2 tests)
- Commit: "feat: Add 1MB metadata size limit, remove dead code"

---

### 📋 SESSION 2: Consistency + Documentation (45 min)

**Priority**: 🟡 MEDIUM (Consistency + clarity)
**Risk**: 🟢 LOW
**Files**: `claude-code/index.js`, `extension/background.js`, `tests/unit/screenshot-validation.test.js`

#### Tasks

1. **P2-2**: Fix quality float validation (15 min)
2. **P1-3**: Document race conditions (30 min)

#### Implementation Steps

```bash
# Step 1: Add quality integer validation (P2-2)
# File: claude-code/index.js
# Location: captureScreenshot function (lines 285-294)

# After line 294 (after quality range validation):
if (options.quality !== undefined && !Number.isInteger(options.quality)) {
  throw new Error('Quality must be an integer between 0 and 100');
}

# Step 2: Add quality test
# File: tests/unit/screenshot-validation.test.js

test('should reject fractional quality values', async () => {
  const testCases = [0.5, 75.5, 99.9];

  for (const quality of testCases) {
    await expect(captureScreenshot(1, { format: 'jpeg', quality }))
      .rejects.toThrow(/must be an integer/i);
  }
});

# Step 3: Document race conditions (P1-3)
# File: extension/background.js
# Location: handleGetPageMetadataCommand (lines 656-712)

# Add after line 665 (after tab validation):
/**
 * RACE CONDITION HANDLING:
 * This function is subject to Time-Of-Check-Time-Of-Use (TOCTOU) races:
 *
 * 1. Tab Closure Race:
 *    - Tab may close between validation and extraction
 *    - Error: "No tab with id: X"
 *    - Recovery: Client should retry (transient error)
 *
 * 2. Tab Navigation Race:
 *    - Tab may navigate to different page during extraction
 *    - Result: Metadata for NEW page, not original
 *    - Recovery: Client must verify result.url matches expectation
 *
 * 3. Extension Reload Race:
 *    - Extension may reload during command execution
 *    - Error: "Extension context invalidated"
 *    - Recovery: Client should reconnect and retry
 *
 * All errors are caught and returned via sendResponse.
 * Commands are idempotent (safe to retry).
 * WebSocket timeout (30s) prevents hanging commands.
 */

# Add after line 693 (after executeScript error handling):
/**
 * Common error scenarios:
 * - "No tab with id: X" → Tab closed (retry)
 * - "Extension context invalidated" → Extension reloaded (reconnect + retry)
 * - executeScript timeout → Tab unresponsive (retry with longer timeout)
 *
 * Client behavior:
 * - Verify result.url matches expected URL (detect navigation race)
 * - Retry on transient errors (timeout, tab closed, context invalidated)
 * - Fail on permanent errors (invalid tab ID, access denied)
 */

# Similar documentation for handleCaptureScreenshotCommand (lines 721-765)

# Step 4: Run tests
npm test

# Step 5: Commit
git add claude-code/index.js extension/background.js tests/unit/screenshot-validation.test.js
git commit -m "docs: Document race conditions, fix: Validate integer quality

P2-2: Quality validation consistency
- Add integer check for quality parameter (matches tabId pattern)
- Prevents undefined Chrome API behavior with fractional quality
- Add test for fractional quality rejection

P1-3: Race condition documentation
- Document TOCTOU vulnerabilities in getPageMetadata and captureScreenshot
- Explain tab closure, navigation, and extension reload races
- Provide client retry guidance and error recovery strategies
- No code changes (documentation only)

Consistency: Aligns quality validation with tabId validation pattern
Maintainability: Future developers understand error paths
Testing: 1 new test verifies quality integer validation"
```

#### Success Criteria

- ✅ All tests pass (npm test)
- ✅ Quality = 75.5 rejected with clear error
- ✅ Quality = 75 accepted (valid integer)
- ✅ Race conditions documented inline

#### Deliverables

- Modified: `claude-code/index.js` (+3 lines)
- Modified: `extension/background.js` (+60 lines comments)
- Modified: `tests/unit/screenshot-validation.test.js` (+10 lines, 1 test)
- Commit: "docs: Document race conditions, fix: Validate integer quality"

---

### 📋 SESSION 3: Test Coverage Completion (1-1.5 hours)

**Priority**: 🟡 MEDIUM (Coverage improvement)
**Risk**: 🟡 MEDIUM (may reveal bugs)
**Files**: `tests/unit/page-metadata.test.js`, `extension/inject-console-capture.js` (conditional)

#### Tasks

1. **P1-2**: Un-skip 2 critical tests (1 hour)
2. **Conditional**: Implement safeStringify if circular ref test fails (+30 min)

#### Implementation Steps

```bash
# Step 1: Un-skip tests
# File: tests/unit/page-metadata.test.js

# Line 155: Large metadata test
test.skip('should handle large metadata objects', async () => {
# CHANGE TO:
test('should handle large metadata objects', async () => {

# Line 167: Circular reference test
test.skip('should handle circular references in metadata', async () => {
# CHANGE TO:
test('should handle circular references in metadata', async () => {

# Step 2: Run tests
npm test

# Step 3: IF circular ref test FAILS (expected), implement safeStringify
# File: extension/inject-console-capture.js
# Location: Lines 24-29 (current JSON.stringify location)

# REPLACE:
if (typeof arg === 'object') {
  try {
    return JSON.stringify(arg);
  } catch (e) {
    return String(arg);  // Returns "[object Object]" - loses info
  }
}

# WITH:
function safeStringify(obj) {
  const seen = new WeakSet();
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) return '[Circular]';
      seen.add(value);
    }
    return value;
  });
}

if (typeof arg === 'object') {
  try {
    return safeStringify(arg);  // Handles circular refs gracefully
  } catch (e) {
    return String(arg);
  }
}

# Step 4: Re-run tests (should pass now)
npm test

# Step 5: Commit
git add tests/unit/page-metadata.test.js extension/inject-console-capture.js
git commit -m "test: Un-skip critical metadata tests, fix: Handle circular refs

P1-2: Test coverage improvement
- Un-skip large metadata test (validates P1-1 size limit)
- Un-skip circular reference test (reveals serialization bug)

Bug fix: Circular reference handling
- Implement safeStringify to handle circular refs gracefully
- Replaces "[object Object]" with structured data + "[Circular]" markers
- Preserves object structure and shows where cycles occur
- Uses WeakSet for O(1) cycle detection

Testing: 2 previously skipped tests now passing
Coverage: Increases actual test coverage (was blind spot)
Robustness: Handles edge case inputs without information loss"
```

#### Success Criteria

- ✅ All tests pass (npm test)
- ✅ Large metadata test passes (validates P1-1)
- ✅ Circular ref test passes (with safeStringify fix)
- ✅ No regressions in other tests

#### Deliverables

- Modified: `tests/unit/page-metadata.test.js` (-2 `.skip` modifiers)
- Modified: `extension/inject-console-capture.js` (+15 lines) - conditional
- Commit: "test: Un-skip critical metadata tests" (+ ", fix: Handle circular refs" if needed)

---

### 📋 SESSION 4: Basic Test Expansion (30 min)

**Priority**: 🟢 LOW (Nice-to-have)
**Risk**: 🟢 LOW
**Files**: `tests/unit/screenshot-validation.test.js`, `tests/unit/page-metadata.test.js`

#### Tasks

1. **P2-3 Phase 1**: Add 10 validation edge case tests (30 min)

#### Implementation Steps

```bash
# File: tests/unit/screenshot-validation.test.js

test('should accept quality = 0 (valid boundary)', async () => {
  const promise = captureScreenshot(1, { format: 'jpeg', quality: 0 });
  await expect(promise).rejects.toThrow(/not connected/i); // Validates input, fails at connection
});

test('should accept quality = 100 (valid boundary)', async () => {
  const promise = captureScreenshot(1, { format: 'jpeg', quality: 100 });
  await expect(promise).rejects.toThrow(/not connected/i);
});

test('should accept format = "PNG" (uppercase)', async () => {
  const promise = captureScreenshot(1, { format: 'PNG' });
  await expect(promise).rejects.toThrow(/not connected/i);
});

test('should accept format = "jpeg" (lowercase)', async () => {
  const promise = captureScreenshot(1, { format: 'jpeg' });
  await expect(promise).rejects.toThrow(/not connected/i);
});

test('should handle empty options object {}', async () => {
  const promise = captureScreenshot(1, {});
  await expect(promise).rejects.toThrow(/not connected/i);
});

# File: tests/unit/page-metadata.test.js

test('should handle Unicode in metadata', async () => {
  // Create fixture with Unicode characters (emoji, CJK, etc.)
  const result = await getPageMetadata(tabId);
  expect(result.metadata).toBeDefined();
});

test('should handle control characters in metadata', async () => {
  // Create fixture with \n, \t, \0
  const result = await getPageMetadata(tabId);
  expect(result.metadata).toBeDefined();
});

test('should handle deeply nested metadata (100 levels)', async () => {
  // Create fixture with 100+ level nesting
  const result = await getPageMetadata(tabId);
  expect(result.metadata).toBeDefined();
});

test('should handle large array in metadata (10K items)', async () => {
  // Create fixture with 10K+ array items
  const result = await getPageMetadata(tabId);
  expect(result.metadata).toBeDefined();
});

test('should handle mixed types in metadata', async () => {
  // number, string, boolean, null, undefined, object, array
  const result = await getPageMetadata(tabId);
  expect(result.metadata).toBeDefined();
});

# Run tests
npm test

# Commit
git add tests/unit/screenshot-validation.test.js tests/unit/page-metadata.test.js
git commit -m "test: Add validation edge case tests (10)

P2-3 Phase 1: Basic validation coverage
- Quality boundary tests (0, 100)
- Format case sensitivity tests (PNG, jpeg)
- Empty options test
- Unicode and control character tests
- Deep nesting and large array tests
- Mixed type handling test

Coverage: +10 tests (fast, no dependencies)
Testing: All validation edge cases now covered"
```

#### Success Criteria

- ✅ All 10 new tests pass
- ✅ No regressions in existing tests
- ✅ Tests run fast (< 5 seconds total)

#### Deliverables

- Modified: `tests/unit/screenshot-validation.test.js` (+50 lines, 5 tests)
- Modified: `tests/unit/page-metadata.test.js` (+50 lines, 5 tests)
- Commit: "test: Add validation edge case tests (10)"

---

### 📋 SESSION 5: Integration Test Expansion (1 hour)

**Priority**: 🟢 LOW (Nice-to-have)
**Risk**: 🟡 MEDIUM (requires extension loaded)
**Files**: `tests/integration/edge-cases-complete.test.js`

#### Tasks

1. **P2-3 Phase 2**: Add 13 integration tests (1 hour)

#### Implementation Steps

```bash
# File: tests/integration/edge-cases-complete.test.js

# Chrome API restriction tests
test('should handle inactive tab appropriately', async () => {
  // Test tab that's not currently visible
});

test('should handle incognito tab appropriately', async () => {
  // Test privacy boundary (should Chrome block access?)
});

test('should reject chrome:// pages', async () => {
  const tab = await openUrl('chrome://extensions');
  await expect(getPageMetadata(tab.tabId))
    .rejects.toThrow(/cannot access chrome/i);
});

test('should handle extension pages appropriately', async () => {
  const tab = await openUrl('chrome-extension://abc123/page.html');
  // Security boundary test
});

test('should handle file:// URLs with permission', async () => {
  // Requires "Allow access to file URLs" permission
});

test('should handle data: URLs', async () => {
  const tab = await openUrl('data:text/html,<h1>Test</h1>');
  const result = await getPageMetadata(tab.tabId);
  expect(result.metadata).toBeDefined();
});

test('should handle about:blank', async () => {
  const tab = await openUrl('about:blank');
  const result = await getPageMetadata(tab.tabId);
  expect(result.metadata).toBeDefined();
});

# Concurrency tests
test('should handle concurrent getPageMetadata on same tab', async () => {
  const promises = [
    getPageMetadata(tabId),
    getPageMetadata(tabId),
    getPageMetadata(tabId)
  ];
  const results = await Promise.all(promises);
  expect(results).toHaveLength(3);
});

test('should handle concurrent captureScreenshot on same tab', async () => {
  const promises = [
    captureScreenshot(tabId),
    captureScreenshot(tabId),
    captureScreenshot(tabId)
  ];
  const results = await Promise.all(promises);
  expect(results).toHaveLength(3);
});

test('should handle concurrent different commands on same tab', async () => {
  const results = await Promise.all([
    getPageMetadata(tabId),
    captureScreenshot(tabId)
  ]);
  expect(results).toHaveLength(2);
});

test('should handle multiple tabs simultaneously', async () => {
  const tabs = [tab1, tab2, tab3];
  const results = await Promise.all(
    tabs.map(t => getPageMetadata(t.tabId))
  );
  expect(results).toHaveLength(3);
});

# Race condition tests (difficult to test reliably)
test('should handle tab closure during extraction', async () => {
  const promise = getPageMetadata(tabId);
  setTimeout(() => closeTab(tabId), 50); // Close during extraction
  await expect(promise).rejects.toThrow(/No tab with id/i);
});

test('should handle tab navigation during extraction', async () => {
  const promise = getPageMetadata(tabId);
  setTimeout(() => {
    // Trigger navigation in tab
  }, 50);
  const result = await promise;
  // May return metadata for new page (document race in P1-3)
});

# Run tests (requires extension loaded)
npm test

# Commit
git add tests/integration/edge-cases-complete.test.js
git commit -m "test: Add restriction and concurrency tests (13)

P2-3 Phase 2: Integration test coverage
- Chrome restriction tests (7): incognito, chrome://, extension://, file://, data:, about:blank
- Concurrency tests (4): Same tab, different commands, multiple tabs
- Race condition tests (2): Tab closure, navigation

Coverage: +13 tests (requires extension loaded)
Security: Verifies Chrome API security boundaries
Robustness: Tests concurrent operation handling"
```

#### Success Criteria

- ✅ Extension loaded in Chrome
- ✅ All 13 new tests pass (or appropriately fail/skip based on Chrome restrictions)
- ✅ No test infrastructure issues

#### Deliverables

- Modified: `tests/integration/edge-cases-complete.test.js` (+200 lines, 13 tests)
- Commit: "test: Add restriction and concurrency tests (13)"

---

### 📋 SESSION 6: Visual Verification Tests (2 hours)

**Priority**: 🟢 LOW (Nice-to-have)
**Risk**: 🟡 MEDIUM (complex, may need image analysis library)
**Files**: `tests/integration/screenshot-visual-verification.test.js` (new), `tests/fixtures/`

#### Tasks

1. **P2-3 Phase 3**: Add 10 complex tests (2 hours)

#### Implementation Steps

```bash
# Create new test file
# File: tests/integration/screenshot-visual-verification.test.js

const fs = require('fs');
const path = require('path');

test('should produce different file sizes for quality 50 vs 90', async () => {
  const screenshot50 = await captureScreenshot(tabId, { format: 'jpeg', quality: 50 });
  const screenshot90 = await captureScreenshot(tabId, { format: 'jpeg', quality: 90 });

  const size50 = Buffer.from(screenshot50.split(',')[1], 'base64').length;
  const size90 = Buffer.from(screenshot90.split(',')[1], 'base64').length;

  expect(size90).toBeGreaterThan(size50); // Higher quality = larger file
});

test('should produce smaller files for JPEG vs PNG', async () => {
  const screenshotPNG = await captureScreenshot(tabId, { format: 'png' });
  const screenshotJPEG = await captureScreenshot(tabId, { format: 'jpeg', quality: 90 });

  const sizePNG = Buffer.from(screenshotPNG.split(',')[1], 'base64').length;
  const sizeJPEG = Buffer.from(screenshotJPEG.split(',')[1], 'base64').length;

  // PNG typically larger for photos, smaller for simple graphics
  // Test depends on page content
});

test('should produce correct MIME type for format', async () => {
  const screenshotPNG = await captureScreenshot(tabId, { format: 'png' });
  const screenshotJPEG = await captureScreenshot(tabId, { format: 'jpeg' });

  expect(screenshotPNG).toMatch(/^data:image\/png;base64,/);
  expect(screenshotJPEG).toMatch(/^data:image\/jpeg;base64,/);
});

# Create test fixtures
# tests/fixtures/iframe-test.html
test('should capture iframe content', async () => {
  const tab = await openUrl(getFixtureUrl('iframe-test.html'));
  const screenshot = await captureScreenshot(tab.tabId);
  expect(screenshot).toBeDefined();
  // Visual verification: Does screenshot include iframe content?
});

# tests/fixtures/canvas-test.html
test('should capture canvas elements', async () => {
  const tab = await openUrl(getFixtureUrl('canvas-test.html'));
  const screenshot = await captureScreenshot(tab.tabId);
  expect(screenshot).toBeDefined();
  // Visual verification: Does screenshot show canvas rendering?
});

# Remaining tests: shadow DOM, video, extension reload, server disconnect, etc.

# Run tests
npm test

# Commit
git add tests/integration/screenshot-visual-verification.test.js tests/fixtures/*.html
git commit -m "test: Add race condition and visual tests (10)

P2-3 Phase 3: Complex test coverage
- Visual verification tests (4): Quality comparison, format comparison, MIME types
- Content verification tests (4): iframe, shadow DOM, canvas, video
- Reliability tests (2): Extension reload, server disconnect

Coverage: +10 tests (complex, expensive)
Testing: Visual quality and edge case rendering
Fixtures: 5 new HTML files for specialized testing

Total P2-3: 33 tests added (10 + 13 + 10)
Final coverage: ~85% state space"
```

#### Success Criteria

- ✅ Extension loaded in Chrome
- ✅ All 10 new tests pass
- ✅ Fixtures created and functional
- ✅ Visual verification working (file size comparison, MIME types)

#### Deliverables

- Created: `tests/integration/screenshot-visual-verification.test.js` (+300 lines, 10 tests)
- Created: `tests/fixtures/iframe-test.html`, `canvas-test.html`, etc. (5 files)
- Commit: "test: Add race condition and visual tests (10)"

---

## Summary Checklist

### P1 Issues (High Priority)

- [ ] **P1-1**: Add metadata size limit (Session 1) - ⏱️ 30 min
- [ ] **P1-2**: Un-skip critical tests (Session 3) - ⏱️ 1-1.5 hours
- [ ] **P1-3**: Document race conditions (Session 2) - ⏱️ 30 min

### P2 Issues (Medium Priority)

- [ ] **P2-1**: Remove dead code (Session 1) - ⏱️ 5 min
- [ ] **P2-2**: Fix quality float handling (Session 2) - ⏱️ 15 min
- [ ] **P2-3 Phase 1**: Add validation tests (Session 4) - ⏱️ 30 min
- [ ] **P2-3 Phase 2**: Add integration tests (Session 5) - ⏱️ 1 hour
- [ ] **P2-3 Phase 3**: Add visual tests (Session 6) - ⏱️ 2 hours

### Verification

- [ ] All tests pass after each session
- [ ] No regressions introduced
- [ ] Code coverage maintained or improved
- [ ] Documentation updated (inline comments, test descriptions)
- [ ] Git commits follow message template

---

## Success Metrics

### Code Quality

- **Lines changed**: ~600 lines (100 production + 500 tests)
- **Files modified**: 6 production files, 4+ test files
- **Test coverage**: 40% → 85% (state space coverage)
- **Code coverage**: Maintained at 95%+ (line coverage)

### Security

- **Critical vulnerabilities**: 1 closed (DoS via memory exhaustion)
- **Security boundaries tested**: 7 tests (incognito, chrome://, extension://, etc.)
- **Attack vectors mitigated**: Memory exhaustion, undefined behavior

### Maintainability

- **Race conditions documented**: 3 scenarios (tab closure, navigation, extension reload)
- **Error handling clarified**: Inline comments explain transient vs permanent errors
- **Validation consistency**: All inputs follow same pattern (type → range → invariants)

### Reliability

- **Edge cases covered**: 33 new tests
- **Blind spots eliminated**: 2 skipped tests now active
- **Concurrency tested**: 4 tests (same tab, different commands, multiple tabs)
- **Chrome restrictions tested**: 7 tests (security boundaries)

---

## Risk Mitigation

### Session 1 (P1-1 + P2-1)

**Risk**: Temporary memory spike during size check
**Mitigation**: Size checked immediately after extraction, memory freed on rejection

### Session 3 (P1-2)

**Risk**: Circular ref test may fail, requiring safeStringify implementation
**Mitigation**: Budget 1.5 hours (1 hour for tests + 30 min for fix)

### Session 5-6 (P2-3 Phases 2-3)

**Risk**: Integration tests require extension loaded (manual step)
**Mitigation**: Document prerequisites clearly, skip tests if not loaded

---

## Git Commit Template

Each session should follow this commit message format:

```
<type>: <short summary> (<issue>)

<detailed description>

<body>
- Bullet point 1
- Bullet point 2

<footer>
Related: <related issues>
Reviewed-by: <reviewers>
Testing: <test summary>
```

**Example**:

```
feat: Add 1MB metadata size limit, remove dead code (P1-1, P2-1)

Add MAX_METADATA_SIZE validation in handleGetPageMetadataCommand to prevent
DoS via memory exhaustion. Remove unreachable null check in
handleCaptureScreenshotCommand.

- Add 1MB size limit in extension/background.js:656-712
- Calculate size using TextEncoder for accurate byte count
- Provide clear error message with actual size
- Remove dead code at extension/background.js:733-735
- Add 2 boundary tests (at-limit, over-limit)

Security: Closes DoS vector identified by multi-persona review
Code quality: Removes 3 lines of dead code (improves coverage to 100%)
Testing: 2 new tests verify size limit enforcement
Reviewed-by: Architect, QA, Logician, Security
```

---

## Implementation Resources

### Documentation References

- `.P1-P2-IMPLEMENTATION-ANALYSIS-4-PERSONAS-2025-10-27.md` - Complete analysis
- `.ARCHITECTURAL-PLACEMENT-GUIDE-2025-10-27.md` - Architectural fit details
- `TO-FIX.md` - Issue tracking
- `COMPLETE-FUNCTIONALITY-MAP.md` - Current functionality

### Test Helpers

- `tests/integration/test-helpers.js` - URL generation, token handling
- `tests/fixtures/` - Test HTML files (create new ones as needed)

### Chrome Extension Development

- `chrome://extensions` - Load and reload extension
- Service worker console - View extension logs
- `docs/EXTENSION-TESTING-GUIDE.md` - Testing instructions

---

## Post-Implementation Actions

### Documentation Updates

1. Update `TO-FIX.md` - Move completed issues to `FIXED-LOG.md` (after 24-hour cooling)
2. Update `COMPLETE-FUNCTIONALITY-MAP.md` - Document new test coverage
3. Update `docs/API.md` - Add security warnings if needed
4. Update `README.md` - Mention improved test coverage

### Validation

1. Run full test suite: `npm test`
2. Check code coverage: `npm run test:coverage`
3. Verify no regressions: Compare test results before/after
4. Manual testing: Load extension, verify commands work

### Communication

1. Create session summary document
2. Document lessons learned
3. Report to stakeholders (if any)

---

**Total Estimated Time**: 5.5-6.5 hours
**Critical Path**: Session 1 (Security) → Session 2 (Consistency) → Session 3 (Coverage)
**Optional**: Sessions 4-6 (Additional test coverage)

**Status**: Ready for implementation ✅
**Approval**: Unanimous (4/4 expert personas)
**Risk Level**: 🟡 Low-Medium (well-mitigated)

---

**Created**: 2025-10-27
**Reviewed by**: Architect, QA Engineer, Code Logician, Security Hacker
**Related Documents**: See "Implementation Resources" section above
