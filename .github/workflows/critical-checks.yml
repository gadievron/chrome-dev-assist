name: Critical Checks (Free)

# Runs on: push to main branches, all PRs
# Cost: $0 (uses GitHub Actions free tier)
# Duration: ~3-5 minutes

'on':
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master, develop]

jobs:
  critical-lint:
    name: Critical Linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 1. SHELL SCRIPT LINTING (Critical - catches syntax errors & security issues)
      - name: ShellCheck - Lint shell scripts
        uses: ludeeus/action-shellcheck@master
        with:
          severity: error
          scandir: '.'

      # 2. YAML LINTING (Critical - validates CI/CD workflow files)
      - name: YAML Lint - Validate workflow files
        uses: ibiqlik/action-yamllint@v3
        with:
          file_or_dir: .github/workflows/
          config_file: .yamllint.yml
          strict: true

      # 3. JSON VALIDATION (Critical - config files must be valid)
      - name: JSON Validation
        run: |
          echo "=== Validating JSON files ==="
          # Find and validate all JSON files
          find . -name "*.json" \
            -not -path "*/node_modules/*" \
            -not -path "*/.git/*" \
            -exec echo "Checking: {}" \; \
            -exec jq empty {} \;
          echo "‚úÖ All JSON files are valid"

      # 4. MARKDOWN LINTING (Critical - documentation quality)
      #    Note: Only checks project-critical markdown files
      - name: Markdown Lint
        uses: articulate/actions-markdownlint@v1
        with:
          config: .markdownlint.json
          files: '*.md'
          ignore: 'node_modules blogs docs tests .archive .backups .validation-tests'

  critical-security:
    name: Critical Security Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for secret scanning

      # 1. SECRET SCANNING (Critical - prevent credential leaks)
      - name: Gitleaks - Scan for secrets
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 2. CVE-2025-53773 SECURITY AUDIT (Critical - custom checks for Claude Code hooks)
      - name: Hook Security Audit (CVE-2025-53773 patterns)
        run: |
          echo "========================================"
          echo "üîí HOOK SECURITY AUDIT"
          echo "========================================"

          FAILED=0

          # Check 1: Unsafe echo usage (should use printf)
          echo ""
          echo "Check 1: Unsafe echo with variables..."
          if find . -name "*.sh" -type f \
            -not -path './.archive/*' \
            -not -path './test-rules-compliance.sh*' \
            -not -path './.github/*' \
            -exec grep -Hn 'echo.*\$' {} \; 2>/dev/null | grep -v '^\s*#'; then
            echo "‚ùå FAIL: Found unsafe 'echo \$var' usage"
            echo "   Fix: Use 'printf \"%s\" \"\$var\"' instead"
            FAILED=1
          else
            echo "‚úÖ PASS: No unsafe echo usage"
          fi

          # Check 2: Regex grep (should use literal)
          echo ""
          echo "Check 2: Unsafe regex grep matching..."
          GREP_E_RESULTS=$(find . -name "*.sh" -type f \
            -not -path './.archive/*' \
            -not -path './test-rules-compliance.sh*' \
            -not -path './.github/*' \
            -exec grep -Hn 'grep[[:space:]]\+-E' {} \; 2>/dev/null || true)

          if [ -n "$GREP_E_RESULTS" ]; then
            echo "‚ùå FAIL: Found regex grep usage in:"
            echo "$GREP_E_RESULTS"
            echo "   Fix: Use literal matching (grep -F) instead"
            FAILED=1
          else
            echo "‚úÖ PASS: No regex grep usage"
          fi

          # Check 3: eval usage (command injection risk)
          echo ""
          echo "Check 3: eval usage (command injection)..."
          if find . -name "*.sh" -type f -exec grep -Hn '\beval\b' {} \; 2>/dev/null | grep -v '^\s*#'; then
            echo "‚ùå FAIL: Found 'eval' usage"
            echo "   Fix: Refactor to avoid eval"
            FAILED=1
          else
            echo "‚úÖ PASS: No eval usage"
          fi

          # Check 4: Unquoted variables
          echo ""
          echo "Check 4: Unquoted variables..."
          if find . -name "*.sh" -type f \
            -exec grep -Hn '\$[A-Z_][A-Z_0-9]*[^"\}]' {} \; 2>/dev/null \
            | grep -v '^\s*#' | grep -v '=' | head -5; then
            echo "‚ö†Ô∏è  WARNING: Found potentially unquoted variables"
            echo "   Review: Ensure all \$VARS are quoted: \"\$VAR\""
            # Not failing on this, just warning
          else
            echo "‚úÖ PASS: Variables appear to be quoted"
          fi

          # Check 5: Hooks are executable
          echo ""
          echo "Check 5: Hook file permissions..."
          NON_EXEC=0
          if [ -d ".claude/hooks" ]; then
            for hook in .claude/hooks/*.sh; do
              if [ -f "$hook" ] && [ ! -x "$hook" ]; then
                echo "‚ùå FAIL: $hook is not executable"
                NON_EXEC=1
              fi
            done
          fi
          if [ $NON_EXEC -eq 0 ]; then
            echo "‚úÖ PASS: All hooks are executable (or no hooks found)"
          else
            echo "   Fix: chmod +x .claude/hooks/*.sh"
            FAILED=1
          fi

          echo ""
          echo "========================================"
          if [ $FAILED -eq 1 ]; then
            echo "‚ùå SECURITY AUDIT FAILED"
            echo "========================================"
            exit 1
          else
            echo "‚úÖ SECURITY AUDIT PASSED"
            echo "========================================"
          fi

      # 3. TOKEN BUDGET VALIDATION (Critical for Claude Code projects - prevents context bloat)
      - name: Token Budget Validation
        run: |
          echo "========================================"
          echo "üìè TOKEN BUDGET VALIDATION"
          echo "========================================"

          FAILED=0

          # Check CLAUDE.md size
          echo ""
          echo "Checking CLAUDE.md size..."
          if [ -f "CLAUDE.md" ]; then
            CLAUDE_LINES=$(wc -l < CLAUDE.md)
            if [ $CLAUDE_LINES -gt 250 ]; then
              echo "‚ùå FAIL: CLAUDE.md is $CLAUDE_LINES lines (max: 250)"
              echo "   Community best practice: 100-200 lines optimal"
              FAILED=1
            else
              echo "‚úÖ PASS: CLAUDE.md is $CLAUDE_LINES lines (target: <250)"
            fi
          else
            echo "‚ÑπÔ∏è  INFO: No CLAUDE.md found (optional)"
          fi

          # Check tier1 files
          echo ""
          if [ -d "base-rules/tier1" ] || [ -d "rules/tier1" ] || [ -d ".claude/rules/tier1" ]; then
            echo "Checking tier1 file sizes..."
            for dir in base-rules/tier1 rules/tier1 .claude/rules/tier1; do
              if [ -d "$dir" ]; then
                for file in "$dir"/*.md; do
                  if [ -f "$file" ]; then
                    LINES=$(wc -l < "$file")
                    FILENAME=$(basename "$file")
                    if [ $LINES -gt 150 ]; then
                      echo "‚ùå FAIL: $FILENAME is $LINES lines (max: 150)"
                      FAILED=1
                    else
                      echo "‚úÖ PASS: $FILENAME is $LINES lines"
                    fi
                  fi
                done
              fi
            done
          else
            echo "‚ÑπÔ∏è  INFO: No tier1 rules found (optional)"
          fi

          echo ""
          echo "========================================"
          if [ $FAILED -eq 1 ]; then
            echo "‚ùå TOKEN BUDGET CHECK FAILED"
            echo "========================================"
            exit 1
          else
            echo "‚úÖ TOKEN BUDGET CHECK PASSED"
            echo "========================================"
          fi

  summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [critical-lint, critical-security]
    if: always()

    steps:
      - name: Check results
        run: |
          echo "========================================"
          echo "üìä CI PIPELINE SUMMARY"
          echo "========================================"
          echo ""
          echo "Critical Linting: ${{ needs.critical-lint.result }}"
          echo "Critical Security: ${{ needs.critical-security.result }}"
          echo ""

          LINT="${{ needs.critical-lint.result }}"
          SECURITY="${{ needs.critical-security.result }}"
          if [ "$LINT" != "success" ] || [ "$SECURITY" != "success" ]; then
            echo "‚ùå PIPELINE FAILED"
            echo "========================================"
            exit 1
          else
            echo "‚úÖ ALL CHECKS PASSED"
            echo "========================================"
          fi
