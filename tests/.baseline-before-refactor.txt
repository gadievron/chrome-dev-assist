
> chrome-dev-assist@1.0.0 test
> jest

FAIL tests/unit/websocket-connection-stability.test.js
  â— Test suite failed to run

    Jest encountered an unexpected token

    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.

    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.

    By default "node_modules" folder is ignored by transformers.

    Here's what you can do:
     â€¢ If you are trying to use ECMAScript Modules, see https://jestjs.io/docs/ecmascript-modules for how to enable it.
     â€¢ If you are trying to use TypeScript, see https://jestjs.io/docs/getting-started#using-typescript
     â€¢ To have some of your "node_modules" files transformed, you can specify a custom "transformIgnorePatterns" in your config.
     â€¢ If you need a custom transformation specify a "transform" option in your config.
     â€¢ If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the "moduleNameMapper" config option.

    You'll find more details and examples of these config options in the docs:
    https://jestjs.io/docs/configuration
    For information about custom transformations, see:
    https://jestjs.io/docs/code-transformation

    Details:

    /Users/gadievron/Documents/Claude Code/chrome-dev-assist/tests/unit/websocket-connection-stability.test.js:24
      jest
      ^

    SyntaxError: Identifier 'jest' has already been declared

      at Runtime.createScriptFromCode (node_modules/jest-runtime/build/index.js:1505:14)

FAIL tests/integration/console-error-crash-detection.test.js
  â— Console

    console.log
      
      ğŸ“Š Total console.error() calls: 9

      at Object.log (tests/integration/console-error-crash-detection.test.js:73:15)

    console.log
      Expected: 4 legitimate programming errors

      at Object.log (tests/integration/console-error-crash-detection.test.js:74:15)

    console.log
      Found: Check CONSOLE-ERROR-ANALYSIS.md for details

      at Object.log (tests/integration/console-error-crash-detection.test.js:75:15)

    console.log
      
      âœ… Fixed console.error â†’ console.warn: 0 locations

      at Object.log (tests/integration/console-error-crash-detection.test.js:146:15)

    console.log
      
      ğŸ“‹ Catch blocks with console.error: 2

      at Object.log (tests/integration/console-error-crash-detection.test.js:179:15)

    console.warn
      âš ï¸ console.error in ws.onerror without fix comment

      285 |
      286 |             if (!hasFixComment) {
    > 287 |               console.warn(`âš ï¸ console.error in ${handler} without fix comment`);
          |                       ^
      288 |               console.warn('   Expected errors should use console.warn');
      289 |             }
      290 |           }

      at Object.warn (tests/integration/console-error-crash-detection.test.js:287:23)

    console.warn
         Expected errors should use console.warn

      286 |             if (!hasFixComment) {
      287 |               console.warn(`âš ï¸ console.error in ${handler} without fix comment`);
    > 288 |               console.warn('   Expected errors should use console.warn');
          |                       ^
      289 |             }
      290 |           }
      291 |         }

      at Object.warn (tests/integration/console-error-crash-detection.test.js:288:23)

    console.warn
      âš ï¸ console.error in catch (error) without fix comment

      285 |
      286 |             if (!hasFixComment) {
    > 287 |               console.warn(`âš ï¸ console.error in ${handler} without fix comment`);
          |                       ^
      288 |               console.warn('   Expected errors should use console.warn');
      289 |             }
      290 |           }

      at Object.warn (tests/integration/console-error-crash-detection.test.js:287:23)

    console.warn
         Expected errors should use console.warn

      286 |             if (!hasFixComment) {
      287 |               console.warn(`âš ï¸ console.error in ${handler} without fix comment`);
    > 288 |               console.warn('   Expected errors should use console.warn');
          |                       ^
      289 |             }
      290 |           }
      291 |         }

      at Object.warn (tests/integration/console-error-crash-detection.test.js:288:23)

    console.warn
      âš ï¸ console.error in catch (err) without fix comment

      285 |
      286 |             if (!hasFixComment) {
    > 287 |               console.warn(`âš ï¸ console.error in ${handler} without fix comment`);
          |                       ^
      288 |               console.warn('   Expected errors should use console.warn');
      289 |             }
      290 |           }

      at Object.warn (tests/integration/console-error-crash-detection.test.js:287:23)

    console.warn
         Expected errors should use console.warn

      286 |             if (!hasFixComment) {
      287 |               console.warn(`âš ï¸ console.error in ${handler} without fix comment`);
    > 288 |               console.warn('   Expected errors should use console.warn');
          |                       ^
      289 |             }
      290 |           }
      291 |         }

      at Object.warn (tests/integration/console-error-crash-detection.test.js:288:23)

    console.log
      
      ğŸ“Š Statistics:

      at Object.log (tests/integration/console-error-crash-detection.test.js:323:15)

    console.log
         Catch blocks: 8

      at Object.log (tests/integration/console-error-crash-detection.test.js:324:15)

    console.log
         console.error calls: 9

      at Object.log (tests/integration/console-error-crash-detection.test.js:325:15)

    console.log
         Ratio: 112.5%

      at Object.log (tests/integration/console-error-crash-detection.test.js:326:15)

    console.log
         Goal: <30% (most errors should be console.warn)

      at Object.log (tests/integration/console-error-crash-detection.test.js:327:15)

  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for WebSocket connection failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', exte"

      31 |       );
      32 |
    > 33 |       expect(onerrorHandler).toContain('console.warn');
         |                              ^
      34 |       expect(onerrorHandler).not.toMatch(/console\.error.*WebSocket.*connection/i);
      35 |     });
      36 |

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:33:30)

  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for connection timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      41 |       );
      42 |
    > 43 |       expect(timeoutHandler).toContain('console.warn');
         |                              ^
      44 |       expect(timeoutHandler).not.toMatch(/console\.error.*timeout/i);
      45 |     });
      46 |

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:43:30)

  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for registration timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      51 |       );
      52 |
    > 53 |       expect(regTimeoutHandler).toContain('console.warn');
         |                                 ^
      54 |       expect(regTimeoutHandler).not.toMatch(/console\.error.*[Rr]egistration/);
      55 |     });
      56 |

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:53:33)

  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for command failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclos"

      61 |       );
      62 |
    > 63 |       expect(catchHandler).toContain('console.warn');
         |                            ^
      64 |       expect(catchHandler).toContain('Command failed');
      65 |       expect(catchHandler).not.toMatch(/console\.error.*Command failed/);
      66 |     });

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:63:28)

  â— Console.error Crash Detection Prevention â€º Remaining console.error Usage Analysis â€º should NOT use console.error for expected tab closure failures

    âŒ Found console.error in tab cleanup at line ~485. Tab closure failures are EXPECTED in testing (tabs may be already closed). Should use console.warn instead. See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:206-214

       97 |         if (section.includes('console.error')) {
       98 |           const lineNumber = backgroundJs.substring(0, idx).split('\n').length;
    >  99 |           throw new Error(`âŒ Found console.error in tab cleanup at line ~${lineNumber}. ` +
          |                 ^
      100 |                           `Tab closure failures are EXPECTED in testing (tabs may be already closed). ` +
      101 |                           `Should use console.warn instead. ` +
      102 |                           `See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:206-214`);

      at Object.<anonymous> (tests/integration/console-error-crash-detection.test.js:99:17)

  â— Console.error Crash Detection Prevention â€º Pattern Detection (Generic Bug Prevention) â€º should have "âœ… FIX" comment for all fixed console.warn conversions

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 4
    Received:    0

      147 |
      148 |       // We have 4 known fixes
    > 149 |       expect(fixComments.length).toBeGreaterThanOrEqual(4);
          |                                  ^
      150 |     });
      151 |
      152 |     it('should document why console.error is kept for programming bugs', () => {

      at Object.toBeGreaterThanOrEqual (tests/integration/console-error-crash-detection.test.js:149:34)

  â— Console.error Crash Detection Prevention â€º Crash Detection Trigger Patterns â€º should NOT have multiple console.error in rapid succession

    âŒ Found 2 rapid console.error sequence(s). Chrome may interpret this as extension crash. Example locations:
      1. Line ~485: console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');         console.error('[ChromeDevAssist...
      2. Line ~488: console.error('[ChromeDevAssist] Error message:', err.message);         console.error('[ChromeDevAss...
    Recommendation: Consolidate into single console.warn with object. See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:459-483

      206 |         }).join('\n');
      207 |
    > 208 |         throw new Error(`âŒ Found ${rapidErrors.length} rapid console.error sequence(s). ` +
          |               ^
      209 |                         `Chrome may interpret this as extension crash. ` +
      210 |                         `Example locations:\n${errorDetails}\n` +
      211 |                         `Recommendation: Consolidate into single console.warn with object. ` +

      at Object.<anonymous> (tests/integration/console-error-crash-detection.test.js:208:15)

  â— Console.error Crash Detection Prevention â€º Crash Detection Trigger Patterns â€º should consolidate error details into single log (not split across multiple console.error)

    âŒ Found 1 location(s) with multiple console.error for single error. Should consolidate into single console.warn with object:
      console.warn('Message', { tabId, errorType, errorMessage, ... });

    Violations:
      1. Line ~469: 4 console.error calls in 20 lines
                   const removeResult = chrome.tabs.remove(tab.id);
                   console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult...

    See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:459-483

      254 |         }).join('\n');
      255 |
    > 256 |         throw new Error(`âŒ Found ${violations.length} location(s) with multiple console.error for single error. ` +
          |               ^
      257 |                         `Should consolidate into single console.warn with object:\n` +
      258 |                         `  console.warn('Message', { tabId, errorType, errorMessage, ... });\n\n` +
      259 |                         `Violations:\n${violationDetails}\n\n` +

      at Object.<anonymous> (tests/integration/console-error-crash-detection.test.js:256:15)

  â— Console.error Crash Detection Prevention â€º Regression Prevention â€º should prevent re-introducing console.error for command failures

    expect(received).toBeNull()

    Received: ["console.error('[ChromeDevAssist] Command failed"]

      366 |           // Should NOT have console.error for Command failed
      367 |           if (hasError) {
    > 368 |             expect(hasError).toBeNull();
          |                              ^
      369 |             throw new Error(`Found console.error for command failure (should be console.warn): ${hasError[0].substring(0, 100)}`);
      370 |           }
      371 |         }

      at Object.toBeNull (tests/integration/console-error-crash-detection.test.js:368:30)

FAIL tests/security/websocket-client-security.test.js
  â— Console

    console.log
      
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/security/websocket-client-security.test.js:397:15)

    console.log
      SECURITY VULNERABILITY STATUS

      at Object.log (tests/security/websocket-client-security.test.js:398:15)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/security/websocket-client-security.test.js:399:15)

    console.log
      P0 CRITICAL:

      at log (tests/security/websocket-client-security.test.js:402:17)
          at Array.forEach (<anonymous>)

    console.log
        âœ… Registration ACK Spoofing: NOT FIXED

      at log (tests/security/websocket-client-security.test.js:407:19)
          at Array.forEach (<anonymous>)
          at Array.forEach (<anonymous>)

    console.log
        âš ï¸ Queue Overflow (no FIFO): PARTIAL - drops but no eviction

      at log (tests/security/websocket-client-security.test.js:407:19)
          at Array.forEach (<anonymous>)
          at Array.forEach (<anonymous>)

    console.log


      at log (tests/security/websocket-client-security.test.js:409:17)
          at Array.forEach (<anonymous>)

    console.log
      P1 HIGH:

      at log (tests/security/websocket-client-security.test.js:402:17)
          at Array.forEach (<anonymous>)

    console.log
        âœ… Timer Leaks: FIXED - cleanup verified

      at log (tests/security/websocket-client-security.test.js:407:19)
          at Array.forEach (<anonymous>)
          at Array.forEach (<anonymous>)

    console.log
        âš ï¸ Race Conditions: PARTIAL - flag exists, not tested

      at log (tests/security/websocket-client-security.test.js:407:19)
          at Array.forEach (<anonymous>)
          at Array.forEach (<anonymous>)

    console.log
        âœ… Message Injection: NOT FIXED - no validation

      at log (tests/security/websocket-client-security.test.js:407:19)
          at Array.forEach (<anonymous>)
          at Array.forEach (<anonymous>)

    console.log


      at log (tests/security/websocket-client-security.test.js:409:17)
          at Array.forEach (<anonymous>)

    console.log
      P2 MEDIUM:

      at log (tests/security/websocket-client-security.test.js:402:17)
          at Array.forEach (<anonymous>)

    console.log
        âœ… Replay Attacks: NOT FIXED - no nonces/timestamps

      at log (tests/security/websocket-client-security.test.js:407:19)
          at Array.forEach (<anonymous>)
          at Array.forEach (<anonymous>)

    console.log


      at log (tests/security/websocket-client-security.test.js:409:17)
          at Array.forEach (<anonymous>)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/security/websocket-client-security.test.js:412:15)

    console.log
      
      Security Test Coverage:

      at Object.log (tests/security/websocket-client-security.test.js:427:15)

    console.log
        Total tests: 27

      at Object.log (tests/security/websocket-client-security.test.js:428:15)

    console.log
        Implemented: 18

      at Object.log (tests/security/websocket-client-security.test.js:429:15)

    console.log
        Skipped: 9

      at Object.log (tests/security/websocket-client-security.test.js:430:15)

    console.log
        Coverage: 66.7%

      at Object.log (tests/security/websocket-client-security.test.js:431:15)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should have registration timeout mechanism

    expect(received).toContain(expected) // indexOf

    Expected substring: "registrationTimeout"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      35 |     it('should have registration timeout mechanism', () => {
      36 |       // Verify timeout exists (5 seconds)
    > 37 |       expect(backgroundJs).toContain('registrationTimeout');
         |                            ^
      38 |       expect(backgroundJs).toContain('5000'); // 5 second timeout
      39 |
      40 |       // Verify timeout handler exists

      at Object.toContain (tests/security/websocket-client-security.test.js:37:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should clear registration timeout on valid ACK

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      47 |       const clearTimeoutIndex = backgroundJs.indexOf('clearTimeout(registrationTimeout)', ackHandlerIndex);
      48 |
    > 49 |       expect(clearTimeoutIndex).toBeGreaterThan(ackHandlerIndex);
         |                                 ^
      50 |     });
      51 |
      52 |     it('should set registration flags on ACK', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:49:33)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should set registration flags on ACK

    expect(received).toContain(expected) // indexOf

    Expected substring: "isRegistered = true"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      52 |     it('should set registration flags on ACK', () => {
      53 |       // Verify state changes on ACK
    > 54 |       expect(backgroundJs).toContain('isRegistered = true');
         |                            ^
      55 |       expect(backgroundJs).toContain('registrationPending = false');
      56 |     });
      57 |

      at Object.toContain (tests/security/websocket-client-security.test.js:54:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should timeout if ACK not received within 5 seconds

    expect(received).toBeTruthy()

    Received: null

      108 |       // Verify timeout mechanism exists
      109 |       const timeoutCode = backgroundJs.match(/setTimeout\([^)]+,\s*5000\)/);
    > 110 |       expect(timeoutCode).toBeTruthy();
          |                           ^
      111 |
      112 |       // Verify reconnection triggered on timeout
      113 |       expect(backgroundJs).toContain('Registration timeout, reconnecting');

      at Object.toBeTruthy (tests/security/websocket-client-security.test.js:110:27)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should enforce MAX_QUEUE_SIZE limit

    expect(received).toContain(expected) // indexOf

    Expected substring: "const MAX_QUEUE_SIZE = 100"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      122 |     it('should enforce MAX_QUEUE_SIZE limit', () => {
      123 |       // Verify MAX_QUEUE_SIZE constant exists
    > 124 |       expect(backgroundJs).toContain('const MAX_QUEUE_SIZE = 100');
          |                            ^
      125 |
      126 |       // Verify bounds check exists
      127 |       expect(backgroundJs).toContain('if (messageQueue.length >= MAX_QUEUE_SIZE)');

      at Object.toContain (tests/security/websocket-client-security.test.js:124:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should drop messages when queue is full

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      134 |       const returnIndex = backgroundJs.indexOf('return false', queueCheckIndex);
      135 |
    > 136 |       expect(returnIndex).toBeGreaterThan(queueCheckIndex);
          |                           ^
      137 |       expect(returnIndex - queueCheckIndex).toBeLessThan(200); // Within ~200 chars
      138 |     });
      139 |

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:136:27)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should clear queue on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "messageQueue.length = 0"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      160 |     it('should clear queue on disconnect', () => {
      161 |       // Verify queue is cleared (security: prevent stale message replay)
    > 162 |       expect(backgroundJs).toContain('messageQueue.length = 0');
          |                            ^
      163 |       expect(backgroundJs).toContain('Clearing');
      164 |     });
      165 |

      at Object.toContain (tests/security/websocket-client-security.test.js:162:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should handle queue drain errors gracefully

    expect(received).toContain(expected) // indexOf

    Expected substring: "Failed to send queued message"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      166 |     it('should handle queue drain errors gracefully', () => {
      167 |       // Verify error handling during drain
    > 168 |       expect(backgroundJs).toContain('Failed to send queued message');
          |                            ^
      169 |
      170 |       // Verify message put back on error
      171 |       expect(backgroundJs).toContain('messageQueue.unshift(queued)');

      at Object.toContain (tests/security/websocket-client-security.test.js:168:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up timer on withTimeout success

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      182 |       const successCleanup = backgroundJs.indexOf('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success', withTimeoutIndex);
      183 |
    > 184 |       expect(successCleanup).toBeGreaterThan(withTimeoutIndex);
          |                              ^
      185 |     });
      186 |
      187 |     it('should clean up timer on withTimeout error', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:184:30)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up timer on withTimeout error

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      189 |       const errorCleanup = backgroundJs.indexOf('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error', withTimeoutIndex);
      190 |
    > 191 |       expect(errorCleanup).toBeGreaterThan(withTimeoutIndex);
          |                            ^
      192 |     });
      193 |
      194 |     it('should clean up registration timeout on success', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:191:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up registration timeout on success

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      197 |       const clearIndex = backgroundJs.indexOf('clearTimeout(registrationTimeout)', ackIndex);
      198 |
    > 199 |       expect(clearIndex).toBeGreaterThan(ackIndex);
          |                          ^
      200 |     });
      201 |
      202 |     it('should clean up registration timeout on disconnect', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:199:26)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up registration timeout on disconnect

    expect(received).toBeGreaterThan(expected)

    Expected: > 6120
    Received:   -1

      205 |       const clearIndex = backgroundJs.indexOf('clearTimeout(registrationTimeout)', oncloseIndex);
      206 |
    > 207 |       expect(clearIndex).toBeGreaterThan(oncloseIndex);
          |                          ^
      208 |     });
      209 |
      210 |     it.skip('should verify no timer leaks with stress test (NOT IMPLEMENTED)', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:207:26)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Race Condition - Duplicate Connections â€º should have isConnecting flag to prevent duplicates

    expect(received).toContain(expected) // indexOf

    Expected substring: "let isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      231 |     it('should have isConnecting flag to prevent duplicates', () => {
      232 |       // Verify flag exists
    > 233 |       expect(backgroundJs).toContain('let isConnecting = false');
          |                            ^
      234 |
      235 |       // Verify check exists
      236 |       expect(backgroundJs).toContain('if (isConnecting)');

      at Object.toContain (tests/security/websocket-client-security.test.js:233:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Race Condition - Duplicate Connections â€º should set isConnecting before creating WebSocket

    expect(received).toContain(expected) // indexOf

    Expected substring: "isConnecting = true"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      240 |     it('should set isConnecting before creating WebSocket', () => {
      241 |       // Verify flag set before connection
    > 242 |       expect(backgroundJs).toContain('isConnecting = true');
          |                            ^
      243 |
      244 |       // Verify flag cleared on error
      245 |       expect(backgroundJs).toContain('isConnecting = false');

      at Object.toContain (tests/security/websocket-client-security.test.js:242:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Message Injection via Queue â€º should validate message structure before queueing

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      272 |       const queuePushIndex = backgroundJs.indexOf('messageQueue.push(message)', safeSendIndex);
      273 |
    > 274 |       expect(queuePushIndex).toBeGreaterThan(safeSendIndex);
          |                              ^
      275 |
      276 |       // âš ï¸  WARNING: No validation between safeSend and push
      277 |       // Gap = queuePushIndex - safeSendIndex

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:274:30)

FAIL tests/integration/adversarial-tests.test.js
  â— Test suite failed to run

    ENOENT: no such file or directory, open '/Users/gadievron/Documents/Claude Code/chrome-dev-assist/.auth-token'

      22 |
      23 | // Read auth token
    > 24 | const AUTH_TOKEN = fs.readFileSync(path.join(__dirname, '../../.auth-token'), 'utf8').trim();
         |                       ^
      25 |
      26 | // ========================================
      27 | // PRE-TEST CHECKLIST (TESTING_QUICK_REFERENCE.md)

      at Object.readFileSync (tests/integration/adversarial-tests.test.js:24:23)

FAIL tests/integration/edge-cases-stress.test.js
  â— Test suite failed to run

    ENOENT: no such file or directory, open '/Users/gadievron/Documents/Claude Code/chrome-dev-assist/.auth-token'

      14 |
      15 | // Read auth token
    > 16 | const AUTH_TOKEN = fs.readFileSync(path.join(__dirname, '../../.auth-token'), 'utf8').trim();
         |                       ^
      17 |
      18 | describe('Edge Cases and Stress Tests', () => {
      19 |   let testTabs = [];

      at Object.readFileSync (tests/integration/edge-cases-stress.test.js:16:23)

PASS tests/unit/error-logger.test.js
PASS tests/unit/smarter-completion-detection.test.js
  â— Console

    console.log
      [Test] Page ready signal received for tab 123, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

    console.log
      [Test] Page ready signal received for tab 100, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

    console.log
      [Test] Page ready signal received for tab 123, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

    console.log
      [Test] Page ready signal received for tab 123, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

    console.log
      [Test] Page ready signal received for tab 123, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

    console.log
      [Test] Page ready signal received for tab 123, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

    console.log
      [Test] Page ready signal received for tab 123, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

    console.log
      [Test] Page ready signal received for tab 123, ending capture early

      at log (tests/unit/smarter-completion-detection.test.js:41:15)

PASS tests/boundary/tab-cleanup-boundary.test.js
  â— Console

    console.log
      [ChromeDevAssist] Background service worker started

      at Object.log (extension/background.js:19:9)

FAIL tests/integration/dogfooding.test.js
  â— Console

    console.log
      [Test Config] URL Mode: http

      at Object.log (tests/integration/dogfooding.test.js:26:9)

    console.log
      
      ğŸ§ª Testing: basic-test.html

      at Object.log (tests/integration/dogfooding.test.js:39:17)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/integration/dogfooding.test.js:40:17)

    console.log
      
      âŒ Testing: console-errors-test.html

      at Object.log (tests/integration/dogfooding.test.js:112:17)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/integration/dogfooding.test.js:113:17)

    console.log
      
      ğŸ“‹ Testing: console-mixed-test.html

      at Object.log (tests/integration/dogfooding.test.js:178:17)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/integration/dogfooding.test.js:179:17)

    console.log
      
      ğŸ”„ Testing: Complete workflow with reload

      at Object.log (tests/integration/dogfooding.test.js:241:17)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/integration/dogfooding.test.js:242:17)

    console.log
      
      âš¡ Testing: Concurrent fixture loading

      at Object.log (tests/integration/dogfooding.test.js:302:17)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/integration/dogfooding.test.js:303:17)

    console.log
      âœ“ Cleaned up 0 tabs

      at Object.log (tests/integration/dogfooding.test.js:363:17)

  â— Dogfooding - Extension Testing Itself â€º Basic Test Fixture â€º opens basic test page and detects test identification

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Console Errors Test Fixture â€º captures expected errors from test page

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Mixed Console Output Test Fixture â€º captures mixed console output (logs, warnings, errors)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Complete Test Workflow â€º opens â†’ reloads â†’ captures â†’ closes test page

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Concurrent Fixture Testing â€º opens multiple test fixtures simultaneously

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/multi-feature-integration.test.js
  â— Console

    console.log
      
      ğŸ§ª Starting Multi-Feature Integration Test 1...

      at Object.log (tests/integration/multi-feature-integration.test.js:39:15)

    console.log
      ğŸ“‚ Opening: http://localhost:9876/fixtures/integration-test-1.html?token=e4a6c53a98edaa7acff78816919ee2e1cda711e0848c63d39f9fc0525b4a883c

      at Object.log (tests/integration/multi-feature-integration.test.js:43:15)

    console.log
      
      ğŸ§ª Starting Console Levels Test...

      at Object.log (tests/integration/multi-feature-integration.test.js:121:15)

    console.log
      ğŸ“‚ Opening: http://localhost:9876/fixtures/integration-test-2.html?token=e4a6c53a98edaa7acff78816919ee2e1cda711e0848c63d39f9fc0525b4a883c

      at Object.log (tests/integration/multi-feature-integration.test.js:125:15)

    console.log
      
      ğŸ§ª Starting Tab Lifecycle Test...

      at Object.log (tests/integration/multi-feature-integration.test.js:187:15)

    console.log
      
      ğŸ§ª Starting Test Orchestration Test...

      at Object.log (tests/integration/multi-feature-integration.test.js:234:15)

    console.log
      ğŸ¬ Starting test: integration-test-1761524703189

      at Object.log (tests/integration/multi-feature-integration.test.js:239:15)

    console.log
      
      ======================================================================

      at Object.log (tests/integration/multi-feature-integration.test.js:298:15)

    console.log
      ğŸ‰ MULTI-FEATURE INTEGRATION TESTS COMPLETE

      at Object.log (tests/integration/multi-feature-integration.test.js:299:15)

    console.log
      ======================================================================

      at Object.log (tests/integration/multi-feature-integration.test.js:300:15)

    console.log
      
      âœ… Features Tested:

      at Object.log (tests/integration/multi-feature-integration.test.js:301:15)

    console.log
         1. URL Opening (openUrl)

      at Object.log (tests/integration/multi-feature-integration.test.js:302:15)

    console.log
         2. Console Log Capture (captureLogs)

      at Object.log (tests/integration/multi-feature-integration.test.js:303:15)

    console.log
         3. Screenshot Capture (captureScreenshot)

      at Object.log (tests/integration/multi-feature-integration.test.js:304:15)

    console.log
         4. Page Metadata Extraction (getPageMetadata)

      at Object.log (tests/integration/multi-feature-integration.test.js:305:15)

    console.log
         5. Tab Reloading (reloadTab)

      at Object.log (tests/integration/multi-feature-integration.test.js:306:15)

    console.log
         6. Tab Closing (closeTab)

      at Object.log (tests/integration/multi-feature-integration.test.js:307:15)

    console.log
         7. Test Orchestration (startTest, endTest)

      at Object.log (tests/integration/multi-feature-integration.test.js:308:15)

    console.log
         8. Auto-Cleanup (verifyCleanup)

      at Object.log (tests/integration/multi-feature-integration.test.js:309:15)

    console.log
      
      âœ… Integration Scenarios:

      at Object.log (tests/integration/multi-feature-integration.test.js:310:15)

    console.log
         â€¢ Console + Screenshot + Metadata

      at Object.log (tests/integration/multi-feature-integration.test.js:311:15)

    console.log
         â€¢ Multiple Console Levels

      at Object.log (tests/integration/multi-feature-integration.test.js:312:15)

    console.log
         â€¢ Tab Lifecycle Management

      at Object.log (tests/integration/multi-feature-integration.test.js:313:15)

    console.log
         â€¢ Test Orchestration with Auto-Cleanup

      at Object.log (tests/integration/multi-feature-integration.test.js:314:15)

    console.log
      
      âœ… All integration tests passed!

      at Object.log (tests/integration/multi-feature-integration.test.js:315:15)

    console.log
      ======================================================================

      at Object.log (tests/integration/multi-feature-integration.test.js:316:15)

    console.log
      
      âœ… All tabs closed

      at Object.log (tests/integration/multi-feature-integration.test.js:34:13)

  â— Multi-Feature Integration Tests â€º Integration Test 1: Console + Screenshot + Metadata â€º should open page, capture logs, take screenshot, and extract metadata

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Multi-Feature Integration Tests â€º Integration Test 2: Console Level Verification â€º should capture all console levels (log, info, warn, error)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Multi-Feature Integration Tests â€º Integration Test 3: Tab Lifecycle with Capture â€º should open, reload, capture, and close tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Multi-Feature Integration Tests â€º Integration Test 4: Test Orchestration â€º should use test orchestration with auto-cleanup

    TypeError: chromeDevAssist.startTest is not a function

      238 |       // 1. Start test
      239 |       console.log(`ğŸ¬ Starting test: ${testId}`);
    > 240 |       const startResult = await chromeDevAssist.startTest(testId, { autoCleanup: true });
          |                                                 ^
      241 |
      242 |       expect(startResult.testId).toBe(testId);
      243 |       console.log(`âœ… Test started: ${startResult.testId}`);

      at Object.startTest (tests/integration/multi-feature-integration.test.js:240:49)

FAIL tests/integration/edge-cases-complete.test.js
  â— Edge Cases - Complete Coverage â€º Extension Not Found Scenarios â€º should error when extension ID does not exist

    expect(received).rejects.toThrow(expected)

    Expected pattern: /not found/
    Received message: "Invalid extensionId format (must be 32 lowercase letters a-p)"

          326 |   // Chrome extension IDs are lowercase letters a-p
          327 |   if (!/^[a-p]{32}$/.test(extensionId)) {
        > 328 |     throw new Error('Invalid extensionId format (must be 32 lowercase letters a-p)');
              |           ^
          329 |   }
          330 | }
          331 |

      at validateExtensionId (claude-code/index.js:328:11)
      at Object.validateExtensionId [as getExtensionInfo] (claude-code/index.js:100:3)
      at Object.getExtensionInfo (tests/integration/edge-cases-complete.test.js:29:25)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/edge-cases-complete.test.js:30:17)

  â— Edge Cases - Complete Coverage â€º Extension Not Found Scenarios â€º should error when reloading non-existent extension

    expect(received).rejects.toThrow(expected)

    Expected pattern: /not found/
    Received message: "Invalid extensionId format (must be 32 lowercase letters a-p)"

          326 |   // Chrome extension IDs are lowercase letters a-p
          327 |   if (!/^[a-p]{32}$/.test(extensionId)) {
        > 328 |     throw new Error('Invalid extensionId format (must be 32 lowercase letters a-p)');
              |           ^
          329 |   }
          330 | }
          331 |

      at validateExtensionId (claude-code/index.js:328:11)
      at Object.validateExtensionId [as reload] (claude-code/index.js:45:3)
      at Object.reload (tests/integration/edge-cases-complete.test.js:37:25)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/edge-cases-complete.test.js:38:17)

  â— Edge Cases - Complete Coverage â€º Extension Not Found Scenarios â€º should error when enabling non-existent extension

    TypeError: chromeDevAssist.enableExtension is not a function

      43 |
      44 |       await expect(
    > 45 |         chromeDevAssist.enableExtension(fakeId)
         |                         ^
      46 |       ).rejects.toThrow();
      47 |     });
      48 |   });

      at Object.enableExtension (tests/integration/edge-cases-complete.test.js:45:25)

  â— Edge Cases - Complete Coverage â€º Tab Not Found Scenarios â€º should error when getting metadata from non-existent tab

    TypeError: chromeDevAssist.getPageMetadata is not a function

      70 |
      71 |       await expect(
    > 72 |         chromeDevAssist.getPageMetadata(fakeTabId)
         |                         ^
      73 |       ).rejects.toThrow();
      74 |     });
      75 |   });

      at Object.getPageMetadata (tests/integration/edge-cases-complete.test.js:72:25)

  â— Edge Cases - Complete Coverage â€º Tab Already Closed Scenario â€º should handle attempting to close already-closed tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Console Timing Functions â€º should capture console.time and console.timeEnd

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject nested/overlapping tests

    TypeError: chromeDevAssist.startTest is not a function

      136 |
      137 |       // Start first test
    > 138 |       await chromeDevAssist.startTest(testId);
          |                             ^
      139 |
      140 |       // Try to start another - should fail
      141 |       await expect(

      at Object.startTest (tests/integration/edge-cases-complete.test.js:138:29)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should work with autoCleanup disabled

    TypeError: chromeDevAssist.startTest is not a function

      152 |
      153 |       // Start test with cleanup disabled
    > 154 |       await chromeDevAssist.startTest(testId, {
          |                             ^
      155 |         autoCleanup: false
      156 |       });
      157 |

      at Object.startTest (tests/integration/edge-cases-complete.test.js:154:29)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject ending test that is not active

    TypeError: chromeDevAssist.endTest is not a function

      180 |     test('should reject ending test that is not active', async () => {
      181 |       await expect(
    > 182 |         chromeDevAssist.endTest('non-existent-test-id')
          |                         ^
      183 |       ).rejects.toThrow(/No active test/);
      184 |     });
      185 |

      at Object.endTest (tests/integration/edge-cases-complete.test.js:182:25)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject aborting test that is not active

    TypeError: chromeDevAssist.abortTest is not a function

      186 |     test('should reject aborting test that is not active', async () => {
      187 |       await expect(
    > 188 |         chromeDevAssist.abortTest('non-existent-test-id')
          |                         ^
      189 |       ).rejects.toThrow(/No active test/);
      190 |     });
      191 |

      at Object.abortTest (tests/integration/edge-cases-complete.test.js:188:25)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject ending test with wrong ID

    TypeError: chromeDevAssist.startTest is not a function

      193 |       testId = 'test-wrong-id-' + Date.now();
      194 |
    > 195 |       await chromeDevAssist.startTest(testId);
          |                             ^
      196 |
      197 |       // Try to end with different ID
      198 |       await expect(

      at Object.startTest (tests/integration/edge-cases-complete.test.js:195:29)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should validate test ID format

    TypeError: chromeDevAssist.startTest is not a function

      207 |       // Test IDs with invalid characters should be rejected
      208 |       await expect(
    > 209 |         chromeDevAssist.startTest('test with spaces')
          |                         ^
      210 |       ).rejects.toThrow(/invalid characters/);
      211 |
      212 |       await expect(

      at Object.startTest (tests/integration/edge-cases-complete.test.js:209:25)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject very long test ID

    TypeError: chromeDevAssist.startTest is not a function

      223 |
      224 |       await expect(
    > 225 |         chromeDevAssist.startTest(longId)
          |                         ^
      226 |       ).rejects.toThrow(/too long/);
      227 |     });
      228 |   });

      at Object.startTest (tests/integration/edge-cases-complete.test.js:225:25)

  â— Edge Cases - Complete Coverage â€º Extension Reload - Cannot Reload Self â€º should prevent reloading Chrome Dev Assist itself

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Console Capture Duration Edge Cases â€º should handle very short capture duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Hard Reload (Cache Bypass) â€º should perform hard reload with cache bypass

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Cleanup Verification Edge Cases â€º should detect all orphaned tabs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Cleanup Verification Edge Cases â€º should verify cleanup when all tabs actually closed

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Permission Checks â€º should include mayDisable in extension info

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Permission Checks â€º should verify all expected permissions exist

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/meta/test-reality-check.test.js
  â— Console

    console.warn
      âš ï¸  Potential fake tests detected:

       96 |
       97 |       if (filesWithLocalMocks.length > 0) {
    >  98 |         console.warn('âš ï¸  Potential fake tests detected:');
          |                 ^
       99 |         filesWithLocalMocks.forEach(({ file, pattern }) => {
      100 |           console.warn(`   ${file}: ${pattern}`);
      101 |         });

      at Object.warn (tests/meta/test-reality-check.test.js:98:17)

    console.warn
         tests/unit/timeout-wrapper.test.js: ^async function withTimeout\(

       98 |         console.warn('âš ï¸  Potential fake tests detected:');
       99 |         filesWithLocalMocks.forEach(({ file, pattern }) => {
    > 100 |           console.warn(`   ${file}: ${pattern}`);
          |                   ^
      101 |         });
      102 |       }
      103 |

      at warn (tests/meta/test-reality-check.test.js:100:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:99:29)

    console.warn
      âš ï¸  Unit tests without imports detected:

      131 |
      132 |       if (filesWithoutImports.length > 0) {
    > 133 |         console.warn('âš ï¸  Unit tests without imports detected:');
          |                 ^
      134 |         filesWithoutImports.forEach(file => {
      135 |           console.warn(`   ${file}`);
      136 |         });

      at Object.warn (tests/meta/test-reality-check.test.js:133:17)

    console.warn
         tests/unit/clean-shutdown-detection.test.js

      133 |         console.warn('âš ï¸  Unit tests without imports detected:');
      134 |         filesWithoutImports.forEach(file => {
    > 135 |           console.warn(`   ${file}`);
          |                   ^
      136 |         });
      137 |       }
      138 |

      at warn (tests/meta/test-reality-check.test.js:135:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:134:29)

    console.warn
         tests/unit/smarter-completion-detection.test.js

      133 |         console.warn('âš ï¸  Unit tests without imports detected:');
      134 |         filesWithoutImports.forEach(file => {
    > 135 |           console.warn(`   ${file}`);
          |                   ^
      136 |         });
      137 |       }
      138 |

      at warn (tests/meta/test-reality-check.test.js:135:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:134:29)

    console.warn
         tests/unit/tab-operations-timeout.test.js

      133 |         console.warn('âš ï¸  Unit tests without imports detected:');
      134 |         filesWithoutImports.forEach(file => {
    > 135 |           console.warn(`   ${file}`);
          |                   ^
      136 |         });
      137 |       }
      138 |

      at warn (tests/meta/test-reality-check.test.js:135:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:134:29)

    console.warn
      âš ï¸  Critical functions without tests:

      229 |
      230 |       if (missingTests.length > 0) {
    > 231 |         console.warn('âš ï¸  Critical functions without tests:');
          |                 ^
      232 |         missingTests.forEach(func => {
      233 |           console.warn(`   - ${func}`);
      234 |         });

      at Object.warn (tests/meta/test-reality-check.test.js:231:17)

    console.warn
         - withTimeout (not found in production)

      231 |         console.warn('âš ï¸  Critical functions without tests:');
      232 |         missingTests.forEach(func => {
    > 233 |           console.warn(`   - ${func}`);
          |                   ^
      234 |         });
      235 |       }
      236 |

      at warn (tests/meta/test-reality-check.test.js:233:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:232:22)

    console.warn
         - safeSend (not found in production)

      231 |         console.warn('âš ï¸  Critical functions without tests:');
      232 |         missingTests.forEach(func => {
    > 233 |           console.warn(`   - ${func}`);
          |                   ^
      234 |         });
      235 |       }
      236 |

      at warn (tests/meta/test-reality-check.test.js:233:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:232:22)

    console.warn
         - scheduleReconnect (not found in production)

      231 |         console.warn('âš ï¸  Critical functions without tests:');
      232 |         missingTests.forEach(func => {
    > 233 |           console.warn(`   - ${func}`);
          |                   ^
      234 |         });
      235 |       }
      236 |

      at warn (tests/meta/test-reality-check.test.js:233:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:232:22)

    console.log
      
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/meta/test-reality-check.test.js:285:15)

    console.log
      TEST CLASSIFICATION ANALYSIS

      at Object.log (tests/meta/test-reality-check.test.js:286:15)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/meta/test-reality-check.test.js:287:15)

    console.log
      Behavior tests:      189 (48.7%)

      at Object.log (tests/meta/test-reality-check.test.js:288:15)

    console.log
      Verification tests:  176 (45.4%)

      at Object.log (tests/meta/test-reality-check.test.js:289:15)

    console.log
      Other tests:         23

      at Object.log (tests/meta/test-reality-check.test.js:290:15)

    console.log
      Total tests:         388

      at Object.log (tests/meta/test-reality-check.test.js:291:15)

    console.log
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      at Object.log (tests/meta/test-reality-check.test.js:292:15)

    console.log
      
      Files with verification tests:

      at Object.log (tests/meta/test-reality-check.test.js:333:17)

    console.log
        - tests/integration/chrome-crash-prevention.test.js: 17 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/console-error-crash-detection.test.js: 24 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/edge-cases-stress.test.js: 5 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/improvements-6-7-8.test.js: 10 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/improvements-verification.test.js: 25 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/multi-feature-integration.test.js: 5 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/reconnection-behavior.test.js: 10 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/reload-button-fix.test.js: 16 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/resource-cleanup.test.js: 15 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/integration/screenshot-security.test.js: 6 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/security/websocket-client-security.test.js: 18 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
        - tests/unit/timeout-wrapper.test.js: 25 verification tests

      at log (tests/meta/test-reality-check.test.js:335:19)
          at Array.forEach (<anonymous>)

    console.log
      Total: 176 verification tests

      at Object.log (tests/meta/test-reality-check.test.js:337:17)

    console.warn
      âš ï¸  Test file without assertions: tests/unit/websocket-connection-stability.test.js

      370 |
      371 |         if (hasIt && !hasExpect) {
    > 372 |           console.warn(`âš ï¸  Test file without assertions: ${testFile}`);
          |                   ^
      373 |         }
      374 |       });
      375 |     });

      at warn (tests/meta/test-reality-check.test.js:372:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-reality-check.test.js:364:17)

  â— Test Reality Check - Verify Tests Test Production Code â€º Critical Production Functions â€º should verify withTimeout is tested against production code

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      26 |
      27 |       // Verify production code has withTimeout
    > 28 |       expect(backgroundJs).toContain('async function withTimeout(');
         |                            ^
      29 |
      30 |       // Verify test file has verification tests
      31 |       expect(testFile).toContain('should verify withTimeout exists in background.js');

      at Object.toContain (tests/meta/test-reality-check.test.js:28:28)

  â— Test Reality Check - Verify Tests Test Production Code â€º Critical Production Functions â€º should verify safeSend is tested against production code

    expect(received).toContain(expected) // indexOf

    Expected substring: "function safeSend("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      39 |
      40 |       // Verify safeSend exists in production
    > 41 |       expect(backgroundJs).toContain('function safeSend(');
         |                            ^
      42 |       expect(backgroundJs).toContain('messageQueue'); // Part of Improvement 7
      43 |     });
      44 |

      at Object.toContain (tests/meta/test-reality-check.test.js:41:28)

  â— Test Reality Check - Verify Tests Test Production Code â€º Critical Production Functions â€º should verify registration ACK is tested against production code

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (message.type === 'registration-ack')"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      55 |
      56 |       // Verify registration ACK in extension
    > 57 |       expect(backgroundJs).toContain("if (message.type === 'registration-ack')");
         |                            ^
      58 |
      59 |       // Verify registration ACK in server
      60 |       expect(serverJs).toContain("type: 'registration-ack'");

      at Object.toContain (tests/meta/test-reality-check.test.js:57:28)

  â— Test Reality Check - Verify Tests Test Production Code â€º Verification Test Pattern â€º should verify critical implementations exist in production files

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      166 |
      167 |       // Improvement 8: Timeout wrapper
    > 168 |       expect(backgroundJs).toContain('async function withTimeout(');
          |                            ^
      169 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle)');
      170 |
      171 |       // Improvement 7: Message queuing

      at Object.toContain (tests/meta/test-reality-check.test.js:168:28)

FAIL tests/meta/test-quality.test.js
  â— Console

    console.warn
      Tests with fewer assertions than test blocks:

      180 |     // Some tests might use other assertion methods, so allow some flexibility
      181 |     if (noAssertions.length > 0) {
    > 182 |       console.warn('Tests with fewer assertions than test blocks:');
          |               ^
      183 |       noAssertions.forEach(t => {
      184 |         console.warn(`  ${t.file}: ${t.tests} tests, ${t.assertions} assertions`);
      185 |       });

      at Object.warn (tests/meta/test-quality.test.js:182:15)

    console.warn
        tests/integration/console-error-crash-detection.test.js: 24 tests, 16 assertions

      182 |       console.warn('Tests with fewer assertions than test blocks:');
      183 |       noAssertions.forEach(t => {
    > 184 |         console.warn(`  ${t.file}: ${t.tests} tests, ${t.assertions} assertions`);
          |                 ^
      185 |       });
      186 |     }
      187 |

      at warn (tests/meta/test-quality.test.js:184:17)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-quality.test.js:183:20)

    console.warn
        tests/integration/resource-cleanup.test.js: 15 tests, 13 assertions

      182 |       console.warn('Tests with fewer assertions than test blocks:');
      183 |       noAssertions.forEach(t => {
    > 184 |         console.warn(`  ${t.file}: ${t.tests} tests, ${t.assertions} assertions`);
          |                 ^
      185 |       });
      186 |     }
      187 |

      at warn (tests/meta/test-quality.test.js:184:17)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-quality.test.js:183:20)

    console.warn
        tests/unit/hard-reload.test.js: 6 tests, 2 assertions

      182 |       console.warn('Tests with fewer assertions than test blocks:');
      183 |       noAssertions.forEach(t => {
    > 184 |         console.warn(`  ${t.file}: ${t.tests} tests, ${t.assertions} assertions`);
          |                 ^
      185 |       });
      186 |     }
      187 |

      at warn (tests/meta/test-quality.test.js:184:17)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-quality.test.js:183:20)

    console.warn
        tests/unit/websocket-connection-stability.test.js: 30 tests, 0 assertions

      182 |       console.warn('Tests with fewer assertions than test blocks:');
      183 |       noAssertions.forEach(t => {
    > 184 |         console.warn(`  ${t.file}: ${t.tests} tests, ${t.assertions} assertions`);
          |                 ^
      185 |       });
      186 |     }
      187 |

      at warn (tests/meta/test-quality.test.js:184:17)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-quality.test.js:183:20)

    console.warn
      Test files defining implementation-like functions:

      226 |
      227 |     if (suspiciousPatterns.length > 0) {
    > 228 |       console.warn('Test files defining implementation-like functions:');
          |               ^
      229 |       suspiciousPatterns.forEach(s => {
      230 |         console.warn(`  ${s.file}: ${s.pattern}`);
      231 |       });

      at Object.warn (tests/meta/test-quality.test.js:228:15)

    console.warn
        tests/integration/phase-1.1.test.js: Send function

      228 |       console.warn('Test files defining implementation-like functions:');
      229 |       suspiciousPatterns.forEach(s => {
    > 230 |         console.warn(`  ${s.file}: ${s.pattern}`);
          |                 ^
      231 |       });
      232 |     }
      233 |

      at warn (tests/meta/test-quality.test.js:230:17)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-quality.test.js:229:26)

    console.warn
      Misplaced test files:

      276 |
      277 |     if (misplaced.length > 0) {
    > 278 |       console.warn('Misplaced test files:');
          |               ^
      279 |       misplaced.forEach(m => {
      280 |         console.warn(`  ${m.file} â†’ should be in ${m.shouldBe}`);
      281 |       });

      at Object.warn (tests/meta/test-quality.test.js:278:15)

    console.warn
        tests/integration/screenshot-security.test.js â†’ should be in tests/security/

      278 |       console.warn('Misplaced test files:');
      279 |       misplaced.forEach(m => {
    > 280 |         console.warn(`  ${m.file} â†’ should be in ${m.shouldBe}`);
          |                 ^
      281 |       });
      282 |     }
      283 |

      at warn (tests/meta/test-quality.test.js:280:17)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/meta/test-quality.test.js:279:17)

  â— Testing Expert: Fake Test Detection â€º all test files should import real implementations

    Fake tests detected:
      - tests/crash-recovery.test.js: Only uses mocks, never imports real implementation
      - tests/unit/clean-shutdown-detection.test.js: Defines functions but does not import real implementation
      - tests/unit/clean-shutdown-detection.test.js: Only uses mocks, never imports real implementation
      - tests/unit/smarter-completion-detection.test.js: Only uses mocks, never imports real implementation
      - tests/unit/tab-operations-timeout.test.js: Only uses mocks, never imports real implementation

      57 |       const message = 'Fake tests detected:\n' +
      58 |         fakeTests.map(t => `  - ${t.file}: ${t.reason}`).join('\n');
    > 59 |       throw new Error(message);
         |             ^
      60 |     }
      61 |
      62 |     expect(fakeTests).toEqual([]);

      at Object.<anonymous> (tests/meta/test-quality.test.js:59:13)

  â— Testing Expert: Test Organization â€º test files should be in appropriate directories

    expect(received).toEqual(expected) // deep equality

    - Expected  - 1
    + Received  + 6

    - Array []
    + Array [
    +   Object {
    +     "file": "tests/integration/screenshot-security.test.js",
    +     "shouldBe": "tests/security/",
    +   },
    + ]

      282 |     }
      283 |
    > 284 |     expect(misplaced).toEqual([]);
          |                       ^
      285 |   });
      286 |
      287 |   test('all personas should have test coverage', () => {

      at Object.toEqual (tests/meta/test-quality.test.js:284:23)

FAIL tests/unit/test-orchestration.test.js
  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject missing testId

    TypeError: chromeDevAssist.startTest is not a function

      20 |
      21 |       test('should reject missing testId', async () => {
    > 22 |         await expect(chromeDevAssist.startTest(null))
         |                                      ^
      23 |           .rejects.toThrow('testId is required');
      24 |       });
      25 |

      at Object.startTest (tests/unit/test-orchestration.test.js:22:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject non-string testId

    TypeError: chromeDevAssist.startTest is not a function

      25 |
      26 |       test('should reject non-string testId', async () => {
    > 27 |         await expect(chromeDevAssist.startTest(123))
         |                                      ^
      28 |           .rejects.toThrow('testId is required and must be a string');
      29 |       });
      30 |

      at Object.startTest (tests/unit/test-orchestration.test.js:27:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject testId that is too long

    TypeError: chromeDevAssist.startTest is not a function

      31 |       test('should reject testId that is too long', async () => {
      32 |         const longId = 'a'.repeat(101);
    > 33 |         await expect(chromeDevAssist.startTest(longId))
         |                                      ^
      34 |           .rejects.toThrow('testId too long');
      35 |       });
      36 |

      at Object.startTest (tests/unit/test-orchestration.test.js:33:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject testId with invalid characters

    TypeError: chromeDevAssist.startTest is not a function

      36 |
      37 |       test('should reject testId with invalid characters', async () => {
    > 38 |         await expect(chromeDevAssist.startTest('test;DROP TABLE'))
         |                                      ^
      39 |           .rejects.toThrow('testId contains invalid characters');
      40 |       });
      41 |

      at Object.startTest (tests/unit/test-orchestration.test.js:38:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should accept valid testId

    TypeError: chromeDevAssist.startTest is not a function

      42 |       test('should accept valid testId', async () => {
      43 |         // This will fail with WebSocket connection error, but validates parameter handling
    > 44 |         const promise = chromeDevAssist.startTest('test-001');
         |                                         ^
      45 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      46 |       });
      47 |

      at Object.startTest (tests/unit/test-orchestration.test.js:44:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should accept valid testId with underscores

    TypeError: chromeDevAssist.startTest is not a function

      47 |
      48 |       test('should accept valid testId with underscores', async () => {
    > 49 |         const promise = chromeDevAssist.startTest('test_001');
         |                                         ^
      50 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      51 |       });
      52 |

      at Object.startTest (tests/unit/test-orchestration.test.js:49:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should accept valid testId with options

    TypeError: chromeDevAssist.startTest is not a function

      52 |
      53 |       test('should accept valid testId with options', async () => {
    > 54 |         const promise = chromeDevAssist.startTest('test-001', { autoCleanup: false });
         |                                         ^
      55 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      56 |       });
      57 |     });

      at Object.startTest (tests/unit/test-orchestration.test.js:54:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should reject missing testId

    TypeError: chromeDevAssist.endTest is not a function

      60 |
      61 |       test('should reject missing testId', async () => {
    > 62 |         await expect(chromeDevAssist.endTest(null)).rejects.toThrow('testId is required');
         |                                      ^
      63 |       });
      64 |
      65 |       test('should reject non-string testId', async () => {

      at Object.endTest (tests/unit/test-orchestration.test.js:62:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should reject non-string testId

    TypeError: chromeDevAssist.endTest is not a function

      64 |
      65 |       test('should reject non-string testId', async () => {
    > 66 |         await expect(chromeDevAssist.endTest(123)).rejects.toThrow('testId is required and must be a string');
         |                                      ^
      67 |       });
      68 |
      69 |       test('should reject invalid result value', async () => {

      at Object.endTest (tests/unit/test-orchestration.test.js:66:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should reject invalid result value

    TypeError: chromeDevAssist.endTest is not a function

      68 |
      69 |       test('should reject invalid result value', async () => {
    > 70 |         await expect(chromeDevAssist.endTest('test-001', 'invalid'))
         |                                      ^
      71 |           .rejects.toThrow('result must be one of: passed, failed, aborted');
      72 |       });
      73 |

      at Object.endTest (tests/unit/test-orchestration.test.js:70:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should accept valid result: passed

    TypeError: chromeDevAssist.endTest is not a function

      73 |
      74 |       test('should accept valid result: passed', async () => {
    > 75 |         const promise = chromeDevAssist.endTest('test-001', 'passed');
         |                                         ^
      76 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      77 |       });
      78 |

      at Object.endTest (tests/unit/test-orchestration.test.js:75:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should accept valid result: failed

    TypeError: chromeDevAssist.endTest is not a function

      78 |
      79 |       test('should accept valid result: failed', async () => {
    > 80 |         const promise = chromeDevAssist.endTest('test-001', 'failed');
         |                                         ^
      81 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      82 |       });
      83 |

      at Object.endTest (tests/unit/test-orchestration.test.js:80:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should accept valid result: aborted

    TypeError: chromeDevAssist.endTest is not a function

      83 |
      84 |       test('should accept valid result: aborted', async () => {
    > 85 |         const promise = chromeDevAssist.endTest('test-001', 'aborted');
         |                                         ^
      86 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      87 |       });
      88 |

      at Object.endTest (tests/unit/test-orchestration.test.js:85:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should default to result=passed if not specified

    TypeError: chromeDevAssist.endTest is not a function

      88 |
      89 |       test('should default to result=passed if not specified', async () => {
    > 90 |         const promise = chromeDevAssist.endTest('test-001');
         |                                         ^
      91 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      92 |       });
      93 |     });

      at Object.endTest (tests/unit/test-orchestration.test.js:90:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º getTestStatus() â€º should not require parameters

    TypeError: chromeDevAssist.getTestStatus is not a function

       96 |
       97 |       test('should not require parameters', async () => {
    >  98 |         const promise = chromeDevAssist.getTestStatus();
          |                                         ^
       99 |
      100 |         await expect(promise).rejects.toThrow(); // WebSocket error expected (but params valid)
      101 |       });

      at Object.getTestStatus (tests/unit/test-orchestration.test.js:98:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should reject missing testId

    TypeError: chromeDevAssist.abortTest is not a function

      105 |
      106 |       test('should reject missing testId', async () => {
    > 107 |         await expect(chromeDevAssist.abortTest(null)).rejects.toThrow('testId is required');
          |                                      ^
      108 |       });
      109 |
      110 |       test('should reject non-string testId', async () => {

      at Object.abortTest (tests/unit/test-orchestration.test.js:107:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should reject non-string testId

    TypeError: chromeDevAssist.abortTest is not a function

      109 |
      110 |       test('should reject non-string testId', async () => {
    > 111 |         await expect(chromeDevAssist.abortTest(123)).rejects.toThrow('testId is required and must be a string');
          |                                      ^
      112 |       });
      113 |
      114 |       test('should accept valid testId with reason', async () => {

      at Object.abortTest (tests/unit/test-orchestration.test.js:111:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should accept valid testId with reason

    TypeError: chromeDevAssist.abortTest is not a function

      113 |
      114 |       test('should accept valid testId with reason', async () => {
    > 115 |         const promise = chromeDevAssist.abortTest('test-001', 'Test timeout');
          |                                         ^
      116 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      117 |       });
      118 |

      at Object.abortTest (tests/unit/test-orchestration.test.js:115:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should accept valid testId without reason (uses default)

    TypeError: chromeDevAssist.abortTest is not a function

      118 |
      119 |       test('should accept valid testId without reason (uses default)', async () => {
    > 120 |         const promise = chromeDevAssist.abortTest('test-001');
          |                                         ^
      121 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      122 |       });
      123 |     });

      at Object.abortTest (tests/unit/test-orchestration.test.js:120:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º verifyCleanup() â€º should accept empty expectedClosedTabs (defaults to [])

    TypeError: chromeDevAssist.verifyCleanup is not a function

      126 |
      127 |       test('should accept empty expectedClosedTabs (defaults to [])', async () => {
    > 128 |         const promise = chromeDevAssist.verifyCleanup();
          |                                         ^
      129 |
      130 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      131 |       });

      at Object.verifyCleanup (tests/unit/test-orchestration.test.js:128:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º verifyCleanup() â€º should accept array of tab IDs

    TypeError: chromeDevAssist.verifyCleanup is not a function

      132 |
      133 |       test('should accept array of tab IDs', async () => {
    > 134 |         const promise = chromeDevAssist.verifyCleanup({
          |                                         ^
      135 |           expectedClosedTabs: [123, 456, 789]
      136 |         });
      137 |

      at Object.verifyCleanup (tests/unit/test-orchestration.test.js:134:41)

  â— Test Orchestration Protocol â€º State Machine Tests â€º should export all orchestration functions

    expect(received).toHaveProperty(path)

    Expected path: "startTest"
    Received path: []

    Received value: {"captureLogs": [Function captureLogs], "closeTab": [Function closeTab], "getAllExtensions": [Function getAllExtensions], "getExtensionInfo": [Function getExtensionInfo], "openUrl": [Function openUrl], "reload": [Function reload], "reloadAndCapture": [Function reloadAndCapture], "reloadTab": [Function reloadTab]}

      271 |
      272 |     test('should export all orchestration functions', () => {
    > 273 |       expect(chromeDevAssist).toHaveProperty('startTest');
          |                               ^
      274 |       expect(chromeDevAssist).toHaveProperty('endTest');
      275 |       expect(chromeDevAssist).toHaveProperty('getTestStatus');
      276 |       expect(chromeDevAssist).toHaveProperty('abortTest');

      at Object.toHaveProperty (tests/unit/test-orchestration.test.js:273:31)

PASS tests/chaos/tab-cleanup-adversarial.test.js
  â— Console

    console.log
      [ChromeDevAssist] Background service worker started

      at Object.log (extension/background.js:19:9)

PASS tests/unit/connection-logic-unit.test.js
  â— Console

    console.error
      [ChromeDevAssist] Cannot send: WebSocket is null

      91 |     function safeSend(ws, message) {
      92 |       if (!ws) {
    > 93 |         console.error('[ChromeDevAssist] Cannot send: WebSocket is null');
         |                 ^
      94 |         return false;
      95 |       }
      96 |

      at error (tests/unit/connection-logic-unit.test.js:93:17)
      at Object.safeSend (tests/unit/connection-logic-unit.test.js:127:22)

    console.warn
      [ChromeDevAssist] Cannot send: WebSocket is connecting (state: CONNECTING)

       96 |
       97 |       if (ws.readyState === CONNECTING) {
    >  98 |         console.warn('[ChromeDevAssist] Cannot send: WebSocket is connecting (state: CONNECTING)');
          |                 ^
       99 |         return false;
      100 |       }
      101 |

      at warn (tests/unit/connection-logic-unit.test.js:98:17)
      at Object.safeSend (tests/unit/connection-logic-unit.test.js:133:22)

    console.warn
      [ChromeDevAssist] Cannot send: WebSocket is closing (state: CLOSING)

      101 |
      102 |       if (ws.readyState === CLOSING) {
    > 103 |         console.warn('[ChromeDevAssist] Cannot send: WebSocket is closing (state: CLOSING)');
          |                 ^
      104 |         return false;
      105 |       }
      106 |

      at warn (tests/unit/connection-logic-unit.test.js:103:17)
      at Object.safeSend (tests/unit/connection-logic-unit.test.js:148:22)

    console.warn
      [ChromeDevAssist] Cannot send: WebSocket is closed (state: CLOSED)

      106 |
      107 |       if (ws.readyState === CLOSED) {
    > 108 |         console.warn('[ChromeDevAssist] Cannot send: WebSocket is closed (state: CLOSED)');
          |                 ^
      109 |         return false;
      110 |       }
      111 |

      at warn (tests/unit/connection-logic-unit.test.js:108:17)
      at Object.safeSend (tests/unit/connection-logic-unit.test.js:155:22)

PASS tests/unit/tab-operations-timeout.test.js
PASS tests/unit/clean-shutdown-detection.test.js
FAIL tests/integration/phase-1.1.test.js
  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º returns list of installed extensions

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º filters out self (Chrome Dev Assist)

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º includes extension details

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º count matches array length

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º returns details for valid extension ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º throws error for non-existent extension

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º throws error for missing extension ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º includes permissions array

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º opens URL in new tab

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º throws error for missing URL

    expect(received).rejects.toThrow(expected)

    Expected pattern: /required/i
    Received message: "Extension not connected"

          60 |         } else if (response.type === 'error') {
          61 |           ws.close();
        > 62 |           reject(new Error(response.error.message));
             |                  ^
          63 |         }
          64 |       });
          65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/phase-1.1.test.js:250:17)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º supports active option

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º supports captureConsole option

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º returns tabId

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º reloads tab by ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º supports bypassCache option (hard reload)

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º supports captureConsole option

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º throws error for missing tabId

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º closeTab â€º closes tab by ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º closeTab â€º throws error for missing tabId

    expect(received).rejects.toThrow(expected)

    Expected pattern: /required/i
    Received message: "Extension not connected"

          60 |         } else if (response.type === 'error') {
          61 |           ws.close();
        > 62 |           reject(new Error(response.error.message));
             |                  ^
          63 |         }
          64 |       });
          65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/phase-1.1.test.js:396:17)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "[Server ERROR] WebSocket error: Error: listen EADDRINUSE: address already in use 127.0.0.1:9876
        at Server.setupListenHandle [as _listen2] (node:net:1940:16)
        at listenInCluster (node:net:1997:12)
        at node:net:2206:7
        at processTicksAndRejections (node:internal/process/task_queues:90:21) {
      code: 'EADDRINUSE',
      errno: -48,
      syscall: 'listen',
      address: '127.0.0.1',
      port: 9876
    }".

      138 |
      139 | function logError(...args) {
    > 140 |   console.error('[Server ERROR]', ...args);
          |           ^
      141 | }
      142 |
      143 | /**

      at processTicksAndRejections (node:internal/process/task_queues:90:21) {
        code: 'EADDRINUSE',
        errno: -48,
        syscall: 'listen',
        address: '127.0.0.1',
        port: 9876
      }".
      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at error (server/websocket-server.js:140:11)
      at WebSocketServer.logError (server/websocket-server.js:416:3)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      394 | httpServer.on('error', (err) => {
      395 |   if (err.code === 'EADDRINUSE') {
    > 396 |     console.error('');
          |             ^
      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
      399 |     console.error('This usually means:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:396:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "ERROR: Port 9876 is already in use.".

      395 |   if (err.code === 'EADDRINUSE') {
      396 |     console.error('');
    > 397 |     console.error('ERROR: Port 9876 is already in use.');
          |             ^
      398 |     console.error('');
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:397:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      396 |     console.error('');
      397 |     console.error('ERROR: Port 9876 is already in use.');
    > 398 |     console.error('');
          |             ^
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:398:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "This usually means:".

      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
    > 399 |     console.error('This usually means:');
          |             ^
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:399:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  1. The server is already running (check other terminals)".

      398 |     console.error('');
      399 |     console.error('This usually means:');
    > 400 |     console.error('  1. The server is already running (check other terminals)');
          |             ^
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
      403 |     console.error('To fix:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:400:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  2. Another application is using port 9876".

      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
    > 401 |     console.error('  2. Another application is using port 9876');
          |             ^
      402 |     console.error('');
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:401:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
    > 402 |     console.error('');
          |             ^
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:402:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "To fix:".

      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
    > 403 |     console.error('To fix:');
          |             ^
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:403:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Stop the other process using port 9876".

      402 |     console.error('');
      403 |     console.error('To fix:');
    > 404 |     console.error('  - Stop the other process using port 9876');
          |             ^
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
      407 |     process.exit(1);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:404:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Or kill existing server: pkill -f websocket-server".

      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
    > 405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
          |             ^
      406 |     console.error('');
      407 |     process.exit(1);
      408 |   } else {

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:405:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
    > 406 |     console.error('');
          |             ^
      407 |     process.exit(1);
      408 |   } else {
      409 |     logError('Server error:', err);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:406:13)

  â—  process.exit called with "1"

      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
    > 407 |     process.exit(1);
          |             ^
      408 |   } else {
      409 |     logError('Server error:', err);
      410 |     process.exit(1);

      at Server.exit (server/websocket-server.js:407:13)
FAIL tests/unit/timeout-wrapper.test.js
  â— Verification: withTimeout implementation in background.js â€º should verify withTimeout exists in background.js

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      230 |
      231 |     // Verify withTimeout function is defined
    > 232 |     expect(backgroundJs).toContain('async function withTimeout(');
          |                          ^
      233 |     expect(backgroundJs).toContain('clearTimeout(timeoutHandle)');
      234 |   });
      235 |

      at Object.toContain (tests/unit/timeout-wrapper.test.js:232:26)

  â— Verification: withTimeout implementation in background.js â€º should verify withTimeout implementation matches test version

    expect(received).toContain(expected) // indexOf

    Expected substring: "Promise.race([promise, timeoutPromise])"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      241 |
      242 |     // Key implementation details that MUST be present
    > 243 |     expect(backgroundJs).toContain('Promise.race([promise, timeoutPromise])');
          |                          ^
      244 |     expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success');
      245 |     expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error');
      246 |   });

      at Object.toContain (tests/unit/timeout-wrapper.test.js:243:26)

FAIL tests/integration/phase-1.1-medium.test.js
  â— Phase 1.1 - Medium Complexity Tests â€º Beginner Developer - Realistic Confusion â€º passes wrong types to functions that expect none

    Should handle extra arguments gracefully: Extension not connected

      36 |       } catch (err) {
      37 |         // Should not error - just ignore extra args
    > 38 |         throw new Error('Should handle extra arguments gracefully: ' + err.message);
         |               ^
      39 |       }
      40 |     }, TEST_TIMEOUT);
      41 |

      at Object.<anonymous> (tests/integration/phase-1.1-medium.test.js:38:15)

  â— Phase 1.1 - Medium Complexity Tests â€º Beginner Developer - Realistic Confusion â€º forgets to await async functions

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Busy Developer - Rapid Workflows â€º opens multiple tabs quickly

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Busy Developer - Rapid Workflows â€º open -> reload -> close workflow

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Busy Developer - Rapid Workflows â€º queries extension info multiple times

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Debugger - Error Details â€º provides clear error for non-existent extension

    expect(received).toMatch(expected)

    Expected pattern: /Extension not found/i
    Received string:  "Extension not connected"

      242 |         throw new Error('Should throw error for non-existent extension');
      243 |       } catch (err) {
    > 244 |         expect(err.message).toMatch(/Extension not found/i);
          |                             ^
      245 |         expect(err.message).toContain(fakeId);
      246 |       }
      247 |     }, TEST_TIMEOUT);

      at Object.toMatch (tests/integration/phase-1.1-medium.test.js:244:29)

  â— Phase 1.1 - Medium Complexity Tests â€º Debugger - Error Details â€º returns detailed extension info including permissions

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Debugger - Error Details â€º openUrl returns tabId for tracking

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Reliability Engineer - Concurrent Operations â€º handles parallel getAllExtensions calls

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Reliability Engineer - Concurrent Operations â€º handles parallel getExtensionInfo calls

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Reliability Engineer - Concurrent Operations â€º opens multiple tabs concurrently

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º getAllExtensions count matches array length

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º getAllExtensions filters out Chrome Dev Assist itself

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º openUrl with active:true focuses tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º openUrl with active:false backgrounds tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º reloadTab with bypassCache option

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º closeTab returns correct response

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/edge-cases.test.js
  â— Console

    console.warn
      [Test Helper] Warning: Could not read auth token from /Users/gadievron/Documents/Claude Code/chrome-dev-assist/.auth-token

      42 |     AUTH_TOKEN = fs.readFileSync(TOKEN_FILE, 'utf8').trim();
      43 |   } catch (err) {
    > 44 |     console.warn(`[Test Helper] Warning: Could not read auth token from ${TOKEN_FILE}`);
         |             ^
      45 |     console.warn(`[Test Helper] HTTP requests may fail. Ensure server is running.`);
      46 |   }
      47 | }

      at Object.warn (tests/integration/test-helpers.js:44:13)
      at Object.require (tests/integration/edge-cases.test.js:13:46)

    console.warn
      [Test Helper] HTTP requests may fail. Ensure server is running.

      43 |   } catch (err) {
      44 |     console.warn(`[Test Helper] Warning: Could not read auth token from ${TOKEN_FILE}`);
    > 45 |     console.warn(`[Test Helper] HTTP requests may fail. Ensure server is running.`);
         |             ^
      46 |   }
      47 | }
      48 |

      at Object.warn (tests/integration/test-helpers.js:45:13)
      at Object.require (tests/integration/edge-cases.test.js:13:46)

    console.log
      [Test Config] URL Mode: http

      at Object.log (tests/integration/edge-cases.test.js:19:9)

    console.log
      [Test Config] Using HTTP server: http://localhost:9876/fixtures/

      at Object.log (tests/integration/edge-cases.test.js:23:11)

    console.log
      âœ“ Invalid tab ID rejected correctly

      at Object.log (tests/integration/edge-cases.test.js:372:13)

    console.log
      âœ“ Missing parameters rejected correctly

      at Object.log (tests/integration/edge-cases.test.js:384:13)

  â— Edge Cases - Memory & Resource Limits â€º enforces 10,000 log limit per capture

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Memory & Resource Limits â€º truncates very long messages (>10,000 chars)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Memory & Resource Limits â€º handles 10 rapid concurrent captures (cleanup verification)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies 10 concurrent tab-specific captures with isolation

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies openUrl only captures from its own tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies reloadTab only captures from specified tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies consistent tabId in captured logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles special characters in console output

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles undefined and null in console output

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles deeply nested objects

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles circular references in objects

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles empty console output

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Race Conditions & Timing â€º handles overlapping captures on same tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Race Conditions & Timing â€º handles rapid sequential operations on same tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/complete-system.test.js
  â— Console

    console.log
      âœ… Timeout mechanism validated (rejects invalid durations)

      at Object.log (tests/integration/complete-system.test.js:712:15)

  â— Complete System Integration Tests â€º Extension Discovery â€º should get all installed extensions

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension Discovery â€º should get specific extension info

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should enable extension

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should disable and re-enable extension

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should toggle extension state

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should reject invalid extension ID for enable/disable

    TypeError: chromeDevAssist.enableExtension is not a function

      182 |     test('should reject invalid extension ID for enable/disable', async () => {
      183 |       await expect(
    > 184 |         chromeDevAssist.enableExtension('invalid-id')
          |                         ^
      185 |       ).rejects.toThrow(/32 characters/);
      186 |
      187 |       await expect(

      at Object.enableExtension (tests/integration/complete-system.test.js:184:25)

  â— Complete System Integration Tests â€º Extension Reload â€º should reload extension without console capture

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension Reload â€º should reload extension WITH console capture

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension Reload â€º should capture console logs for specified duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Console Log Capture (No Reload) â€º should capture console logs without reloading

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should open URL in new tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should open URL and capture console logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should open URL with autoClose

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should reload tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should close tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Page Metadata Extraction â€º should extract metadata from test page

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Page Metadata Extraction â€º should handle page with no metadata gracefully

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Page Metadata Extraction â€º should reject invalid tab ID

    TypeError: chromeDevAssist.getPageMetadata is not a function

      416 |     test('should reject invalid tab ID', async () => {
      417 |       await expect(
    > 418 |         chromeDevAssist.getPageMetadata(999999)
          |                         ^
      419 |       ).rejects.toThrow();
      420 |     });
      421 |   });

      at Object.getPageMetadata (tests/integration/complete-system.test.js:418:25)

  â— Complete System Integration Tests â€º Test Orchestration â€º should start, check status, and end test

    TypeError: chromeDevAssist.startTest is not a function

      440 |
      441 |       // Start test
    > 442 |       const startResult = await chromeDevAssist.startTest(testId, {
          |                                                 ^
      443 |         autoCleanup: true
      444 |       });
      445 |

      at Object.startTest (tests/integration/complete-system.test.js:442:49)

  â— Complete System Integration Tests â€º Test Orchestration â€º should track tabs opened during test

    TypeError: chromeDevAssist.startTest is not a function

      471 |       testId = 'test-tab-tracking-' + Date.now();
      472 |
    > 473 |       await chromeDevAssist.startTest(testId);
          |                             ^
      474 |
      475 |       // Open tabs during test (should be auto-tracked)
      476 |       const tab1 = await chromeDevAssist.openUrl('https://example.com', {

      at Object.startTest (tests/integration/complete-system.test.js:473:29)

  â— Complete System Integration Tests â€º Test Orchestration â€º should abort test

    TypeError: chromeDevAssist.startTest is not a function

      501 |       testId = 'test-abort-' + Date.now();
      502 |
    > 503 |       await chromeDevAssist.startTest(testId);
          |                             ^
      504 |
      505 |       // Open a tab
      506 |       await chromeDevAssist.openUrl('https://example.com', { active: false });

      at Object.startTest (tests/integration/complete-system.test.js:503:29)

  â— Complete System Integration Tests â€º Test Orchestration â€º should reject starting test when one is active

    TypeError: chromeDevAssist.startTest is not a function

      521 |       testId = 'test-duplicate-' + Date.now();
      522 |
    > 523 |       await chromeDevAssist.startTest(testId);
          |                             ^
      524 |
      525 |       // Try to start another test
      526 |       await expect(

      at Object.startTest (tests/integration/complete-system.test.js:523:29)

  â— Complete System Integration Tests â€º Test Orchestration â€º should verify cleanup detects orphans

    TypeError: chromeDevAssist.startTest is not a function

      536 |       testId = 'test-cleanup-verification-' + Date.now();
      537 |
    > 538 |       await chromeDevAssist.startTest(testId);
          |                             ^
      539 |
      540 |       // Open tabs
      541 |       const tab1 = await chromeDevAssist.openUrl('https://example.com', {

      at Object.startTest (tests/integration/complete-system.test.js:538:29)

  â— Complete System Integration Tests â€º Full Integration Workflows â€º complete workflow: reload extension + capture + analyze logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Full Integration Workflows â€º complete workflow: test with fixture + metadata validation

    TypeError: chromeDevAssist.abortTest is not a function

      634 |       } catch (err) {
      635 |         // Cleanup on error
    > 636 |         await chromeDevAssist.abortTest(testId, err.message);
          |                               ^
      637 |         throw err;
      638 |       }
      639 |     });

      at Object.abortTest (tests/integration/complete-system.test.js:636:31)

  â— Complete System Integration Tests â€º Full Integration Workflows â€º complete workflow: multi-tab test with orchestration

    TypeError: chromeDevAssist.abortTest is not a function

      679 |
      680 |       } catch (err) {
    > 681 |         await chromeDevAssist.abortTest(testId, err.message);
          |                               ^
      682 |         throw err;
      683 |       }
      684 |     });

      at Object.abortTest (tests/integration/complete-system.test.js:681:31)

  â— Complete System Integration Tests â€º Error Handling â€º should handle connection errors gracefully

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

PASS tests/security/tab-cleanup-security.test.js
  â— Console

    console.log
      [ChromeDevAssist] Background service worker started

      at Object.log (extension/background.js:19:9)

PASS tests/unit/health-manager-observers.test.js
  â— Console

    console.log
      Observer overhead: 0.0060ms per check (10 observers)

      at Object.log (tests/unit/health-manager-observers.test.js:467:13)

    console.log
      Memory delta after 1000 events: 1.25 MB

      at Object.log (tests/unit/health-manager-observers.test.js:505:13)

FAIL tests/unit/page-metadata.test.js
  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject missing tabId

    TypeError: getPageMetadata is not a function

      23 |   describe('Input Validation', () => {
      24 |     test('should reject missing tabId', async () => {
    > 25 |       await expect(getPageMetadata()).rejects.toThrow('tabId is required');
         |                    ^
      26 |     });
      27 |
      28 |     test('should reject null tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:25:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject null tabId

    TypeError: getPageMetadata is not a function

      27 |
      28 |     test('should reject null tabId', async () => {
    > 29 |       await expect(getPageMetadata(null)).rejects.toThrow('tabId is required');
         |                    ^
      30 |     });
      31 |
      32 |     test('should reject undefined tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:29:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject undefined tabId

    TypeError: getPageMetadata is not a function

      31 |
      32 |     test('should reject undefined tabId', async () => {
    > 33 |       await expect(getPageMetadata(undefined)).rejects.toThrow('tabId is required');
         |                    ^
      34 |     });
      35 |
      36 |     test('should reject non-number tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:33:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject non-number tabId

    TypeError: getPageMetadata is not a function

      35 |
      36 |     test('should reject non-number tabId', async () => {
    > 37 |       await expect(getPageMetadata('123')).rejects.toThrow('tabId must be a number');
         |                    ^
      38 |       await expect(getPageMetadata(true)).rejects.toThrow('tabId must be a number');
      39 |       await expect(getPageMetadata({})).rejects.toThrow('tabId must be a number');
      40 |       await expect(getPageMetadata([])).rejects.toThrow('tabId must be a number');

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:37:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject negative tabId

    TypeError: getPageMetadata is not a function

      42 |
      43 |     test('should reject negative tabId', async () => {
    > 44 |       await expect(getPageMetadata(-1)).rejects.toThrow('tabId must be a positive integer');
         |                    ^
      45 |     });
      46 |
      47 |     test('should reject zero tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:44:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject zero tabId

    TypeError: getPageMetadata is not a function

      46 |
      47 |     test('should reject zero tabId', async () => {
    > 48 |       await expect(getPageMetadata(0)).rejects.toThrow('tabId must be a positive integer');
         |                    ^
      49 |     });
      50 |
      51 |     test('should reject non-integer tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:48:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject non-integer tabId

    TypeError: getPageMetadata is not a function

      50 |
      51 |     test('should reject non-integer tabId', async () => {
    > 52 |       await expect(getPageMetadata(123.45)).rejects.toThrow('tabId must be an integer');
         |                    ^
      53 |     });
      54 |
      55 |     test('should reject tabId exceeding safe integer', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:52:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject tabId exceeding safe integer

    TypeError: getPageMetadata is not a function

      54 |
      55 |     test('should reject tabId exceeding safe integer', async () => {
    > 56 |       await expect(getPageMetadata(Number.MAX_SAFE_INTEGER + 1))
         |                    ^
      57 |         .rejects.toThrow('tabId exceeds safe integer range');
      58 |     });
      59 |

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:56:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject NaN tabId

    TypeError: getPageMetadata is not a function

      59 |
      60 |     test('should reject NaN tabId', async () => {
    > 61 |       await expect(getPageMetadata(NaN)).rejects.toThrow('tabId must be a number');
         |                    ^
      62 |     });
      63 |
      64 |     test('should reject Infinity tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:61:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject Infinity tabId

    TypeError: getPageMetadata is not a function

      63 |
      64 |     test('should reject Infinity tabId', async () => {
    > 65 |       await expect(getPageMetadata(Infinity)).rejects.toThrow('tabId must be a finite number');
         |                    ^
      66 |     });
      67 |   });
      68 |

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:65:20)

  â— DOM Inspection API: getPageMetadata() â€º Error Handling â€º should reject tab that does not exist

    TypeError: getPageMetadata is not a function

      135 |       const nonExistentTabId = 999999;
      136 |
    > 137 |       await expect(getPageMetadata(nonExistentTabId))
          |                    ^
      138 |         .rejects.toThrow(/No tab with id|Extension not connected|tab.*not found/i);
      139 |     });
      140 |

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:137:20)

  â— DOM Inspection API: getPageMetadata() â€º Error Handling â€º should provide clear error for connection failures

    TypeError: getPageMetadata is not a function

      143 |       // This will fail with "Extension not connected" or "ECONNREFUSED"
      144 |
    > 145 |       await expect(getPageMetadata(1))
          |                    ^
      146 |         .rejects.toThrow(/Extension not connected|ECONNREFUSED|not running/i);
      147 |     });
      148 |   });

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:145:20)

FAIL tests/integration/screenshot-visual-verification.test.js
  â— Console

    console.log
      
      ğŸ“¸ SCREENSHOT VERIFICATION SUMMARY

      at Object.log (tests/integration/screenshot-visual-verification.test.js:232:15)

    console.log
      =====================================

      at Object.log (tests/integration/screenshot-visual-verification.test.js:233:15)

    console.log
      
      Total screenshots captured: 10

      at Object.log (tests/integration/screenshot-visual-verification.test.js:238:17)

    console.log
      Location: /Users/gadievron/Documents/Claude Code/chrome-dev-assist/tests/.screenshots

      at Object.log (tests/integration/screenshot-visual-verification.test.js:239:17)

    console.log
        âœ“ edge-console-logs.png (539726 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ edge-metadata.png (679117 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ edge-screenshots-jpeg.jpg (110034 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ edge-screenshots-png.png (1155868 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ integration-test-1.png (986652 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ integration-test-2.png (785512 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ stress-high-volume.jpg (109325 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ test-1-ALPHA-7392.png (971576 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ test-2-BETA-4561.jpeg (99642 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
        âœ“ test-3-GAMMA-8205.png (891077 bytes)

      at log (tests/integration/screenshot-visual-verification.test.js:244:19)
          at Array.forEach (<anonymous>)

    console.log
      
      ğŸ“‹ Expected secrets to verify:

      at Object.log (tests/integration/screenshot-visual-verification.test.js:247:17)

    console.log
        â€¢ ALPHA-7392 - Purple gradient background with red secret code

      at log (tests/integration/screenshot-visual-verification.test.js:249:19)
          at Array.forEach (<anonymous>)

    console.log
        â€¢ BETA-4561 - Pink gradient background with green secret code

      at log (tests/integration/screenshot-visual-verification.test.js:249:19)
          at Array.forEach (<anonymous>)

    console.log
        â€¢ GAMMA-8205 - Orange gradient background with dark container

      at log (tests/integration/screenshot-visual-verification.test.js:249:19)
          at Array.forEach (<anonymous>)

    console.log
      
      ğŸ” Next step: Verify screenshots contain visible secret codes

      at Object.log (tests/integration/screenshot-visual-verification.test.js:252:17)

    console.log
         Use Read tool to analyze screenshot images

      at Object.log (tests/integration/screenshot-visual-verification.test.js:253:17)

    console.log
      
      ğŸ’¾ Screenshots preserved for verification at: tests/.screenshots/

      at Object.log (tests/integration/screenshot-visual-verification.test.js:61:13)

  â— Screenshot Visual Verification â€º Screenshot Verification Summary â€º should list all screenshots for manual verification

    expect(received).toBe(expected) // Object.is equality

    Expected: 3
    Received: 10

      253 |         console.log('   Use Read tool to analyze screenshot images');
      254 |
    > 255 |         expect(files.length).toBe(3);
          |                              ^
      256 |       }
      257 |     });
      258 |   });

      at Object.toBe (tests/integration/screenshot-visual-verification.test.js:255:30)

FAIL tests/integration/reload-button-fix.test.js
  â— Console

    console.warn
      âš ï¸  Found potential console.error for connection failure: console.error('[ChromeDevAssist] WebSocket error

      222 |         const match = backgroundJs.match(pattern);
      223 |         if (match) {
    > 224 |           console.warn(`âš ï¸  Found potential console.error for connection failure: ${match[0]}`);
          |                   ^
      225 |         }
      226 |       });
      227 |

      at warn (tests/integration/reload-button-fix.test.js:224:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/integration/reload-button-fix.test.js:221:31)

  â— Reload Button Fix Verification â€º Fix #1: WebSocket onerror Handler â€º should use console.warn (not console.error) for WebSocket connection issues

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optio"

      34 |
      35 |       // Verify it uses console.warn for WebSocket connection issue
    > 36 |       expect(handlerBody).toContain('console.warn');
         |                           ^
      37 |       expect(handlerBody).toContain('WebSocket connection issue');
      38 |
      39 |       // Verify it does NOT use console.error for the connection issue

      at Object.toContain (tests/integration/reload-button-fix.test.js:36:27)

  â— Reload Button Fix Verification â€º Fix #1: WebSocket onerror Handler â€º should include explanatory comment about Chrome crash prevention

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { e"

      48 |
      49 |       // Verify fix comment exists
    > 50 |       expect(handlerBody).toContain('âœ… FIX');
         |                           ^
      51 |       expect(handlerBody).toContain('console.warn instead of console.error');
      52 |       expect(handlerBody).toContain('prevent Chrome');
      53 |     });

      at Object.toContain (tests/integration/reload-button-fix.test.js:50:27)

  â— Reload Button Fix Verification â€º Fix #1: WebSocket onerror Handler â€º should still schedule reconnection on error

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', exte"

      58 |
      59 |       // Verify reconnection logic still exists
    > 60 |       expect(handlerBody).toContain('scheduleReconnect');
         |                           ^
      61 |       expect(handlerBody).toContain('reconnectAttempts++');
      62 |     });
      63 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:60:27)

  â— Reload Button Fix Verification â€º Fix #2: Connection Timeout Handler â€º should use console.warn (not console.error) for connection timeout

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   -1

      67 |       // Find connection timeout handler
      68 |       const timeoutIndex = backgroundJs.indexOf('const connectTimeout = setTimeout(');
    > 69 |       expect(timeoutIndex).toBeGreaterThan(0);
         |                            ^
      70 |
      71 |       // Get timeout handler body (next 500 chars)
      72 |       const handlerBody = backgroundJs.substring(timeoutIndex, timeoutIndex + 500);

      at Object.toBeGreaterThan (tests/integration/reload-button-fix.test.js:69:28)

  â— Reload Button Fix Verification â€º Fix #2: Connection Timeout Handler â€º should include explanatory comment

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      85 |       const handlerBody = backgroundJs.substring(timeoutIndex, timeoutIndex + 600);
      86 |
    > 87 |       expect(handlerBody).toContain('âœ… FIX');
         |                           ^
      88 |       expect(handlerBody).toContain('console.warn instead of console.error');
      89 |     });
      90 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:87:27)

  â— Reload Button Fix Verification â€º Fix #3: Registration Timeout Handler â€º should use console.warn (not console.error) for registration timeout

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   -1

      94 |       // Find registration timeout handler
      95 |       const regTimeoutIndex = backgroundJs.indexOf('registrationTimeout = setTimeout(');
    > 96 |       expect(regTimeoutIndex).toBeGreaterThan(0);
         |                               ^
      97 |
      98 |       // Get handler body (next 500 chars)
      99 |       const handlerBody = backgroundJs.substring(regTimeoutIndex, regTimeoutIndex + 500);

      at Object.toBeGreaterThan (tests/integration/reload-button-fix.test.js:96:31)

  â— Reload Button Fix Verification â€º Fix #3: Registration Timeout Handler â€º should include explanatory comment

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      112 |       const handlerBody = backgroundJs.substring(regTimeoutIndex, regTimeoutIndex + 600);
      113 |
    > 114 |       expect(handlerBody).toContain('âœ… FIX');
          |                           ^
      115 |       expect(handlerBody).toContain('console.warn instead of console.error');
      116 |     });
      117 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:114:27)

  â— Reload Button Fix Verification â€º Verify No console.error for Expected Conditions â€º should not use console.error for WebSocket state issues in safeSend

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.error"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    /"

      126 |
      127 |       // console.error for null is OK (programming error)
    > 128 |       expect(safeSendBody).toContain('console.error');
          |                            ^
      129 |       expect(safeSendBody).toContain('WebSocket is null');
      130 |
      131 |       // But should use console.warn for state-based issues

      at Object.toContain (tests/integration/reload-button-fix.test.js:128:28)

  â— Reload Button Fix Verification â€º Verify No console.error for Expected Conditions â€º should document why connection failures are expected

    expect(received).toMatch(expected)

    Expected pattern: /expected/i
    Received string:  "d(json.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'extension_error'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[chromedevassist] websocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[chromedevassist] disconnected from server, reconnecting in 1s...');
        ws = null;
        settimeout(connecttoserver, 1000);
      };
    }Â·
    // connect on startup (only in chrome extension context)
    if (typeof chrome !== 'undefined' && typeof websocket !== 'undefined') {
      connecttoserver();
    }Â·
    /**
     * handle reload command
     * disables and re-enables the target extension, optionally capturing console logs
     */
    async function handlereloadcommand(commandid, params) {
      const { e"

      141 |
      142 |       // Should explain that failures are EXPECTED
    > 143 |       expect(handlerSection.toLowerCase()).toMatch(/expected/i);
          |                                            ^
      144 |     });
      145 |   });
      146 |

      at Object.toMatch (tests/integration/reload-button-fix.test.js:143:44)

  â— Reload Button Fix Verification â€º Fix #4: Command Error Handler â€º should use console.warn (not console.error) for command failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws."

      155 |
      156 |       // Verify it uses console.warn for command failures
    > 157 |       expect(handlerBody).toContain('console.warn');
          |                           ^
      158 |       expect(handlerBody).toContain('Command failed');
      159 |
      160 |       // Verify it does NOT use console.error for command failures

      at Object.toContain (tests/integration/reload-button-fix.test.js:157:27)

  â— Reload Button Fix Verification â€º Fix #4: Command Error Handler â€º should include explanatory comment about expected errors

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclos"

      168 |
      169 |       // Verify fix comment exists
    > 170 |       expect(handlerBody).toContain('âœ… FIX');
          |                           ^
      171 |       expect(handlerBody).toContain('console.warn instead of console.error');
      172 |       expect(handlerBody).toContain('Command failures are EXPECTED');
      173 |     });

      at Object.toContain (tests/integration/reload-button-fix.test.js:170:27)

  â— Reload Button Fix Verification â€º Fix #4: Command Error Handler â€º should still send error response to server

    expect(received).toContain(expected) // indexOf

    Expected substring: "safeSend"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome ex"

      179 |       // Verify error response sent
      180 |       expect(handlerBody).toContain("type: 'error'");
    > 181 |       expect(handlerBody).toContain('safeSend');
          |                           ^
      182 |     });
      183 |   });
      184 |

      at Object.toContain (tests/integration/reload-button-fix.test.js:181:27)

  â— Reload Button Fix Verification â€º Impact Verification â€º should have exactly 4 console.error â†’ console.warn fixes

    expect(received).toBeTruthy()

    Received: null

      187 |       // Count fix comments
      188 |       const fixComments = backgroundJs.match(/âœ… FIX.*console\.warn instead of console\.error/g);
    > 189 |       expect(fixComments).toBeTruthy();
          |                           ^
      190 |       expect(fixComments.length).toBe(4);
      191 |     });
      192 |

      at Object.toBeTruthy (tests/integration/reload-button-fix.test.js:189:27)

  â— Reload Button Fix Verification â€º Impact Verification â€º should preserve all reconnection logic

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect()"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      193 |     it('should preserve all reconnection logic', () => {
      194 |       // Verify reconnection logic still intact
    > 195 |       expect(backgroundJs).toContain('scheduleReconnect()');
          |                            ^
      196 |       expect(backgroundJs).toContain('exponential backoff');
      197 |       expect(backgroundJs).toContain('reconnectAttempts++');
      198 |       expect(backgroundJs).toContain('isConnecting = false');

      at Object.toContain (tests/integration/reload-button-fix.test.js:195:28)

  â— Reload Button Fix Verification â€º Impact Verification â€º should preserve all error handling paths

    expect(received).toContain(expected) // indexOf

    Expected substring: "connectTimeout"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      203 |       expect(backgroundJs).toContain('ws.onerror');
      204 |       expect(backgroundJs).toContain('ws.onclose');
    > 205 |       expect(backgroundJs).toContain('connectTimeout');
          |                            ^
      206 |       expect(backgroundJs).toContain('registrationTimeout');
      207 |     });
      208 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:205:28)

PASS tests/unit/level4-reload-auto-detect.test.js
PASS tests/unit/health-manager.test.js
FAIL tests/unit/screenshot.test.js
  â— Screenshot Capture â€º Basic Screenshot Capture â€º should capture screenshot of a tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Basic Screenshot Capture â€º should return PNG format by default

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Basic Screenshot Capture â€º should include base64 image data

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Basic Screenshot Capture â€º should include timestamp

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Format Options â€º should capture PNG when format is "png"

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Format Options â€º should capture JPEG when format is "jpeg"

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Format Options â€º should reject invalid format

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should accept quality parameter for JPEG

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should default to quality 90 for JPEG

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should reject quality < 0

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should reject quality > 100

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should ignore quality parameter for PNG

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject invalid tab ID (non-number)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject invalid tab ID (negative)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject invalid tab ID (non-existent)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject null tab ID

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject undefined tab ID

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Error Handling â€º should handle extension disconnection gracefully

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Error Handling â€º should provide clear error message for invalid options

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Multiple Screenshots â€º should capture multiple screenshots of same tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Multiple Screenshots â€º should capture screenshots of different tabs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Different Page Content â€º should capture different content for different pages

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Integration with Test Orchestration â€º should work within a test context

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Performance â€º should capture screenshot in reasonable time

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/chrome-crash-prevention.test.js
  â— Console

    console.warn
      Warning message may lack actionable info: console.warn('[ChromeDevAssist] Tab already closed:', tab.id)

      165 |
      166 |         if (!hasActionableInfo) {
    > 167 |           console.warn('Warning message may lack actionable info:', msg.substring(0, 100));
          |                   ^
      168 |         }
      169 |       });
      170 |

      at warn (tests/integration/chrome-crash-prevention.test.js:167:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/integration/chrome-crash-prevention.test.js:159:20)

    console.warn
      Warning message may lack actionable info: console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!')

      165 |
      166 |         if (!hasActionableInfo) {
    > 167 |           console.warn('Warning message may lack actionable info:', msg.substring(0, 100));
          |                   ^
      168 |         }
      169 |       });
      170 |

      at warn (tests/integration/chrome-crash-prevention.test.js:167:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/integration/chrome-crash-prevention.test.js:159:20)

    console.warn
      Warning message may lack actionable info: console.warn('[ChromeDevAssist] Rejected console message from non-tab source')

      165 |
      166 |         if (!hasActionableInfo) {
    > 167 |           console.warn('Warning message may lack actionable info:', msg.substring(0, 100));
          |                   ^
      168 |         }
      169 |       });
      170 |

      at warn (tests/integration/chrome-crash-prevention.test.js:167:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/integration/chrome-crash-prevention.test.js:159:20)

    console.warn
      Warning message may lack actionable info: console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)

      165 |
      166 |         if (!hasActionableInfo) {
    > 167 |           console.warn('Warning message may lack actionable info:', msg.substring(0, 100));
          |                   ^
      168 |         }
      169 |       });
      170 |

      at warn (tests/integration/chrome-crash-prevention.test.js:167:19)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/integration/chrome-crash-prevention.test.js:159:20)

  â— Chrome Crash Prevention â€º Expected Errors Use console.warn â€º should use console.warn for WebSocket connection failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', exte"

      29 |       );
      30 |
    > 31 |       expect(onerrorHandler).toContain('console.warn');
         |                              ^
      32 |       expect(onerrorHandler).toContain('WebSocket connection issue');
      33 |       expect(onerrorHandler).not.toMatch(/console\.error.*WebSocket.*connection/i);
      34 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:31:30)

  â— Chrome Crash Prevention â€º Expected Errors Use console.warn â€º should use console.warn for connection timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      41 |       );
      42 |
    > 43 |       expect(timeoutHandler).toContain('console.warn');
         |                              ^
      44 |       expect(timeoutHandler).toContain('Connection timeout after 5s');
      45 |       expect(timeoutHandler).not.toMatch(/console\.error.*timeout/i);
      46 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:43:30)

  â— Chrome Crash Prevention â€º Expected Errors Use console.warn â€º should use console.warn for registration timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      53 |       );
      54 |
    > 55 |       expect(regTimeoutHandler).toContain('console.warn');
         |                                 ^
      56 |       expect(regTimeoutHandler).toContain('Registration acknowledgment not received');
      57 |       expect(regTimeoutHandler).not.toMatch(/console\.error.*[Rr]egistration/);
      58 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:55:33)

  â— Chrome Crash Prevention â€º Unexpected Errors Use console.error â€º should use console.error for programming errors

    expect(received).toBeTruthy()

    Received: null

      66 |       // Verify we still have console.error for actual bugs
      67 |       const nullCheckErrors = backgroundJs.match(/console\.error.*WebSocket is null/g);
    > 68 |       expect(nullCheckErrors).toBeTruthy();
         |                               ^
      69 |       expect(nullCheckErrors.length).toBeGreaterThan(0);
      70 |     });
      71 |

      at Object.toBeTruthy (tests/integration/chrome-crash-prevention.test.js:68:31)

  â— Chrome Crash Prevention â€º Unexpected Errors Use console.error â€º should use console.error for unknown WebSocket states

    expect(received).toContain(expected) // indexOf

    Expected substring: "Unknown WebSocket state"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      73 |       // Unknown states are programming errors
      74 |       expect(backgroundJs).toContain('console.error');
    > 75 |       expect(backgroundJs).toContain('Unknown WebSocket state');
         |                            ^
      76 |     });
      77 |
      78 |     it('should use console.error for command failures', () => {

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:75:28)

  â— Chrome Crash Prevention â€º Crash Prevention Patterns â€º should have explanatory comments for all console.warn usages

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 3
    Received:    0

      88 |
      89 |       // Should have at least 3 fix comments (for the 3 main fixes)
    > 90 |       expect(fixComments.length).toBeGreaterThanOrEqual(3);
         |                                  ^
      91 |     });
      92 |
      93 |     it('should explain why connection failures are expected', () => {

      at Object.toBeGreaterThanOrEqual (tests/integration/chrome-crash-prevention.test.js:90:34)

  â— Chrome Crash Prevention â€º Crash Prevention Patterns â€º should explain why connection failures are expected

    expect(received).toContain(expected) // indexOf

    Expected substring: "Connection failures are EXPECTED"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      93 |     it('should explain why connection failures are expected', () => {
      94 |       // Check for explanatory comments
    > 95 |       expect(backgroundJs).toContain('Connection failures are EXPECTED');
         |                            ^
      96 |       expect(backgroundJs).toContain('server not running');
      97 |       expect(backgroundJs).toContain('server restart');
      98 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:95:28)

  â— Chrome Crash Prevention â€º Crash Prevention Patterns â€º should still handle errors gracefully

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      100 |     it('should still handle errors gracefully', () => {
      101 |       // Verify all error paths have recovery logic
    > 102 |       expect(backgroundJs).toContain('scheduleReconnect');
          |                            ^
      103 |       expect(backgroundJs).toContain('exponential backoff');
      104 |       expect(backgroundJs).toContain('reconnectAttempts');
      105 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:102:28)

  â— Chrome Crash Prevention â€º Chrome Extension Health Indicators â€º should not have patterns that trigger Chrome crash detection

    expect(received).toMatch(expected)

    Expected pattern: /scheduleReconnect|reconnectAttempts|ws\.close\(\)/
    Received string:  "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`)"

      131 |
      132 |         // Should have recovery logic (either direct scheduleReconnect() or ws.close() which triggers ws.onclose)
    > 133 |         expect(handlerCode).toMatch(/scheduleReconnect|reconnectAttempts|ws\.close\(\)/);
          |                             ^
      134 |       });
      135 |     });
      136 |

      at toMatch (tests/integration/chrome-crash-prevention.test.js:133:29)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/integration/chrome-crash-prevention.test.js:123:21)

  â— Chrome Crash Prevention â€º Chrome Extension Health Indicators â€º should have bounded reconnection attempts

    expect(received).toContain(expected) // indexOf

    Expected substring: "Math.min"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      137 |     it('should have bounded reconnection attempts', () => {
      138 |       // Verify exponential backoff has max limit
    > 139 |       expect(backgroundJs).toContain('Math.min');
          |                            ^
      140 |       expect(backgroundJs).toContain('Math.pow(2,');
      141 |
      142 |       // Should have max reconnection delay (30 seconds)

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:139:28)

  â— Chrome Crash Prevention â€º Chrome Extension Health Indicators â€º should prevent infinite connection loops

    expect(received).toContain(expected) // indexOf

    Expected substring: "let isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      146 |     it('should prevent infinite connection loops', () => {
      147 |       // Verify isConnecting flag prevents duplicates
    > 148 |       expect(backgroundJs).toContain('let isConnecting = false');
          |                            ^
      149 |       expect(backgroundJs).toContain('if (isConnecting)');
      150 |       expect(backgroundJs).toContain('Already connecting');
      151 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:148:28)

  â— Chrome Crash Prevention â€º Error Message Quality â€º should distinguish between transient and permanent errors

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 3
    Received:    0

      179 |       // Count console.warn for transient issues (connection, timeout, registration)
      180 |       const warnCount = (backgroundJs.match(/console\.warn.*connection|console\.warn.*timeout|console\.warn.*Registration/gi) || []).length;
    > 181 |       expect(warnCount).toBeGreaterThanOrEqual(3);
          |                         ^
      182 |
      183 |       // Count console.error for programming issues
      184 |       const errorCount = (backgroundJs.match(/console\.error.*null|Unknown|failed/gi) || []).length;

      at Object.toBeGreaterThanOrEqual (tests/integration/chrome-crash-prevention.test.js:181:25)

  â— Chrome Crash Prevention â€º Service Worker Stability â€º should have keep-alive mechanism

    expect(received).toContain(expected) // indexOf

    Expected substring: "keep-alive"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      190 |     it('should have keep-alive mechanism', () => {
      191 |       // Verify keep-alive alarm exists
    > 192 |       expect(backgroundJs).toContain('keep-alive');
          |                            ^
      193 |       expect(backgroundJs).toContain('periodInMinutes');
      194 |       expect(backgroundJs).toContain('0.25'); // 15 seconds
      195 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:192:28)

  â— Chrome Crash Prevention â€º Service Worker Stability â€º should handle alarm errors gracefully

    expect(received).toContain(expected) // indexOf

    Expected substring: "chrome.alarms.onAlarm.addListener"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      197 |     it('should handle alarm errors gracefully', () => {
      198 |       // Verify alarm handler exists
    > 199 |       expect(backgroundJs).toContain('chrome.alarms.onAlarm.addListener');
          |                            ^
      200 |
      201 |       // Should check connection state before reconnecting
      202 |       expect(backgroundJs).toContain('ws.readyState');

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:199:28)

  â— Chrome Crash Prevention â€º Service Worker Stability â€º should prevent duplicate alarms

    expect(received).toContain(expected) // indexOf

    Expected substring: "chrome.alarms.clear"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      205 |     it('should prevent duplicate alarms', () => {
      206 |       // Verify alarm clearing before creating new one
    > 207 |       expect(backgroundJs).toContain('chrome.alarms.clear');
          |                            ^
      208 |       expect(backgroundJs).toContain('reconnect-websocket');
      209 |     });
      210 |   });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:207:28)

FAIL tests/integration/improvements-verification.test.js
  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have withTimeout function defined

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      25 |   describe('Improvement 8: Timeout Wrapper (P0 CRITICAL)', () => {
      26 |     it('should have withTimeout function defined', () => {
    > 27 |       expect(backgroundJs).toContain('async function withTimeout(');
         |                            ^
      28 |       expect(backgroundJs).toContain('Promise.race([promise, timeoutPromise])');
      29 |     });
      30 |

      at Object.toContain (tests/integration/improvements-verification.test.js:27:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have timer cleanup on success

    expect(received).toContain(expected) // indexOf

    Expected substring: "clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      30 |
      31 |     it('should have timer cleanup on success', () => {
    > 32 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success');
         |                            ^
      33 |     });
      34 |
      35 |     it('should have timer cleanup on error', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:32:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have timer cleanup on error

    expect(received).toContain(expected) // indexOf

    Expected substring: "clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      34 |
      35 |     it('should have timer cleanup on error', () => {
    > 36 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error');
         |                            ^
      37 |     });
      38 |
      39 |     it('should have timeout error message format', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:36:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have timeout error message format

    expect(received).toContain(expected) // indexOf

    Expected substring: "${operation} timeout after ${timeoutMs}ms"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      38 |
      39 |     it('should have timeout error message format', () => {
    > 40 |       expect(backgroundJs).toContain('${operation} timeout after ${timeoutMs}ms');
         |                            ^
      41 |     });
      42 |
      43 |     // Check if chrome.* calls are wrapped (this will initially fail)

      at Object.toContain (tests/integration/improvements-verification.test.js:40:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have message queue array

    expect(received).toContain(expected) // indexOf

    Expected substring: "const messageQueue = []"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      57 |   describe('Improvement 7: Message Queuing (P1 HIGH)', () => {
      58 |     it('should have message queue array', () => {
    > 59 |       expect(backgroundJs).toContain('const messageQueue = []');
         |                            ^
      60 |     });
      61 |
      62 |     it('should have MAX_QUEUE_SIZE constant', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:59:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have MAX_QUEUE_SIZE constant

    expect(received).toContain(expected) // indexOf

    Expected substring: "const MAX_QUEUE_SIZE = 100"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      61 |
      62 |     it('should have MAX_QUEUE_SIZE constant', () => {
    > 63 |       expect(backgroundJs).toContain('const MAX_QUEUE_SIZE = 100');
         |                            ^
      64 |     });
      65 |
      66 |     it('should have queue bounds check', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:63:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have queue bounds check

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (messageQueue.length >= MAX_QUEUE_SIZE)"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      65 |
      66 |     it('should have queue bounds check', () => {
    > 67 |       expect(backgroundJs).toContain('if (messageQueue.length >= MAX_QUEUE_SIZE)');
         |                            ^
      68 |       expect(backgroundJs).toContain('Queue full, dropping message');
      69 |     });
      70 |

      at Object.toContain (tests/integration/improvements-verification.test.js:67:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should queue messages during CONNECTING state

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (ws.readyState === WebSocket.CONNECTING)"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      70 |
      71 |     it('should queue messages during CONNECTING state', () => {
    > 72 |       expect(backgroundJs).toContain('if (ws.readyState === WebSocket.CONNECTING)');
         |                            ^
      73 |       expect(backgroundJs).toContain('messageQueue.push(message)');
      74 |     });
      75 |

      at Object.toContain (tests/integration/improvements-verification.test.js:72:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should drain queue when connection opens

    expect(received).toContain(expected) // indexOf

    Expected substring: "while (messageQueue.length > 0)"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      75 |
      76 |     it('should drain queue when connection opens', () => {
    > 77 |       expect(backgroundJs).toContain('while (messageQueue.length > 0)');
         |                            ^
      78 |       expect(backgroundJs).toContain('const queued = messageQueue.shift()');
      79 |     });
      80 |

      at Object.toContain (tests/integration/improvements-verification.test.js:77:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have error handling during queue drain

    expect(received).toContain(expected) // indexOf

    Expected substring: "Failed to send queued message"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      80 |
      81 |     it('should have error handling during queue drain', () => {
    > 82 |       expect(backgroundJs).toContain('Failed to send queued message');
         |                            ^
      83 |       expect(backgroundJs).toContain('messageQueue.unshift(queued)');
      84 |     });
      85 |

      at Object.toContain (tests/integration/improvements-verification.test.js:82:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should clear queue on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "messageQueue.length = 0"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      85 |
      86 |     it('should clear queue on disconnect', () => {
    > 87 |       expect(backgroundJs).toContain('messageQueue.length = 0');
         |                            ^
      88 |       expect(backgroundJs).toContain('Clearing');
      89 |     });
      90 |   });

      at Object.toContain (tests/integration/improvements-verification.test.js:87:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have registrationPending flag

    expect(received).toContain(expected) // indexOf

    Expected substring: "let registrationPending = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      92 |   describe('Improvement 6: Registration ACK (P2 MEDIUM)', () => {
      93 |     it('should have registrationPending flag', () => {
    > 94 |       expect(backgroundJs).toContain('let registrationPending = false');
         |                            ^
      95 |     });
      96 |
      97 |     it('should have registrationTimeout handle', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:94:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have registrationTimeout handle

    expect(received).toContain(expected) // indexOf

    Expected substring: "let registrationTimeout = null"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

       96 |
       97 |     it('should have registrationTimeout handle', () => {
    >  98 |       expect(backgroundJs).toContain('let registrationTimeout = null');
          |                            ^
       99 |     });
      100 |
      101 |     it('should set registration pending on connection', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:98:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should set registration pending on connection

    expect(received).toContain(expected) // indexOf

    Expected substring: "registrationPending = true"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      100 |
      101 |     it('should set registration pending on connection', () => {
    > 102 |       expect(backgroundJs).toContain('registrationPending = true');
          |                            ^
      103 |     });
      104 |
      105 |     it('should have registration timeout (5 seconds)', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:102:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have registration timeout (5 seconds)

    expect(received).toContain(expected) // indexOf

    Expected substring: "Registration timeout, reconnecting"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      104 |
      105 |     it('should have registration timeout (5 seconds)', () => {
    > 106 |       expect(backgroundJs).toContain('Registration timeout, reconnecting');
          |                            ^
      107 |       expect(backgroundJs).toContain('5000'); // 5 second timeout
      108 |     });
      109 |

      at Object.toContain (tests/integration/improvements-verification.test.js:106:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should handle registration-ack message

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (message.type === 'registration-ack')"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      109 |
      110 |     it('should handle registration-ack message', () => {
    > 111 |       expect(backgroundJs).toContain("if (message.type === 'registration-ack')");
          |                            ^
      112 |       expect(backgroundJs).toContain('clearTimeout(registrationTimeout)');
      113 |       expect(backgroundJs).toContain('isRegistered = true');
      114 |     });

      at Object.toContain (tests/integration/improvements-verification.test.js:111:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should reset registration state on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "isRegistered = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      115 |
      116 |     it('should reset registration state on disconnect', () => {
    > 117 |       expect(backgroundJs).toContain('isRegistered = false');
          |                            ^
      118 |       expect(backgroundJs).toContain('registrationPending = false');
      119 |     });
      120 |

      at Object.toContain (tests/integration/improvements-verification.test.js:117:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have server sending registration-ack

    expect(received).toContain(expected) // indexOf

    Expected substring: "type: 'registration-ack'"
    Received string:    "#!/usr/bin/env nodeÂ·
    /**
     * Chrome Dev Assist - WebSocket Server + HTTP Static File Server
     * Routes messages between Chrome extension and Node.js API
     * Serves test fixtures over HTTP for reliable testing
     *
     * Persona Requirements Implemented:
     * - JSON validation (Persona 6)
     * - Duplicate extension registration (Persona 3, 6)
     * - Clear error messages (Persona 5, 6)
     * - Debug logging (Persona 4)
     *
     * HTTP Server Features:
     * - Serves test fixtures from /fixtures path
     * - CORS enabled for extension access
     * - Same port as WebSocket (9876)
     *
     * Security Documentation:
     * - Architecture: docs/SECURITY.md
     * - Decisions: docs/decisions/README.md
     * - Why HTTP (not HTTPS): docs/decisions/002-http-vs-https-for-localhost.md
     * - Token Auth: docs/decisions/001-test-infrastructure-authentication.md
     */Â·
    const http = require('http');
    const fs = require('fs');
    const path = require('path');
    const crypto = require('crypto');
    const WebSocket = require('ws');
    const HealthManager = require('../src/health/health-manager');Â·
    const PORT = 9876;
    const HOST = '127.0.0.1'; // localhost only for security
    const DEBUG = process.env.DEBUG === 'true';Â·
    // Path to test fixtures
    const FIXTURES_PATH = path.join(__dirname, '../tests/fixtures');Â·
    // BUG #3 FIX: Prevent multiple server instances
    // PID file for single-instance enforcement
    const PID_FILE = path.join(__dirname, '../.server-pid');Â·
    /**
     * Check if another server instance is running and handle it
     * Auto-recovery: Kills stale instances before starting new one
     */
    function ensureSingleInstance() {
      if (fs.existsSync(PID_FILE)) {
        const oldPid = parseInt(fs.readFileSync(PID_FILE, 'utf8').trim(), 10);Â·
        // Check if process is still running
        try {
          process.kill(oldPid, 0); // Signal 0 = just check if process existsÂ·
          // Process exists - kill it
          console.log(`[Server] Detected existing server instance (PID ${oldPid})`);
          console.log(`[Server] Killing old instance to prevent port conflict...`);Â·
          try {
            process.kill(oldPid, 'SIGTERM');
            // Wait a moment for graceful shutdown
            const start = Date.now();
            while (Date.now() - start < 1000) {
              try {
                process.kill(oldPid, 0);
                // Still running, wait a bit
              } catch {
                // Process died, good
                break;
              }
            }Â·
            // If still alive, force kill
            try {
              process.kill(oldPid, 0);
              console.log(`[Server] Forcing kill of old instance...`);
              process.kill(oldPid, 'SIGKILL');
            } catch {
              // Already dead
            }Â·
            console.log(`[Server] Old instance terminated successfully`);
          } catch (err) {
            console.log(`[Server] Could not kill old instance: ${err.message}`);
            console.log(`[Server] Cleaning up stale PID file`);
          }
        } catch {
          // Process doesn't exist - stale PID file
          console.log(`[Server] Removing stale PID file (process ${oldPid} not running)`);
        }Â·
        // Remove old PID file
        try {
          fs.unlinkSync(PID_FILE);
        } catch (err) {
          console.error(`[Server] Failed to remove PID file: ${err.message}`);
        }
      }Â·
      // Write our PID
      try {
        fs.writeFileSync(PID_FILE, String(process.pid), 'utf8');
        console.log(`[Server] PID ${process.pid} written to ${PID_FILE}`);
      } catch (err) {
        console.error(`[Server] Failed to write PID file: ${err.message}`);
        process.exit(1);
      }
    }Â·
    // Enforce single instance before doing anything else
    ensureSingleInstance();Â·
    // Authentication token (generated at startup for defense-in-depth)
    const AUTH_TOKEN = crypto.randomBytes(32).toString('hex');
    const TOKEN_FILE = path.join(__dirname, '../.auth-token');Â·
    // Write auth token to file for client access
    try {
      fs.writeFileSync(TOKEN_FILE, AUTH_TOKEN, 'utf8');
      console.log(`[Server] Auth token generated and saved to ${TOKEN_FILE}`);
    } catch (err) {
      console.error(`[Server] Failed to write auth token: ${err.message}`);
      process.exit(1);
    }Â·
    // State
    let extensionSocket = null;
    const apiSockets = new Map(); // commandId -> socket
    const healthManager = new HealthManager();Â·
    // Logging helper
    function log(...args) {
      if (DEBUG) {
        console.log('[Server]', ...args);
      }
    }Â·
    function logError(...args) {
      console.error('[Server ERROR]', ...args);
    }Â·
    /**
     * Handle HTTP requests - serve static files from /fixtures path
     * This allows tests to load fixtures via HTTP instead of file:// URLs
     *
     * Security:
     * - Server bound to 127.0.0.1 (localhost only)
     * - Validates Host header for additional protection
     * - Directory traversal protection on file paths
     */
    function handleHttpRequest(req, res) {
      log(`HTTP ${req.method} ${req.url} from ${req.socket.remoteAddress}`);Â·
      // Security Layer 1: Validate Host header (defense-in-depth)
      // Even though server is bound to 127.0.0.1, validate the Host header
      const host = req.headers.host || '';
      const isLocalhost = host.startsWith('localhost:') ||
                          host.startsWith('127.0.0.1:') ||
                          host === 'localhost' ||
                          host === '127.0.0.1';Â·
      if (!isLocalhost) {
        logError(`Rejected request from non-localhost Host: ${host}`);
        res.writeHead(403, { 'Content-Type': 'text/plain' });
        res.end('Forbidden: Server only accepts localhost connections');
        return;
      }Â·
      // Security Layer 2: Validate auth token (defense-in-depth)
      // Prevents other localhost applications from accessing the server
      let clientToken = req.headers['x-auth-token'];
      if (!clientToken && req.url.includes('?token=')) {
        const url = new URL(req.url, `http://${host}`);
        clientToken = url.searchParams.get('token');
      }Â·
      // Allow root path without auth (for debugging/listing)
      const requiresAuth = req.url.startsWith('/fixtures/');Â·
      if (requiresAuth && clientToken !== AUTH_TOKEN) {
        logError(`Rejected request with invalid auth token from ${req.socket.remoteAddress}`);
        res.writeHead(401, { 'Content-Type': 'text/plain' });
        res.end('Unauthorized: Invalid or missing auth token');
        return;
      }Â·
      // Enable CORS for extension access (localhost only)
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type');Â·
      // Handle OPTIONS preflight
      if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
      }Â·
      // Only handle GET requests
      if (req.method !== 'GET') {
        res.writeHead(405, { 'Content-Type': 'text/plain' });
        res.end('Method Not Allowed');
        return;
      }Â·
      // Serve test fixtures from /fixtures path
      if (req.url.startsWith('/fixtures/')) {
        // Parse URL to remove query parameters
        const url = new URL(req.url, `http://${host}`);
        const filename = url.pathname.substring('/fixtures/'.length);
        const filepath = path.join(FIXTURES_PATH, filename);Â·
        // Security: prevent directory traversal
        if (!filepath.startsWith(FIXTURES_PATH)) {
          res.writeHead(403, { 'Content-Type': 'text/plain' });
          res.end('Forbidden');
          return;
        }Â·
        // Check if file exists
        fs.stat(filepath, (err, stats) => {
          if (err || !stats.isFile()) {
            res.writeHead(404, { 'Content-Type': 'text/plain' });
            res.end('Not Found');
            return;
          }Â·
          // Determine content type
          const ext = path.extname(filepath).toLowerCase();
          const contentTypes = {
            '.html': 'text/html',
            '.js': 'application/javascript',
            '.css': 'text/css',
            '.json': 'application/json',
            '.txt': 'text/plain'
          };
          const contentType = contentTypes[ext] || 'application/octet-stream';Â·
          // Serve file
          fs.readFile(filepath, (err, data) => {
            if (err) {
              res.writeHead(500, { 'Content-Type': 'text/plain' });
              res.end('Internal Server Error');
              return;
            }Â·
            res.writeHead(200, { 'Content-Type': contentType });
            res.end(data);
            log(`Served ${filename} (${data.length} bytes)`);
          });
        });
        return;
      }Â·
      // Root path - show available fixtures
      if (req.url === '/' || req.url === '/fixtures') {
        fs.readdir(FIXTURES_PATH, (err, files) => {
          if (err) {
            res.writeHead(500, { 'Content-Type': 'text/plain' });
            res.end('Error reading fixtures directory');
            return;
          }Â·
          const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Chrome Dev Assist - Test Fixtures</title>
      <style>
        body { font-family: system-ui; margin: 40px; }
        h1 { color: #1a73e8; }
        ul { line-height: 1.8; }
        a { color: #1a73e8; text-decoration: none; }
        a:hover { text-decoration: underline; }
      </style>
    </head>
    <body>
      <h1>Chrome Dev Assist - Test Fixtures</h1>
      <p>Available test fixtures:</p>
      <ul>
        ${files.filter(f => f.endsWith('.html')).map(f =>
          `<li><a href=\"/fixtures/${f}\">${f}</a></li>`
        ).join('\\n    ')}
      </ul>
      <hr>
      <p><small>Server: ${HOST}:${PORT}</small></p>
    </body>
    </html>`;Â·
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end(html);
        });
        return;
      }Â·
      // 404 for other paths
      res.writeHead(404, { 'Content-Type': 'text/plain' });
      res.end('Not Found');
    }Â·
    // Create HTTP server first
    const httpServer = http.createServer((req, res) => {
      handleHttpRequest(req, res);
    });Â·
    // Attach WebSocket server to HTTP server
    const server = new WebSocket.Server({ server: httpServer });Â·
    // Start HTTP server
    httpServer.listen(PORT, HOST, () => {
      console.log(`[Server] HTTP server on http://${HOST}:${PORT}`);
      console.log(`[Server] WebSocket server on ws://${HOST}:${PORT}`);
      console.log(`[Server] Test fixtures at http://${HOST}:${PORT}/fixtures/`);
    });Â·
    server.on('connection', (socket) => {
      log('Client connected');Â·
      socket.on('message', (data) => {
        // REQUIREMENT #1: JSON validation (Persona 6)
        let msg;
        try {
          msg = JSON.parse(data.toString());
        } catch (err) {
          logError('Invalid JSON received:', err.message);
          socket.send(JSON.stringify({
            type: 'error',
            error: {
              message: 'Invalid JSON',
              code: 'PARSE_ERROR'
            }
          }));
          return;
        }Â·
        // Validate message has type field
        if (!msg.type) {
          logError('Message missing type field:', msg);
          socket.send(JSON.stringify({
            type: 'error',
            error: {
              message: 'Message must have type field',
              code: 'INVALID_MESSAGE'
            }
          }));
          return;
        }Â·
        log('Received:', msg.type, msg.id || '');Â·
        // Handle different message types
        if (msg.type === 'register') {
          handleRegister(socket, msg);
        } else if (msg.type === 'command') {
          handleCommand(socket, msg);
        } else if (msg.type === 'response' || msg.type === 'error') {
          handleResponse(socket, msg);
        } else {
          logError('Unknown message type:', msg.type);
          socket.send(JSON.stringify({
            type: 'error',
            error: {
              message: `Unknown message type: ${msg.type}`,
              code: 'UNKNOWN_MESSAGE_TYPE'
            }
          }));
        }
      });Â·
      socket.on('close', () => {
        // Clean up on disconnect
        if (socket === extensionSocket) {
          log('Extension disconnected');
          extensionSocket = null;
          healthManager.setExtensionSocket(null);
        }Â·
        // Remove from API sockets
        for (const [commandId, apiSocket] of apiSockets.entries()) {
          if (apiSocket === socket) {
            apiSockets.delete(commandId);
            log(`API client disconnected (command ${commandId})`);
          }
        }
      });Â·
      socket.on('error', (err) => {
        logError('Socket error:', err.message);
      });
    });Â·
    // REQUIREMENT #3: Port conflict handling (Persona 5)
    httpServer.on('error', (err) => {
      if (err.code === 'EADDRINUSE') {
        console.error('');
        console.error('ERROR: Port 9876 is already in use.');
        console.error('');
        console.error('This usually means:');
        console.error('  1. The server is already running (check other terminals)');
        console.error('  2. Another application is using port 9876');
        console.error('');
        console.error('To fix:');
        console.error('  - Stop the other process using port 9876');
        console.error('  - Or kill existing server: pkill -f websocket-server');
        console.error('');
        process.exit(1);
      } else {
        logError('Server error:', err);
        process.exit(1);
      }
    });Â·
    // WebSocket server error handling
    server.on('error', (err) => {
      logError('WebSocket error:', err);
    });Â·
    console.log('[Server] Ready - waiting for connections');
    if (DEBUG) {
      console.log('[Server] Debug logging enabled');
    }Â·
    /**
     * Handle extension registration
     */
    function handleRegister(socket, msg) {
      // REQUIREMENT #2: Duplicate extension registration (Persona 3, 6)
      if (extensionSocket !== null && extensionSocket !== socket) {
        logError('Extension already registered, rejecting duplicate');
        socket.send(JSON.stringify({
          type: 'error',
          error: {
            message: 'Extension already registered. Only one extension can connect at a time.',
            code: 'DUPLICATE_REGISTRATION'
          }
        }));
        socket.close();
        return;
      }Â·
      extensionSocket = socket;
      healthManager.setExtensionSocket(socket);
      log('Extension registered:', msg.extensionId || '(no ID provided)');
    }Â·
    /**
     * Handle command from API - route to extension
     */
    function handleCommand(socket, msg) {
      // Validate command has ID
      if (!msg.id) {
        logError('Command missing ID field');
        socket.send(JSON.stringify({
          type: 'error',
          error: {
            message: 'Command must have id field',
            code: 'INVALID_COMMAND'
          }
        }));
        return;
      }Â·
      // Store API socket for response routing
      apiSockets.set(msg.id, socket);
      log(`Command ${msg.id} from API`);Â·
      // Check if extension is connected (using health-manager)
      if (!healthManager.isExtensionConnected()) {
        logError('Extension not connected, cannot route command');
        const healthStatus = healthManager.getHealthStatus();
        socket.send(JSON.stringify({
          type: 'error',
          id: msg.id,
          error: {
            message: healthStatus.issues.join(' ') || 'Extension not connected. Please ensure Chrome Dev Assist extension is loaded and running.',
            code: 'EXTENSION_NOT_CONNECTED'
          }
        }));
        apiSockets.delete(msg.id);
        return;
      }Â·
      // Route command to extension
      log(`Routing command ${msg.id} to extension`);
      try {
        extensionSocket.send(JSON.stringify(msg));
      } catch (err) {
        logError(`Failed to send to extension:`, err.message);
        socket.send(JSON.stringify({
          type: 'error',
          id: msg.id,
          error: {
            message: 'Failed to send command to extension',
            code: 'SEND_FAILED'
          }
        }));
        apiSockets.delete(msg.id);
      }
    }Â·
    /**
     * Handle response from extension - route to API
     */
    function handleResponse(socket, msg) {
      // Validate response has ID
      if (!msg.id) {
        logError('Response missing ID field');
        return;
      }Â·
      log(`Response ${msg.id} from extension`);Â·
      // Find API socket for this command
      const apiSocket = apiSockets.get(msg.id);Â·
      if (!apiSocket) {
        logError(`No API socket found for command ${msg.id}`);
        return;
      }Â·
      if (apiSocket.readyState !== WebSocket.OPEN) {
        logError(`API socket for command ${msg.id} is closed`);
        apiSockets.delete(msg.id);
        return;
      }Â·
      // Route response to API
      log(`Routing response ${msg.id} to API`);
      try {
        apiSocket.send(JSON.stringify(msg));
        apiSockets.delete(msg.id); // Clean up
      } catch (err) {
        logError(`Failed to send to API:`, err.message);
        apiSockets.delete(msg.id);
      }
    }Â·
    // Graceful shutdown
    function cleanup() {
      // Remove PID file (Bug #3 fix)
      try {
        if (fs.existsSync(PID_FILE)) {
          fs.unlinkSync(PID_FILE);
          console.log('[Server] PID file removed');
        }
      } catch (err) {
        console.error('[Server] Failed to remove PID file:', err.message);
      }Â·
      // Remove auth token file on shutdown (security cleanup)
      try {
        if (fs.existsSync(TOKEN_FILE)) {
          fs.unlinkSync(TOKEN_FILE);
          console.log('[Server] Auth token file removed');
        }
      } catch (err) {
        console.error('[Server] Failed to remove auth token:', err.message);
      }
    }Â·
    process.on('SIGINT', () => {
      console.log('\\n[Server] Shutting down...');
      server.close(() => {
        httpServer.close(() => {
          cleanup();
          console.log('[Server] Closed');
          process.exit(0);
        });
      });
    });Â·
    process.on('SIGTERM', () => {
      console.log('\\n[Server] Shutting down...');
      server.close(() => {
        httpServer.close(() => {
          cleanup();
          console.log('[Server] Closed');
          process.exit(0);
        });
      });
    });
    "

      120 |
      121 |     it('should have server sending registration-ack', () => {
    > 122 |       expect(serverJs).toContain("type: 'registration-ack'");
          |                        ^
      123 |       expect(serverJs).toContain('Sent registration-ack');
      124 |     });
      125 |   });

      at Object.toContain (tests/integration/improvements-verification.test.js:122:24)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Bug Fixes Verification â€º should have all Improvement 8 bug fixes

    expect(received).toContain(expected) // indexOf

    Expected substring: "clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      128 |     it('should have all Improvement 8 bug fixes', () => {
      129 |       // Timer cleanup on success
    > 130 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success');
          |                            ^
      131 |
      132 |       // Timer cleanup on error
      133 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error');

      at Object.toContain (tests/integration/improvements-verification.test.js:130:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Bug Fixes Verification â€º should have all Improvement 7 bug fixes

    expect(received).toContain(expected) // indexOf

    Expected substring: "// âœ… IMPROVEMENT 7 FIX: Clear message queue"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      136 |     it('should have all Improvement 7 bug fixes', () => {
      137 |       // Fix 1: Clear queue on disconnect
    > 138 |       expect(backgroundJs).toContain('// âœ… IMPROVEMENT 7 FIX: Clear message queue');
          |                            ^
      139 |
      140 |       // Fix 2: Error handling during drain
      141 |       expect(backgroundJs).toContain('Failed to send queued message');

      at Object.toContain (tests/integration/improvements-verification.test.js:138:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Bug Fixes Verification â€º should have all Improvement 6 bug fixes

    expect(received).toContain(expected) // indexOf

    Expected substring: "// âœ… IMPROVEMENT 6: Set registration timeout"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      147 |     it('should have all Improvement 6 bug fixes', () => {
      148 |       // Fix 1: Registration timeout
    > 149 |       expect(backgroundJs).toContain('// âœ… IMPROVEMENT 6: Set registration timeout');
          |                            ^
      150 |
      151 |       // Fix 2: Reset state on disconnect
      152 |       expect(backgroundJs).toContain('// âœ… IMPROVEMENT 6 FIX: Reset registration state');

      at Object.toContain (tests/integration/improvements-verification.test.js:149:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Integration Points â€º should have all improvements working together

    expect(received).toContain(expected) // indexOf

    Expected substring: "registrationPending"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      157 |     it('should have all improvements working together', () => {
      158 |       // All three flags should exist
    > 159 |       expect(backgroundJs).toContain('registrationPending');
          |                            ^
      160 |       expect(backgroundJs).toContain('messageQueue');
      161 |       expect(backgroundJs).toContain('withTimeout');
      162 |

      at Object.toContain (tests/integration/improvements-verification.test.js:159:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Code Quality Checks â€º should have logging for all improvements

    expect(received).toContain(expected) // indexOf

    Expected substring: "Registration confirmed by server"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      184 |     it('should have logging for all improvements', () => {
      185 |       // Improvement 6: Registration logs
    > 186 |       expect(backgroundJs).toContain('Registration confirmed by server');
          |                            ^
      187 |       expect(backgroundJs).toContain('Registration timeout');
      188 |
      189 |       // Improvement 7: Queue logs

      at Object.toContain (tests/integration/improvements-verification.test.js:186:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Code Quality Checks â€º should have consistent comment markers

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      201 |       const improvement8Markers = (backgroundJs.match(/âœ… IMPROVEMENT 8/g) || []).length;
      202 |
    > 203 |       expect(improvement6Markers).toBeGreaterThan(0);
          |                                   ^
      204 |       expect(improvement7Markers).toBeGreaterThan(0);
      205 |       // Improvement 8 might not have markers in every use
      206 |     });

      at Object.toBeGreaterThan (tests/integration/improvements-verification.test.js:203:35)

PASS tests/unit/tab-cleanup.test.js
  â— Console

    console.log
      [ChromeDevAssist] Background service worker started

      at Object.log (extension/background.js:19:9)

FAIL tests/integration/improvements-6-7-8.test.js
  â— Test suite failed to run

    Cannot find module '../../api/index' from 'tests/integration/improvements-6-7-8.test.js'

       9 |  */
      10 |
    > 11 | const ChromeDevAssist = require('../../api/index');
         |                         ^
      12 |
      13 | describe('Integration: Improvements 6, 7, 8', () => {
      14 |   let api;

      at Resolver._throwModNotFoundError (node_modules/jest-resolve/build/resolver.js:427:11)
      at Object.require (tests/integration/improvements-6-7-8.test.js:11:25)

PASS tests/integration/server-health-integration.test.js
FAIL tests/integration/service-worker-api.test.js
  â— Console

    console.log
      
      âœ… All service worker API tests completed

      at Object.log (tests/integration/service-worker-api.test.js:209:13)

  â— Service Worker API - New Features â€º wakeServiceWorker() â€º should wake the service worker by sending a ping

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      13 |   describe('wakeServiceWorker()', () => {
      14 |     it('should wake the service worker by sending a ping', async () => {
    > 15 |       const result = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      16 |
      17 |       expect(result).toBeDefined();
      18 |       expect(result.success).toBe(true);

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:15:44)

  â— Service Worker API - New Features â€º wakeServiceWorker() â€º should return metadata about the service worker

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      22 |
      23 |     it('should return metadata about the service worker', async () => {
    > 24 |       const result = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      25 |
      26 |       expect(result.extensionId).toBeDefined();
      27 |       expect(result.version).toBeDefined();

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:24:44)

  â— Service Worker API - New Features â€º wakeServiceWorker() â€º should work multiple times in succession

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      29 |
      30 |     it('should work multiple times in succession', async () => {
    > 31 |       const result1 = await chromeDevAssist.wakeServiceWorker();
         |                                             ^
      32 |       const result2 = await chromeDevAssist.wakeServiceWorker();
      33 |       const result3 = await chromeDevAssist.wakeServiceWorker();
      34 |

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:31:45)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should return service worker running status

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      45 |   describe('getServiceWorkerStatus()', () => {
      46 |     it('should return service worker running status', async () => {
    > 47 |       const status = await chromeDevAssist.getServiceWorkerStatus();
         |                                            ^
      48 |
      49 |       expect(status).toBeDefined();
      50 |       expect(typeof status.running).toBe('boolean');

      at Object.getServiceWorkerStatus (tests/integration/service-worker-api.test.js:47:44)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should return true for running and connected after wake

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      54 |     it('should return true for running and connected after wake', async () => {
      55 |       // Wake first to ensure it's running
    > 56 |       await chromeDevAssist.wakeServiceWorker();
         |                             ^
      57 |
      58 |       const status = await chromeDevAssist.getServiceWorkerStatus();
      59 |

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:56:29)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should include metadata when service worker is running

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      63 |
      64 |     it('should include metadata when service worker is running', async () => {
    > 65 |       const status = await chromeDevAssist.getServiceWorkerStatus();
         |                                            ^
      66 |
      67 |       if (status.running) {
      68 |         expect(status.extensionId).toBeDefined();

      at Object.getServiceWorkerStatus (tests/integration/service-worker-api.test.js:65:44)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should have reasonable response time

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      74 |     it('should have reasonable response time', async () => {
      75 |       const startTime = Date.now();
    > 76 |       await chromeDevAssist.getServiceWorkerStatus();
         |                             ^
      77 |       const endTime = Date.now();
      78 |
      79 |       const responseTime = endTime - startTime;

      at Object.getServiceWorkerStatus (tests/integration/service-worker-api.test.js:76:29)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should return a manual helper object

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      86 |   describe('captureServiceWorkerLogs() - Manual Helper', () => {
      87 |     it('should return a manual helper object', () => {
    > 88 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
         |                                      ^
      89 |
      90 |       expect(helper).toBeDefined();
      91 |       expect(helper.manual).toBe(true);

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:88:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should provide instructions

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      94 |
      95 |     it('should provide instructions', () => {
    > 96 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
         |                                      ^
      97 |
      98 |       expect(helper.instructions).toBeDefined();
      99 |       expect(typeof helper.instructions).toBe('string');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:96:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should provide URLs for manual access

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      103 |
      104 |     it('should provide URLs for manual access', () => {
    > 105 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      106 |
      107 |       expect(helper.urls).toBeDefined();
      108 |       expect(helper.urls.extensions).toBe('chrome://extensions');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:105:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should include the duration in instructions

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      111 |
      112 |     it('should include the duration in instructions', () => {
    > 113 |       const helper = chromeDevAssist.captureServiceWorkerLogs(7500);
          |                                      ^
      114 |
      115 |       expect(helper.instructions).toContain('7500');
      116 |     });

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:113:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should have a printInstructions method

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      117 |
      118 |     it('should have a printInstructions method', () => {
    > 119 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      120 |
      121 |       expect(helper.printInstructions).toBeDefined();
      122 |       expect(typeof helper.printInstructions).toBe('function');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:119:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should provide troubleshooting guidance

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      127 |
      128 |     it('should provide troubleshooting guidance', () => {
    > 129 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      130 |
      131 |       expect(helper.troubleshooting).toBeDefined();
      132 |       expect(typeof helper.troubleshooting).toBe('object');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:129:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should include expected log format information

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      135 |
      136 |     it('should include expected log format information', () => {
    > 137 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      138 |
      139 |       expect(helper.expectedFormat).toBeDefined();
      140 |       expect(helper.expectedFormat.levels).toBeDefined();

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:137:38)

  â— Service Worker API - New Features â€º External Logging Capability â€º should provide enableExternalLogging function

    expect(received).toBeDefined()

    Received: undefined

      147 |   describe('External Logging Capability', () => {
      148 |     it('should provide enableExternalLogging function', () => {
    > 149 |       expect(chromeDevAssist.enableExternalLogging).toBeDefined();
          |                                                     ^
      150 |       expect(typeof chromeDevAssist.enableExternalLogging).toBe('function');
      151 |     });
      152 |

      at Object.toBeDefined (tests/integration/service-worker-api.test.js:149:53)

  â— Service Worker API - New Features â€º External Logging Capability â€º should enable external logging with endpoint

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      152 |
      153 |     it('should enable external logging with endpoint', async () => {
    > 154 |       const result = await chromeDevAssist.enableExternalLogging({
          |                                            ^
      155 |         endpoint: 'http://localhost:9999/logs',
      156 |         levels: ['error', 'warn']
      157 |       });

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:154:44)

  â— Service Worker API - New Features â€º External Logging Capability â€º should disable external logging

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      164 |     it('should disable external logging', async () => {
      165 |       // Enable first
    > 166 |       await chromeDevAssist.enableExternalLogging({
          |                             ^
      167 |         endpoint: 'http://localhost:9999/logs'
      168 |       });
      169 |

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:166:29)

  â— Service Worker API - New Features â€º External Logging Capability â€º should get external logging status

    TypeError: chromeDevAssist.getExternalLoggingStatus is not a function

      176 |
      177 |     it('should get external logging status', async () => {
    > 178 |       const status = await chromeDevAssist.getExternalLoggingStatus();
          |                                            ^
      179 |
      180 |       expect(status).toBeDefined();
      181 |       expect(typeof status.enabled).toBe('boolean');

      at Object.getExternalLoggingStatus (tests/integration/service-worker-api.test.js:178:44)

  â— Service Worker API - New Features â€º External Logging Capability â€º should reject invalid endpoint URLs

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      184 |     it('should reject invalid endpoint URLs', async () => {
      185 |       await expect(
    > 186 |         chromeDevAssist.enableExternalLogging({ endpoint: 'not-a-url' })
          |                         ^
      187 |       ).rejects.toThrow();
      188 |     }, 10000);
      189 |

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:186:25)

  â— Service Worker API - New Features â€º External Logging Capability â€º should accept valid log levels only

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      189 |
      190 |     it('should accept valid log levels only', async () => {
    > 191 |       const result = await chromeDevAssist.enableExternalLogging({
          |                                            ^
      192 |         endpoint: 'http://localhost:9999/logs',
      193 |         levels: ['log', 'error', 'warn', 'info', 'debug']
      194 |       });

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:191:44)

PASS tests/unit/hard-reload.test.js
PASS tests/unit/auth-token-fixture-access.test.js
PASS tests/integration/api-client.test.js
PASS tests/integration/websocket-server.test.js
PASS tests/unit/script-registration.test.js
  â— Console

    console.log
      [ChromeDevAssist] Background service worker started

      at Object.log (extension/background.js:19:9)

FAIL tests/unit/level4-reload-cdp.test.js
  â— Test suite failed to run

    Jest encountered an unexpected token

    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.

    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.

    By default "node_modules" folder is ignored by transformers.

    Here's what you can do:
     â€¢ If you are trying to use ECMAScript Modules, see https://jestjs.io/docs/ecmascript-modules for how to enable it.
     â€¢ If you are trying to use TypeScript, see https://jestjs.io/docs/getting-started#using-typescript
     â€¢ To have some of your "node_modules" files transformed, you can specify a custom "transformIgnorePatterns" in your config.
     â€¢ If you need a custom transformation specify a "transform" option in your config.
     â€¢ If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the "moduleNameMapper" config option.

    You'll find more details and examples of these config options in the docs:
    https://jestjs.io/docs/configuration
    For information about custom transformations, see:
    https://jestjs.io/docs/code-transformation

    Details:

    SyntaxError: /Users/gadievron/Documents/Claude Code/chrome-dev-assist/tests/unit/level4-reload-cdp.test.js: Missing semicolon. (32:6)

      30 |       // const result = await level4ReloadCDP(TEST_EXTENSION_ID, { port: CDP_PORT });
      31 |       // expect(result.method).toBe('cdp');
    > 32 | - will fail when implementing
         |       ^
      33 |     });
      34 |
      35 |     // TODO: INCOMPLETE - CDP testing requires debug mode

      at constructor (node_modules/@babel/parser/src/parse-error.ts:95:45)
      at Parser.toParseError [as raise] (node_modules/@babel/parser/src/tokenizer/index.ts:1507:19)
      at Parser.raise [as semicolon] (node_modules/@babel/parser/src/parser/util.ts:149:10)
      at Parser.semicolon [as parseExpressionStatement] (node_modules/@babel/parser/src/parser/statement.ts:1363:10)
      at Parser.parseExpressionStatement [as parseStatementContent] (node_modules/@babel/parser/src/parser/statement.ts:702:19)
      at Parser.parseStatementContent [as parseStatementLike] (node_modules/@babel/parser/src/parser/statement.ts:482:17)
      at Parser.parseStatementLike [as parseStatementListItem] (node_modules/@babel/parser/src/parser/statement.ts:431:17)
      at Parser.parseStatementListItem [as parseBlockOrModuleBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1444:16)
      at Parser.parseBlockOrModuleBlockBody [as parseBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1417:10)
      at Parser.parseBlockBody [as parseBlock] (node_modules/@babel/parser/src/parser/statement.ts:1385:10)
      at Parser.parseBlock [as parseFunctionBody] (node_modules/@babel/parser/src/parser/expression.ts:2626:24)
      at Parser.parseFunctionBody [as parseArrowExpression] (node_modules/@babel/parser/src/parser/expression.ts:2563:10)
      at Parser.parseArrowExpression [as parseAsyncArrowFromCallExpression] (node_modules/@babel/parser/src/parser/expression.ts:1067:10)
      at Parser.parseAsyncArrowFromCallExpression [as parseCoverCallAndAsyncArrowHead] (node_modules/@babel/parser/src/parser/expression.ts:942:27)
      at Parser.parseCoverCallAndAsyncArrowHead [as parseSubscript] (node_modules/@babel/parser/src/parser/expression.ts:804:19)
      at Parser.parseSubscript [as parseSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:763:19)
      at Parser.parseSubscripts [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:748:17)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at parseMaybeAssign (node_modules/@babel/parser/src/parser/expression.ts:257:12)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3202:12)
      at Parser.allowInAnd [as parseMaybeAssignAllowIn] (node_modules/@babel/parser/src/parser/expression.ts:256:17)
      at Parser.parseMaybeAssignAllowIn [as parseMaybeAssignAllowInOrVoidPattern] (node_modules/@babel/parser/src/parser/expression.ts:3316:17)
      at Parser.parseMaybeAssignAllowInOrVoidPattern [as parseExprListItem] (node_modules/@babel/parser/src/parser/expression.ts:2798:18)
      at Parser.parseExprListItem [as parseCallExpressionArguments] (node_modules/@babel/parser/src/parser/expression.ts:1042:14)
      at Parser.parseCallExpressionArguments [as parseCoverCallAndAsyncArrowHead] (node_modules/@babel/parser/src/parser/expression.ts:922:29)
      at Parser.parseCoverCallAndAsyncArrowHead [as parseSubscript] (node_modules/@babel/parser/src/parser/expression.ts:804:19)
      at Parser.parseSubscript [as parseSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:763:19)
      at Parser.parseSubscripts [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:748:17)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at Parser.parseMaybeAssign [as parseExpressionBase] (node_modules/@babel/parser/src/parser/expression.ts:226:23)
      at parseExpressionBase (node_modules/@babel/parser/src/parser/expression.ts:217:39)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3197:16)
      at Parser.allowInAnd [as parseExpression] (node_modules/@babel/parser/src/parser/expression.ts:217:17)
      at Parser.parseExpression [as parseStatementContent] (node_modules/@babel/parser/src/parser/statement.ts:688:23)
      at Parser.parseStatementContent [as parseStatementLike] (node_modules/@babel/parser/src/parser/statement.ts:482:17)
      at Parser.parseStatementLike [as parseStatementListItem] (node_modules/@babel/parser/src/parser/statement.ts:431:17)
      at Parser.parseStatementListItem [as parseBlockOrModuleBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1444:16)
      at Parser.parseBlockOrModuleBlockBody [as parseBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1417:10)
      at Parser.parseBlockBody [as parseBlock] (node_modules/@babel/parser/src/parser/statement.ts:1385:10)
      at Parser.parseBlock [as parseFunctionBody] (node_modules/@babel/parser/src/parser/expression.ts:2626:24)
      at Parser.parseFunctionBody [as parseArrowExpression] (node_modules/@babel/parser/src/parser/expression.ts:2563:10)
      at Parser.parseArrowExpression [as parseParenAndDistinguishExpression] (node_modules/@babel/parser/src/parser/expression.ts:1847:12)
      at Parser.parseParenAndDistinguishExpression [as parseExprAtom] (node_modules/@babel/parser/src/parser/expression.ts:1170:21)
      at Parser.parseExprAtom [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:742:23)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at parseMaybeAssign (node_modules/@babel/parser/src/parser/expression.ts:257:12)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3202:12)
      at Parser.allowInAnd [as parseMaybeAssignAllowIn] (node_modules/@babel/parser/src/parser/expression.ts:256:17)
      at Parser.parseMaybeAssignAllowIn [as parseMaybeAssignAllowInOrVoidPattern] (node_modules/@babel/parser/src/parser/expression.ts:3316:17)
      at Parser.parseMaybeAssignAllowInOrVoidPattern [as parseExprListItem] (node_modules/@babel/parser/src/parser/expression.ts:2798:18)
      at Parser.parseExprListItem [as parseCallExpressionArguments] (node_modules/@babel/parser/src/parser/expression.ts:1042:14)
      at Parser.parseCallExpressionArguments [as parseCoverCallAndAsyncArrowHead] (node_modules/@babel/parser/src/parser/expression.ts:922:29)
      at Parser.parseCoverCallAndAsyncArrowHead [as parseSubscript] (node_modules/@babel/parser/src/parser/expression.ts:804:19)
      at Parser.parseSubscript [as parseSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:763:19)
      at Parser.parseSubscripts [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:748:17)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at Parser.parseMaybeAssign [as parseExpressionBase] (node_modules/@babel/parser/src/parser/expression.ts:226:23)
      at parseExpressionBase (node_modules/@babel/parser/src/parser/expression.ts:217:39)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3197:16)
      at Parser.allowInAnd [as parseExpression] (node_modules/@babel/parser/src/parser/expression.ts:217:17)
      at Parser.parseExpression [as parseStatementContent] (node_modules/@babel/parser/src/parser/statement.ts:688:23)
      at Parser.parseStatementContent [as parseStatementLike] (node_modules/@babel/parser/src/parser/statement.ts:482:17)
      at Parser.parseStatementLike [as parseStatementListItem] (node_modules/@babel/parser/src/parser/statement.ts:431:17)
      at Parser.parseStatementListItem [as parseBlockOrModuleBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1444:16)
      at Parser.parseBlockOrModuleBlockBody [as parseBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1417:10)
      at Parser.parseBlockBody [as parseBlock] (node_modules/@babel/parser/src/parser/statement.ts:1385:10)
      at Parser.parseBlock [as parseFunctionBody] (node_modules/@babel/parser/src/parser/expression.ts:2626:24)
      at Parser.parseFunctionBody [as parseArrowExpression] (node_modules/@babel/parser/src/parser/expression.ts:2563:10)
      at Parser.parseArrowExpression [as parseParenAndDistinguishExpression] (node_modules/@babel/parser/src/parser/expression.ts:1847:12)
      at Parser.parseParenAndDistinguishExpression [as parseExprAtom] (node_modules/@babel/parser/src/parser/expression.ts:1170:21)
      at Parser.parseExprAtom [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:742:23)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at parseMaybeAssign (node_modules/@babel/parser/src/parser/expression.ts:257:12)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3202:12)
      at Parser.allowInAnd [as parseMaybeAssignAllowIn] (node_modules/@babel/parser/src/parser/expression.ts:256:17)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "[Server ERROR] WebSocket error: Error: listen EADDRINUSE: address already in use 127.0.0.1:9876
        at Server.setupListenHandle [as _listen2] (node:net:1940:16)
        at listenInCluster (node:net:1997:12)
        at node:net:2206:7
        at processTicksAndRejections (node:internal/process/task_queues:90:21) {
      code: 'EADDRINUSE',
      errno: -48,
      syscall: 'listen',
      address: '127.0.0.1',
      port: 9876
    }".

      138 |
      139 | function logError(...args) {
    > 140 |   console.error('[Server ERROR]', ...args);
          |           ^
      141 | }
      142 |
      143 | /**

      at processTicksAndRejections (node:internal/process/task_queues:90:21) {
        code: 'EADDRINUSE',
        errno: -48,
        syscall: 'listen',
        address: '127.0.0.1',
        port: 9876
      }".
      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at error (server/websocket-server.js:140:11)
      at WebSocketServer.logError (server/websocket-server.js:416:3)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      394 | httpServer.on('error', (err) => {
      395 |   if (err.code === 'EADDRINUSE') {
    > 396 |     console.error('');
          |             ^
      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
      399 |     console.error('This usually means:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:396:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "ERROR: Port 9876 is already in use.".

      395 |   if (err.code === 'EADDRINUSE') {
      396 |     console.error('');
    > 397 |     console.error('ERROR: Port 9876 is already in use.');
          |             ^
      398 |     console.error('');
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:397:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      396 |     console.error('');
      397 |     console.error('ERROR: Port 9876 is already in use.');
    > 398 |     console.error('');
          |             ^
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:398:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "This usually means:".

      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
    > 399 |     console.error('This usually means:');
          |             ^
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:399:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  1. The server is already running (check other terminals)".

      398 |     console.error('');
      399 |     console.error('This usually means:');
    > 400 |     console.error('  1. The server is already running (check other terminals)');
          |             ^
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
      403 |     console.error('To fix:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:400:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  2. Another application is using port 9876".

      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
    > 401 |     console.error('  2. Another application is using port 9876');
          |             ^
      402 |     console.error('');
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:401:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
    > 402 |     console.error('');
          |             ^
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:402:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "To fix:".

      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
    > 403 |     console.error('To fix:');
          |             ^
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:403:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Stop the other process using port 9876".

      402 |     console.error('');
      403 |     console.error('To fix:');
    > 404 |     console.error('  - Stop the other process using port 9876');
          |             ^
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
      407 |     process.exit(1);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:404:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Or kill existing server: pkill -f websocket-server".

      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
    > 405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
          |             ^
      406 |     console.error('');
      407 |     process.exit(1);
      408 |   } else {

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:405:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
    > 406 |     console.error('');
          |             ^
      407 |     process.exit(1);
      408 |   } else {
      409 |     logError('Server error:', err);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:406:13)

  â—  process.exit called with "1"

      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
    > 407 |     process.exit(1);
          |             ^
      408 |   } else {
      409 |     logError('Server error:', err);
      410 |     process.exit(1);

      at Server.exit (server/websocket-server.js:407:13)
FAIL tests/integration/screenshot-security.test.js
  â— Console

    console.log
      
      ğŸ”’ SECURITY PRINCIPLE: LEAST PRIVILEGE

      at Object.log (tests/integration/screenshot-security.test.js:136:15)

    console.log
      =====================================

      at Object.log (tests/integration/screenshot-security.test.js:137:15)

    console.log
      Screenshot restriction to localhost:9876 prevents:

      at Object.log (tests/integration/screenshot-security.test.js:138:15)

    console.log
        â€¢ Capturing banking/financial data

      at Object.log (tests/integration/screenshot-security.test.js:139:15)

    console.log
        â€¢ Capturing passwords or credentials

      at Object.log (tests/integration/screenshot-security.test.js:140:15)

    console.log
        â€¢ Capturing personal information

      at Object.log (tests/integration/screenshot-security.test.js:141:15)

    console.log
        â€¢ Capturing proprietary/confidential content

      at Object.log (tests/integration/screenshot-security.test.js:142:15)

    console.log
        â€¢ Capturing user's browsing activity

      at Object.log (tests/integration/screenshot-security.test.js:143:15)

    console.log


      at Object.log (tests/integration/screenshot-security.test.js:144:15)

    console.log
      âœ… Screenshots limited to test fixtures only

      at Object.log (tests/integration/screenshot-security.test.js:145:15)

    console.log
      âœ… Principle of least privilege enforced

      at Object.log (tests/integration/screenshot-security.test.js:146:15)

    console.log
      âœ… Defense-in-depth: API layer + Extension layer validation

      at Object.log (tests/integration/screenshot-security.test.js:147:15)

  â— Screenshot Security Restrictions â€º Allowed: localhost:9876 only â€º should allow screenshots from localhost:9876

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Blocked: External websites â€º should block screenshots from google.com

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Blocked: External websites â€º should block screenshots from github.com

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Blocked: Different localhost ports â€º should block screenshots from localhost:3000

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Security Error Messages â€º should provide clear error message with allowed origin

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Security Principle: Least Privilege â€º should document why restriction exists

    expect(received).toBe(expected) // Object.is equality

    Expected: "function"
    Received: "undefined"

      148 |
      149 |       // Real assertion: Verify security constants are defined
    > 150 |       expect(typeof chromeDevAssist.captureScreenshot).toBe('function');
          |                                                        ^
      151 |     });
      152 |   });
      153 | });

      at Object.toBe (tests/integration/screenshot-security.test.js:150:56)

FAIL tests/integration/service-worker-lifecycle.test.js
  â— Console

    console.log
      
      âœ… Keep-alive mechanism tests completed

      at Object.log (tests/integration/service-worker-lifecycle.test.js:138:13)

  â— Keep-Alive Mechanisms â€º WebSocket Ping Mechanism â€º should send ping messages when connection is active

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      17 |     it('should send ping messages when connection is active', async () => {
      18 |       // Wake service worker to ensure connection
    > 19 |       const status = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      20 |       expect(status.success).toBe(true);
      21 |       expect(status.running).toBe(true);
      22 |

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:19:44)

  â— Keep-Alive Mechanisms â€º WebSocket Ping Mechanism â€º should reconnect if connection lost during keep-alive

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      36 |       // In production, if WebSocket closes, the alarm will trigger reconnection
      37 |
    > 38 |       const status = await chromeDevAssist.getServiceWorkerStatus();
         |                                            ^
      39 |       expect(status.running).toBe(true);
      40 |     }, 10000);
      41 |   });

      at Object.getServiceWorkerStatus (tests/integration/service-worker-lifecycle.test.js:38:44)

  â— Keep-Alive Mechanisms â€º Connection Resilience â€º should maintain connection for extended periods

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      44 |     it('should maintain connection for extended periods', async () => {
      45 |       // Verify connection persists beyond service worker idle timeout (30s)
    > 46 |       const initialStatus = await chromeDevAssist.wakeServiceWorker();
         |                                                   ^
      47 |       expect(initialStatus.success).toBe(true);
      48 |
      49 |       const initialTime = initialStatus.timestamp;

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:46:51)

  â— Keep-Alive Mechanisms â€º Connection Resilience â€º should handle multiple rapid status checks

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      63 |       // Rapid API calls should not break connection
      64 |       const results = await Promise.all([
    > 65 |         chromeDevAssist.getServiceWorkerStatus(),
         |                         ^
      66 |         chromeDevAssist.getServiceWorkerStatus(),
      67 |         chromeDevAssist.getServiceWorkerStatus(),
      68 |         chromeDevAssist.wakeServiceWorker(),

      at Object.getServiceWorkerStatus (tests/integration/service-worker-lifecycle.test.js:65:25)

  â— Keep-Alive Mechanisms â€º Service Worker Lifecycle â€º should have alarm configured for keep-alive

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      83 |       // which implies alarms are working
      84 |
    > 85 |       const status = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      86 |       expect(status.success).toBe(true);
      87 |
      88 |       // If alarm wasn't configured, service worker would be idle

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:85:44)

  â— Keep-Alive Mechanisms â€º Service Worker Lifecycle â€º should respond immediately to wake requests

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

       96 |     it('should respond immediately to wake requests', async () => {
       97 |       const startTime = Date.now();
    >  98 |       const result = await chromeDevAssist.wakeServiceWorker();
          |                                            ^
       99 |       const endTime = Date.now();
      100 |
      101 |       const responseTime = endTime - startTime;

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:98:44)

  â— Keep-Alive Mechanisms â€º Error Recovery â€º should recover from temporary disconnections

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      110 |     it('should recover from temporary disconnections', async () => {
      111 |       // Initial connection
    > 112 |       const status1 = await chromeDevAssist.wakeServiceWorker();
          |                                             ^
      113 |       expect(status1.success).toBe(true);
      114 |
      115 |       // Simulate work

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:112:45)

  â— Keep-Alive Mechanisms â€º Error Recovery â€º should handle server restart gracefully

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      126 |       // If server is down, API will auto-start it
      127 |
    > 128 |       const status = await chromeDevAssist.getServiceWorkerStatus();
          |                                            ^
      129 |       expect(status).toBeDefined();
      130 |
      131 |       // Even if connection was lost, it should recover

      at Object.getServiceWorkerStatus (tests/integration/service-worker-lifecycle.test.js:128:44)

PASS tests/unit/health-manager-api-socket.test.js
PASS tests/performance/health-manager-performance.test.js
  â— Console

    console.log
      isExtensionConnected() avg time: 0.0000ms (10000 iterations)

      at Object.log (tests/performance/health-manager-performance.test.js:28:13)

    console.log
      getHealthStatus() avg time: 0.0000ms (1000 iterations)

      at Object.log (tests/performance/health-manager-performance.test.js:49:13)

    console.log
      ensureHealthy() avg time: 0.0000ms (1000 iterations)

      at Object.log (tests/performance/health-manager-performance.test.js:70:13)

    console.log
      1000 rapid state changes completed in 3ms

      at Object.log (tests/performance/health-manager-performance.test.js:97:13)

    console.log
      Memory delta after 10000 status checks: 3.95 MB

      at Object.log (tests/performance/health-manager-performance.test.js:125:13)

PASS tests/unit/metadata-leak-debug.test.js
PASS tests/integration/health-manager-realws.test.js
FAIL tests/api/index.test.js
  â— Chrome Dev Assist API â€º reloadAndCapture() â€º should return console logs after reload

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º reloadAndCapture() â€º should accept options for duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º reload() â€º should reload extension without capturing logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º captureLogs() â€º should capture console logs for specified duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º captureLogs() â€º should default to 5000ms if no duration specified

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

PASS tests/integration/native-messaging.test.js
FAIL tests/integration/resource-cleanup.test.js
  â— Console

    console.warn
      Found temporary test files: [
        'test-5s.js',
        'test-api.js',
        'test-auth-debug.js',
        'test-auto-debug.js',
        'test-capture.js',
        'test-complete-system.js',
        'test-connection-simple.js',
        'test-console-capture-diagnostic.js',
        'test-console-minimal.js',
        'test-errorlogger-automated.js',
        'test-errorlogger-reload.js',
        'test-errorlogger-simple.js',
        'test-errors.js',
        'test-example.js',
        'test-force-reload.js',
        'test-getallextensions.js',
        'test-http-page.js',
        'test-https-url.js',
        'test-list-extensions.js',
        'test-longer-duration.js',
        'test-manual-open.js',
        'test-reload-after-fix.js',
        'test-reload-and-verify-errorlogger.js',
        'test-reload-self.js',
        'test-tab-cleanup-verification.js',
        'test-verify-inject-script.js'
      ]

      123 |
      124 |       if (tempTestFiles.length > 0) {
    > 125 |         console.warn('Found temporary test files:', tempTestFiles);
          |                 ^
      126 |         // Don't fail - just warn, as some might be legitimate
      127 |       }
      128 |     });

      at Object.warn (tests/integration/resource-cleanup.test.js:125:17)

  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should detect Chrome test instances

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh 2>&1 | grep -i chrome



  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should detect server processes

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh 2>&1 | grep -i server



  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should detect debug logging in code

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh 2>&1 | grep -i debug



  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should verify cleanup completion

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh
    bash: /Users/gadievron/Documents/Claude: No such file or directory



  â— Resource Cleanup Verification â€º Process Detection â€º should detect background test processes

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: undefined

      104 |       } catch (err) {
      105 |         // No processes found (grep returns non-zero) - this is good
    > 106 |         expect(err.code).toBe(1);
          |                          ^
      107 |       }
      108 |     });
      109 |   });

      at Object.toBe (tests/integration/resource-cleanup.test.js:106:26)

  â— Resource Cleanup Verification â€º PID File Management â€º should clean up PID file when server stops

    ReferenceError: fail is not defined

      170 |         } catch (err) {
      171 |           // Process doesn't exist but PID file does - cleanup needed
    > 172 |           fail(`Stale PID file found. Process ${pid} not running. Run cleanup script.`);
          |           ^
      173 |         }
      174 |       }
      175 |     });

      at Object.fail (tests/integration/resource-cleanup.test.js:172:11)

  â— Resource Cleanup Verification â€º Verification After Test Run â€º should verify no leaked resources after test suite

    ReferenceError: fail is not defined

      223 |           '\n   Run: ./scripts/cleanup-test-session.sh';
      224 |
    > 225 |         fail(message);
          |         ^
      226 |       }
      227 |
      228 |       expect(issues).toEqual([]);

      at Object.fail (tests/integration/resource-cleanup.test.js:225:9)

PASS tests/unit/ConsoleCapture.poc.test.js
  â— Console

    console.log
      âœ… POC Test 1 passed: Can start a capture

      at Object.log (tests/unit/ConsoleCapture.poc.test.js:62:13)

    console.log
      âœ… POC Test 2 passed: Can add logs to capture

      at Object.log (tests/unit/ConsoleCapture.poc.test.js:90:13)

    console.log
      âœ… POC Test 3 passed: Can stop a capture

      at Object.log (tests/unit/ConsoleCapture.poc.test.js:107:13)

    console.log
      âœ… POC Test 4 passed: Can get logs from capture

      at Object.log (tests/unit/ConsoleCapture.poc.test.js:139:13)

    console.log
      âœ… POC Test 5 passed: Can cleanup a capture

      at Object.log (tests/unit/ConsoleCapture.poc.test.js:180:13)

    console.log
      âœ… POC Test BONUS passed: Auto-stop after duration

      at Object.log (tests/unit/ConsoleCapture.poc.test.js:200:13)

PASS tests/unit/extension-discovery-validation.test.js
FAIL tests/unit/console-capture-race-condition.test.js
  â— Console

    console.log
      [ChromeDevAssist] Background service worker started

      at Object.log (extension/background.js:19:9)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "data:text/html,<html><head><script>console.log(\"test\")</script></head></html>",
        "captureConsole": true,
        "duration": 100
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'data:text/html,<html><head><script>console.log("test")</script></head></html>',
        active: true,
        captureConsole: true,
        duration: 100,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "http://localhost:9876/test.html",
        "captureConsole": true,
        "duration": 100
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'http://localhost:9876/test.html',
        active: true,
        captureConsole: true,
        duration: 100,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] Opening URL: http://localhost:9876/test.html

      at log (extension/background.js:428:11)

    console.log
      [ChromeDevAssist] Console capture started for command cmd-1 (tab 123)

      at log (extension/background.js:592:11)

    console.log
      [ChromeDevAssist] Console capture complete for command cmd-1: 0 logs

      at Timeout.log [as _onTimeout] (extension/background.js:600:15)

    console.log
      [ChromeDevAssist] Entering finally block, autoClose = false

      at log (extension/background.js:454:13)

    console.log
      [ChromeDevAssist] autoClose=false, skipping tab cleanup

      at log (extension/background.js:496:15)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "http://localhost:9876/test.html",
        "captureConsole": true,
        "duration": 200
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'http://localhost:9876/test.html',
        active: true,
        captureConsole: true,
        duration: 200,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] Opening URL: http://localhost:9876/test.html

      at log (extension/background.js:428:11)

    console.log
      [ChromeDevAssist] Console capture started for command cmd-1 (tab 123)

      at log (extension/background.js:592:11)

    console.log
      [ChromeDevAssist] Console capture complete for command cmd-1: 0 logs

      at Timeout.log [as _onTimeout] (extension/background.js:600:15)

    console.log
      [ChromeDevAssist] Entering finally block, autoClose = false

      at log (extension/background.js:454:13)

    console.log
      [ChromeDevAssist] autoClose=false, skipping tab cleanup

      at log (extension/background.js:496:15)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "http://localhost:9876/test.html",
        "captureConsole": true,
        "duration": 200
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'http://localhost:9876/test.html',
        active: true,
        captureConsole: true,
        duration: 200,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] Opening URL: http://localhost:9876/test.html

      at log (extension/background.js:428:11)

    console.log
      [ChromeDevAssist] Console capture started for command cmd-1 (tab 123)

      at log (extension/background.js:592:11)

    console.log
      [ChromeDevAssist] Console capture complete for command cmd-1: 0 logs

      at Timeout.log [as _onTimeout] (extension/background.js:600:15)

    console.log
      [ChromeDevAssist] Entering finally block, autoClose = false

      at log (extension/background.js:454:13)

    console.log
      [ChromeDevAssist] autoClose=false, skipping tab cleanup

      at log (extension/background.js:496:15)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "http://localhost:9876/test.html",
        "captureConsole": true,
        "duration": 500
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'http://localhost:9876/test.html',
        active: true,
        captureConsole: true,
        duration: 500,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] Opening URL: http://localhost:9876/test.html

      at log (extension/background.js:428:11)

    console.log
      [ChromeDevAssist] Console capture started for command cmd-1 (tab 123)

      at log (extension/background.js:592:11)

    console.log
      [ChromeDevAssist] Console capture complete for command cmd-1: 0 logs

      at Timeout.log [as _onTimeout] (extension/background.js:600:15)

    console.log
      [ChromeDevAssist] Entering finally block, autoClose = false

      at log (extension/background.js:454:13)

    console.log
      [ChromeDevAssist] autoClose=false, skipping tab cleanup

      at log (extension/background.js:496:15)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "http://localhost:9876/test1.html",
        "captureConsole": true,
        "duration": 200
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'http://localhost:9876/test1.html',
        active: true,
        captureConsole: true,
        duration: 200,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] Opening URL: http://localhost:9876/test1.html

      at log (extension/background.js:428:11)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "http://localhost:9876/test2.html",
        "captureConsole": true,
        "duration": 200
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'http://localhost:9876/test2.html',
        active: true,
        captureConsole: true,
        duration: 200,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] Opening URL: http://localhost:9876/test2.html

      at log (extension/background.js:428:11)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "http://localhost:9876/test3.html",
        "captureConsole": true,
        "duration": 200
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'http://localhost:9876/test3.html',
        active: true,
        captureConsole: true,
        duration: 200,
        autoClose: false
      }

      at log (extension/background.js:383:11)

    console.log
      [ChromeDevAssist] Opening URL: http://localhost:9876/test3.html

      at log (extension/background.js:428:11)

    console.log
      [ChromeDevAssist] Console capture started for command cmd-1 (tab 101)

      at log (extension/background.js:592:11)
          at async Promise.all (index 0)

    console.log
      [ChromeDevAssist] Console capture started for command cmd-2 (tab 102)

      at log (extension/background.js:592:11)
          at async Promise.all (index 1)

    console.log
      [ChromeDevAssist] Console capture started for command cmd-3 (tab 103)

      at log (extension/background.js:592:11)
          at async Promise.all (index 2)

    console.log
      [ChromeDevAssist] Console capture complete for command cmd-1: 0 logs

      at Timeout.log [as _onTimeout] (extension/background.js:600:15)

    console.log
      [ChromeDevAssist] Console capture complete for command cmd-2: 0 logs

      at Timeout.log [as _onTimeout] (extension/background.js:600:15)

    console.log
      [ChromeDevAssist] Console capture complete for command cmd-3: 0 logs

      at Timeout.log [as _onTimeout] (extension/background.js:600:15)

    console.log
      [ChromeDevAssist] Entering finally block, autoClose = false

      at log (extension/background.js:454:13)
          at async Promise.all (index 0)

    console.log
      [ChromeDevAssist] autoClose=false, skipping tab cleanup

      at log (extension/background.js:496:15)
          at async Promise.all (index 0)

    console.log
      [ChromeDevAssist] Entering finally block, autoClose = false

      at log (extension/background.js:454:13)
          at async Promise.all (index 1)

    console.log
      [ChromeDevAssist] autoClose=false, skipping tab cleanup

      at log (extension/background.js:496:15)
          at async Promise.all (index 1)

    console.log
      [ChromeDevAssist] Entering finally block, autoClose = false

      at log (extension/background.js:454:13)
          at async Promise.all (index 2)

    console.log
      [ChromeDevAssist] autoClose=false, skipping tab cleanup

      at log (extension/background.js:496:15)
          at async Promise.all (index 2)

    console.log
      [ChromeDevAssist] handleOpenUrlCommand called with params: {
        "url": "file:///Users/test/fast.html",
        "captureConsole": true,
        "duration": 200
      }

      at log (extension/background.js:373:11)

    console.log
      [ChromeDevAssist] Extracted parameters: {
        url: 'file:///Users/test/fast.html',
        active: true,
        captureConsole: true,
        duration: 200,
        autoClose: false
      }

      at log (extension/background.js:383:11)

  â— Console Capture Race Condition Fix â€º should capture console messages from inline <head> scripts

    Dangerous URL protocol not allowed: data

      398 |   const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      399 |   if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
    > 400 |     throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
          |           ^
      401 |   }
      402 |
      403 |   // Security: Validate duration parameter

      at handleOpenUrlCommand (extension/background.js:400:11)
      at Object.handleOpenUrlCommand (tests/unit/console-capture-race-condition.test.js:80:26)

  â— Console Capture Race Condition Fix â€º should register capture BEFORE creating tab

    expect(received).toBeLessThan(expected)

    Matcher error: received value must be a number or bigint

    Received has value: undefined

      125 |
      126 |     // ASSERTION: Capture registered BEFORE tab created
    > 127 |     expect(captureTimestamps[0]).toBeLessThan(tabTimestamps[0]);
          |                                  ^
      128 |   });
      129 |
      130 |   /**

      at Object.toBeLessThan (tests/unit/console-capture-race-condition.test.js:127:34)

  â— Console Capture Race Condition Fix â€º should buffer messages that arrive before tab ID is set

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      170 |
      171 |     // ASSERTION: Buffered message should be in final logs
    > 172 |     expect(result.consoleLogs.some(log => log.message === 'EARLY-MESSAGE')).toBe(true);
          |                                                                             ^
      173 |   });
      174 |
      175 |   /**

      at Object.toBe (tests/unit/console-capture-race-condition.test.js:172:77)

  â— Console Capture Race Condition Fix â€º should capture console from fast-loading local file

    Dangerous URL protocol not allowed: file

      398 |   const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      399 |   if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
    > 400 |     throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
          |           ^
      401 |   }
      402 |
      403 |   // Security: Validate duration parameter

      at handleOpenUrlCommand (extension/background.js:400:11)
      at Object.handleOpenUrlCommand (tests/unit/console-capture-race-condition.test.js:312:26)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "[Server ERROR] WebSocket error: Error: listen EADDRINUSE: address already in use 127.0.0.1:9876
        at Server.setupListenHandle [as _listen2] (node:net:1940:16)
        at listenInCluster (node:net:1997:12)
        at node:net:2206:7
        at processTicksAndRejections (node:internal/process/task_queues:90:21) {
      code: 'EADDRINUSE',
      errno: -48,
      syscall: 'listen',
      address: '127.0.0.1',
      port: 9876
    }".

      138 |
      139 | function logError(...args) {
    > 140 |   console.error('[Server ERROR]', ...args);
          |           ^
      141 | }
      142 |
      143 | /**

      at processTicksAndRejections (node:internal/process/task_queues:90:21) {
        code: 'EADDRINUSE',
        errno: -48,
        syscall: 'listen',
        address: '127.0.0.1',
        port: 9876
      }".
      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at error (server/websocket-server.js:140:11)
      at WebSocketServer.logError (server/websocket-server.js:416:3)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      394 | httpServer.on('error', (err) => {
      395 |   if (err.code === 'EADDRINUSE') {
    > 396 |     console.error('');
          |             ^
      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
      399 |     console.error('This usually means:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:396:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "ERROR: Port 9876 is already in use.".

      395 |   if (err.code === 'EADDRINUSE') {
      396 |     console.error('');
    > 397 |     console.error('ERROR: Port 9876 is already in use.');
          |             ^
      398 |     console.error('');
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:397:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      396 |     console.error('');
      397 |     console.error('ERROR: Port 9876 is already in use.');
    > 398 |     console.error('');
          |             ^
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:398:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "This usually means:".

      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
    > 399 |     console.error('This usually means:');
          |             ^
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:399:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  1. The server is already running (check other terminals)".

      398 |     console.error('');
      399 |     console.error('This usually means:');
    > 400 |     console.error('  1. The server is already running (check other terminals)');
          |             ^
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
      403 |     console.error('To fix:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:400:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  2. Another application is using port 9876".

      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
    > 401 |     console.error('  2. Another application is using port 9876');
          |             ^
      402 |     console.error('');
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:401:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
    > 402 |     console.error('');
          |             ^
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:402:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "To fix:".

      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
    > 403 |     console.error('To fix:');
          |             ^
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:403:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Stop the other process using port 9876".

      402 |     console.error('');
      403 |     console.error('To fix:');
    > 404 |     console.error('  - Stop the other process using port 9876');
          |             ^
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
      407 |     process.exit(1);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:404:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Or kill existing server: pkill -f websocket-server".

      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
    > 405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
          |             ^
      406 |     console.error('');
      407 |     process.exit(1);
      408 |   } else {

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:405:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
    > 406 |     console.error('');
          |             ^
      407 |     process.exit(1);
      408 |   } else {
      409 |     logError('Server error:', err);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:406:13)

  â—  process.exit called with "1"

      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
    > 407 |     process.exit(1);
          |             ^
      408 |   } else {
      409 |     logError('Server error:', err);
      410 |     process.exit(1);

      at Server.exit (server/websocket-server.js:407:13)

  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "[Server ERROR] WebSocket error: Error: listen EADDRINUSE: address already in use 127.0.0.1:9876
        at Server.setupListenHandle [as _listen2] (node:net:1940:16)
        at listenInCluster (node:net:1997:12)
        at node:net:2206:7
        at processTicksAndRejections (node:internal/process/task_queues:90:21) {
      code: 'EADDRINUSE',
      errno: -48,
      syscall: 'listen',
      address: '127.0.0.1',
      port: 9876
    }".

      138 |
      139 | function logError(...args) {
    > 140 |   console.error('[Server ERROR]', ...args);
          |           ^
      141 | }
      142 |
      143 | /**

      at processTicksAndRejections (node:internal/process/task_queues:90:21) {
        code: 'EADDRINUSE',
        errno: -48,
        syscall: 'listen',
        address: '127.0.0.1',
        port: 9876
      }".
      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at error (server/websocket-server.js:140:11)
      at WebSocketServer.logError (server/websocket-server.js:416:3)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      394 | httpServer.on('error', (err) => {
      395 |   if (err.code === 'EADDRINUSE') {
    > 396 |     console.error('');
          |             ^
      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
      399 |     console.error('This usually means:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:396:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "ERROR: Port 9876 is already in use.".

      395 |   if (err.code === 'EADDRINUSE') {
      396 |     console.error('');
    > 397 |     console.error('ERROR: Port 9876 is already in use.');
          |             ^
      398 |     console.error('');
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:397:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      396 |     console.error('');
      397 |     console.error('ERROR: Port 9876 is already in use.');
    > 398 |     console.error('');
          |             ^
      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:398:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "This usually means:".

      397 |     console.error('ERROR: Port 9876 is already in use.');
      398 |     console.error('');
    > 399 |     console.error('This usually means:');
          |             ^
      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:399:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  1. The server is already running (check other terminals)".

      398 |     console.error('');
      399 |     console.error('This usually means:');
    > 400 |     console.error('  1. The server is already running (check other terminals)');
          |             ^
      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
      403 |     console.error('To fix:');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:400:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  2. Another application is using port 9876".

      399 |     console.error('This usually means:');
      400 |     console.error('  1. The server is already running (check other terminals)');
    > 401 |     console.error('  2. Another application is using port 9876');
          |             ^
      402 |     console.error('');
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:401:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      400 |     console.error('  1. The server is already running (check other terminals)');
      401 |     console.error('  2. Another application is using port 9876');
    > 402 |     console.error('');
          |             ^
      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:402:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "To fix:".

      401 |     console.error('  2. Another application is using port 9876');
      402 |     console.error('');
    > 403 |     console.error('To fix:');
          |             ^
      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:403:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Stop the other process using port 9876".

      402 |     console.error('');
      403 |     console.error('To fix:');
    > 404 |     console.error('  - Stop the other process using port 9876');
          |             ^
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
      407 |     process.exit(1);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:404:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "  - Or kill existing server: pkill -f websocket-server".

      403 |     console.error('To fix:');
      404 |     console.error('  - Stop the other process using port 9876');
    > 405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
          |             ^
      406 |     console.error('');
      407 |     process.exit(1);
      408 |   } else {

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:405:13)


  â—  Cannot log after tests are done. Did you forget to wait for something async in your test?
    Attempted to log "".

      404 |     console.error('  - Stop the other process using port 9876');
      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
    > 406 |     console.error('');
          |             ^
      407 |     process.exit(1);
      408 |   } else {
      409 |     logError('Server error:', err);

      at console.error (node_modules/@jest/console/build/BufferedConsole.js:127:10)
      at Server.error (server/websocket-server.js:406:13)

  â—  process.exit called with "1"

      405 |     console.error('  - Or kill existing server: pkill -f websocket-server');
      406 |     console.error('');
    > 407 |     process.exit(1);
          |             ^
      408 |   } else {
      409 |     logError('Server error:', err);
      410 |     process.exit(1);

      at Server.exit (server/websocket-server.js:407:13)
FAIL tests/crash-recovery.test.js
  â— Test suite failed to run

    Jest worker encountered 4 child process exceptions, exceeding retry limit

      at ChildProcessWorker.initialize (node_modules/jest-worker/build/workers/ChildProcessWorker.js:181:21)

PASS tests/unit/console-capture-class.test.js
PASS tests/security/websocket-server-security.test.js
FAIL tests/integration/level4-reload.test.js (5.117 s)
  â— Level 4 Reload - Integration Tests â€º Code Reload Verification â€º should reload code from disk using toggle method

    thrown: "Exceeded timeout of 5000 ms for a test.
    Add a timeout value to this test to increase the timeout, if this is a long-running test. See https://jestjs.io/docs/api#testname-fn-timeout."

      72 |     });
      73 |
    > 74 |     it('should reload code from disk using toggle method', async () => {
         |     ^
      75 |       // This test works with normal Chrome (no debug mode required)
      76 |
      77 |       // 1. Get current extension info

      at it (tests/integration/level4-reload.test.js:74:5)
      at describe (tests/integration/level4-reload.test.js:35:3)
      at Object.describe (tests/integration/level4-reload.test.js:16:1)

  â— Level 4 Reload - Integration Tests â€º Code Reload Verification â€º should auto-detect and use best available method

    TypeError: chromeDevAssist.level4Reload is not a function

      108 |       // Test auto-detection logic
      109 |
    > 110 |       const result = await chromeDevAssist.level4Reload(TEST_EXTENSION_ID);
          |                                            ^
      111 |
      112 |       // Should use either CDP or toggle depending on what's available
      113 |       expect(result.reloaded).toBe(true);

      at Object.level4Reload (tests/integration/level4-reload.test.js:110:44)

  â— Level 4 Reload - Integration Tests â€º Service Worker Restart Verification â€º should restart service worker completely

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Level 4 Reload - Integration Tests â€º Phase 0 Registration After Reload â€º should re-register with Phase 0 metadata after reload

    TypeError: chromeDevAssist.level4Reload is not a function

      150 |     it('should re-register with Phase 0 metadata after reload', async () => {
      151 |       // 1. Perform level4Reload
    > 152 |       await chromeDevAssist.level4Reload(TEST_EXTENSION_ID);
          |                             ^
      153 |
      154 |       // 2. Wait for reconnection and re-registration
      155 |       await new Promise(r => setTimeout(r, 3000));

      at Object.level4Reload (tests/integration/level4-reload.test.js:152:29)

  â— Level 4 Reload - Integration Tests â€º Error Recovery â€º should handle reload failure gracefully

    TypeError: chromeDevAssist.level4Reload is not a function

      173 |       // Test with invalid extension ID
      174 |       await expect(
    > 175 |         chromeDevAssist.level4Reload('invalid-extension-id')
          |                         ^
      176 |       ).rejects.toThrow();
      177 |     });
      178 |

      at Object.level4Reload (tests/integration/level4-reload.test.js:175:25)

  â— Level 4 Reload - Integration Tests â€º Performance â€º should complete reload in under 5 seconds

    TypeError: chromeDevAssist.level4Reload is not a function

      193 |       const startTime = Date.now();
      194 |
    > 195 |       await chromeDevAssist.level4Reload(TEST_EXTENSION_ID);
          |                             ^
      196 |
      197 |       const duration = Date.now() - startTime;
      198 |       expect(duration).toBeLessThan(5000);

      at Object.level4Reload (tests/integration/level4-reload.test.js:195:29)

FAIL tests/integration/console-capture-refactored.test.js (6.595 s)
  â— Console

    console.error
      âŒ Extension not loaded. Please load extension first.

      41 |       console.log(`âœ… Extension loaded: ${info.name} v${info.version}`);
      42 |     } catch (err) {
    > 43 |       console.error('âŒ Extension not loaded. Please load extension first.');
         |               ^
      44 |       throw new Error('Extension not loaded');
      45 |     }
      46 |   });

      at Object.error (tests/integration/console-capture-refactored.test.js:43:15)

  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º reloadAndCapture() uses ConsoleCapture class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º captureLogs() uses ConsoleCapture class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º openUrl() with captureConsole uses class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º reloadTab() with captureConsole uses class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Tab-Specific vs Global Captures â€º Tab-specific capture only captures from that tab

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Tab-Specific vs Global Captures â€º Global capture (tabId=null) captures from all tabs

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º 10K Log Limit Enforcement â€º 10K log limit enforced via class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º 10K Log Limit Enforcement â€º Warning added at limit via class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º 10K Log Limit Enforcement â€º Logs dropped after limit via class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Cleanup Functions â€º Periodic cleanup runs via consoleCapture.cleanupStale()

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Cleanup Functions â€º Error cleanup calls consoleCapture.cleanup()

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Cleanup Functions â€º getCommandLogs cleanup calls consoleCapture.cleanup()

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Multiple Captures â€º Multiple captures can coexist for same tab

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

FAIL tests/integration/reconnection-behavior.test.js (30.115 s)
  â— Console

    console.error
      Server error: npm error Missing script: "server"
      npm error
      npm error To see a list of scripts, run:
      npm error   npm run

      40 |
      41 |       serverProcess.stderr.on('data', (data) => {
    > 42 |         console.error('Server error:', data.toString());
         |                 ^
      43 |       });
      44 |
      45 |       setTimeout(() => {

      at Socket.error (tests/integration/reconnection-behavior.test.js:42:17)

    console.error
      Server error: npm error A complete log of this run can be found in: /Users/gadievron/.npm/_logs/2025-10-27T00_25_03_465Z-debug-0.log

      40 |
      41 |       serverProcess.stderr.on('data', (data) => {
    > 42 |         console.error('Server error:', data.toString());
         |                 ^
      43 |       });
      44 |
      45 |       setTimeout(() => {

      at Socket.error (tests/integration/reconnection-behavior.test.js:42:17)

    console.log
      1. Starting server...

      at Object.log (tests/integration/reconnection-behavior.test.js:208:15)

    console.error
      Server error: npm error Missing script: "server"
      npm error
      npm error To see a list of scripts, run:
      npm error   npm run

      40 |
      41 |       serverProcess.stderr.on('data', (data) => {
    > 42 |         console.error('Server error:', data.toString());
         |                 ^
      43 |       });
      44 |
      45 |       setTimeout(() => {

      at Socket.error (tests/integration/reconnection-behavior.test.js:42:17)

    console.error
      Server error: npm error A complete log of this run can be found in: /Users/gadievron/.npm/_logs/2025-10-27T00_25_14_513Z-debug-0.log

      40 |
      41 |       serverProcess.stderr.on('data', (data) => {
    > 42 |         console.error('Server error:', data.toString());
         |                 ^
      43 |       });
      44 |
      45 |       setTimeout(() => {

      at Socket.error (tests/integration/reconnection-behavior.test.js:42:17)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Server Restart Scenario â€º should detect when server is restarted

    Server failed to start within timeout

      45 |       setTimeout(() => {
      46 |         if (!started) {
    > 47 |           reject(new Error('Server failed to start within timeout'));
         |                  ^
      48 |         }
      49 |       }, 10000);
      50 |     });

      at Timeout._onTimeout (tests/integration/reconnection-behavior.test.js:47:18)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Server Restart Scenario â€º should reconnect extension after server restart

    Server failed to start within timeout

      45 |       setTimeout(() => {
      46 |         if (!started) {
    > 47 |           reject(new Error('Server failed to start within timeout'));
         |                  ^
      48 |         }
      49 |       }, 10000);
      50 |     });

      at Timeout._onTimeout (tests/integration/reconnection-behavior.test.js:47:18)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Reconnection Logic Verification â€º should verify ws.onclose is called when server stops

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      274 |
      275 |       // Verify scheduleReconnect is called
    > 276 |       expect(backgroundJs).toContain('scheduleReconnect');
          |                            ^
      277 |
      278 |       // Verify state is reset
      279 |       expect(backgroundJs).toContain('isRegistered = false');

      at Object.toContain (tests/integration/reconnection-behavior.test.js:276:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Reconnection Logic Verification â€º should verify scheduleReconnect uses exponential backoff

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      293 |         (backgroundJs.includes('Math.pow(2,') || backgroundJs.includes('2 **'));
      294 |
    > 295 |       expect(hasExponentialBackoff).toBe(true);
          |                                     ^
      296 |     });
      297 |
      298 |     it('should verify reconnection is scheduled after disconnect', () => {

      at Object.toBe (tests/integration/reconnection-behavior.test.js:295:37)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Reconnection Logic Verification â€º should verify reconnection is scheduled after disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "function scheduleReconnect()"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      303 |
      304 |       // Verify scheduleReconnect is defined
    > 305 |       expect(backgroundJs).toContain('function scheduleReconnect()');
          |                            ^
      306 |
      307 |       // Verify it's called in onclose
      308 |       const oncloseIndex = backgroundJs.indexOf('ws.onclose');

      at Object.toContain (tests/integration/reconnection-behavior.test.js:305:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Connection State Management â€º should verify isConnecting flag prevents multiple connections

    expect(received).toContain(expected) // indexOf

    Expected substring: "let isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      321 |
      322 |       // Verify isConnecting flag exists and is used
    > 323 |       expect(backgroundJs).toContain('let isConnecting = false');
          |                            ^
      324 |       expect(backgroundJs).toContain('if (isConnecting)');
      325 |       expect(backgroundJs).toContain('isConnecting = true');
      326 |       expect(backgroundJs).toContain('isConnecting = false');

      at Object.toContain (tests/integration/reconnection-behavior.test.js:323:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Connection State Management â€º should verify connection state is properly reset on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      334 |
      335 |       // In onclose, verify state is reset
    > 336 |       expect(backgroundJs).toContain('isConnecting = false');
          |                            ^
      337 |       expect(backgroundJs).toContain('ws = null');
      338 |     });
      339 |   });

      at Object.toContain (tests/integration/reconnection-behavior.test.js:336:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Exponential Backoff Implementation â€º should verify reconnection attempts are tracked

    expect(received).toContain(expected) // indexOf

    Expected substring: "reconnectAttempts"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      346 |       );
      347 |
    > 348 |       expect(backgroundJs).toContain('reconnectAttempts');
          |                            ^
      349 |     });
      350 |
      351 |     it('should verify backoff has maximum limit', () => {

      at Object.toContain (tests/integration/reconnection-behavior.test.js:348:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Exponential Backoff Implementation â€º should verify backoff has maximum limit

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      360 |         backgroundJs.includes('maxReconnectDelay');
      361 |
    > 362 |       expect(hasMaxBackoff).toBe(true);
          |                             ^
      363 |     });
      364 |
      365 |     it('should verify reconnection attempts are reset on successful connection', () => {

      at Object.toBe (tests/integration/reconnection-behavior.test.js:362:29)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Exponential Backoff Implementation â€º should verify reconnection attempts are reset on successful connection

    expect(received).toBeGreaterThan(expected)

    Expected: > 3620
    Received:   -1

      373 |       const resetIndex = backgroundJs.indexOf('reconnectAttempts = 0', onopenIndex);
      374 |
    > 375 |       expect(resetIndex).toBeGreaterThan(onopenIndex);
          |                          ^
      376 |     });
      377 |   });
      378 | });

      at Object.toBeGreaterThan (tests/integration/reconnection-behavior.test.js:375:26)

A worker process has failed to exit gracefully and has been force exited. This is likely caused by tests leaking due to improper teardown. Try running with --detectOpenHandles to find leaks. Active timers can also cause this, ensure that .unref() was called on them.
Summary of all failing tests
FAIL tests/unit/websocket-connection-stability.test.js
  â— Test suite failed to run

    Jest encountered an unexpected token

    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.

    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.

    By default "node_modules" folder is ignored by transformers.

    Here's what you can do:
     â€¢ If you are trying to use ECMAScript Modules, see https://jestjs.io/docs/ecmascript-modules for how to enable it.
     â€¢ If you are trying to use TypeScript, see https://jestjs.io/docs/getting-started#using-typescript
     â€¢ To have some of your "node_modules" files transformed, you can specify a custom "transformIgnorePatterns" in your config.
     â€¢ If you need a custom transformation specify a "transform" option in your config.
     â€¢ If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the "moduleNameMapper" config option.

    You'll find more details and examples of these config options in the docs:
    https://jestjs.io/docs/configuration
    For information about custom transformations, see:
    https://jestjs.io/docs/code-transformation

    Details:

    /Users/gadievron/Documents/Claude Code/chrome-dev-assist/tests/unit/websocket-connection-stability.test.js:24
      jest
      ^

    SyntaxError: Identifier 'jest' has already been declared

      at Runtime.createScriptFromCode (node_modules/jest-runtime/build/index.js:1505:14)

FAIL tests/integration/console-error-crash-detection.test.js
  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for WebSocket connection failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', exte"

      31 |       );
      32 |
    > 33 |       expect(onerrorHandler).toContain('console.warn');
         |                              ^
      34 |       expect(onerrorHandler).not.toMatch(/console\.error.*WebSocket.*connection/i);
      35 |     });
      36 |

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:33:30)

  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for connection timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      41 |       );
      42 |
    > 43 |       expect(timeoutHandler).toContain('console.warn');
         |                              ^
      44 |       expect(timeoutHandler).not.toMatch(/console\.error.*timeout/i);
      45 |     });
      46 |

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:43:30)

  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for registration timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      51 |       );
      52 |
    > 53 |       expect(regTimeoutHandler).toContain('console.warn');
         |                                 ^
      54 |       expect(regTimeoutHandler).not.toMatch(/console\.error.*[Rr]egistration/);
      55 |     });
      56 |

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:53:33)

  â— Console.error Crash Detection Prevention â€º Fixed Issues (Should use console.warn) â€º should use console.warn for command failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclos"

      61 |       );
      62 |
    > 63 |       expect(catchHandler).toContain('console.warn');
         |                            ^
      64 |       expect(catchHandler).toContain('Command failed');
      65 |       expect(catchHandler).not.toMatch(/console\.error.*Command failed/);
      66 |     });

      at Object.toContain (tests/integration/console-error-crash-detection.test.js:63:28)

  â— Console.error Crash Detection Prevention â€º Remaining console.error Usage Analysis â€º should NOT use console.error for expected tab closure failures

    âŒ Found console.error in tab cleanup at line ~485. Tab closure failures are EXPECTED in testing (tabs may be already closed). Should use console.warn instead. See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:206-214

       97 |         if (section.includes('console.error')) {
       98 |           const lineNumber = backgroundJs.substring(0, idx).split('\n').length;
    >  99 |           throw new Error(`âŒ Found console.error in tab cleanup at line ~${lineNumber}. ` +
          |                 ^
      100 |                           `Tab closure failures are EXPECTED in testing (tabs may be already closed). ` +
      101 |                           `Should use console.warn instead. ` +
      102 |                           `See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:206-214`);

      at Object.<anonymous> (tests/integration/console-error-crash-detection.test.js:99:17)

  â— Console.error Crash Detection Prevention â€º Pattern Detection (Generic Bug Prevention) â€º should have "âœ… FIX" comment for all fixed console.warn conversions

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 4
    Received:    0

      147 |
      148 |       // We have 4 known fixes
    > 149 |       expect(fixComments.length).toBeGreaterThanOrEqual(4);
          |                                  ^
      150 |     });
      151 |
      152 |     it('should document why console.error is kept for programming bugs', () => {

      at Object.toBeGreaterThanOrEqual (tests/integration/console-error-crash-detection.test.js:149:34)

  â— Console.error Crash Detection Prevention â€º Crash Detection Trigger Patterns â€º should NOT have multiple console.error in rapid succession

    âŒ Found 2 rapid console.error sequence(s). Chrome may interpret this as extension crash. Example locations:
      1. Line ~485: console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');         console.error('[ChromeDevAssist...
      2. Line ~488: console.error('[ChromeDevAssist] Error message:', err.message);         console.error('[ChromeDevAss...
    Recommendation: Consolidate into single console.warn with object. See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:459-483

      206 |         }).join('\n');
      207 |
    > 208 |         throw new Error(`âŒ Found ${rapidErrors.length} rapid console.error sequence(s). ` +
          |               ^
      209 |                         `Chrome may interpret this as extension crash. ` +
      210 |                         `Example locations:\n${errorDetails}\n` +
      211 |                         `Recommendation: Consolidate into single console.warn with object. ` +

      at Object.<anonymous> (tests/integration/console-error-crash-detection.test.js:208:15)

  â— Console.error Crash Detection Prevention â€º Crash Detection Trigger Patterns â€º should consolidate error details into single log (not split across multiple console.error)

    âŒ Found 1 location(s) with multiple console.error for single error. Should consolidate into single console.warn with object:
      console.warn('Message', { tabId, errorType, errorMessage, ... });

    Violations:
      1. Line ~469: 4 console.error calls in 20 lines
                   const removeResult = chrome.tabs.remove(tab.id);
                   console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult...

    See TESTER-GUIDE-CONSOLE-ERROR-CRASH-BUG.md:459-483

      254 |         }).join('\n');
      255 |
    > 256 |         throw new Error(`âŒ Found ${violations.length} location(s) with multiple console.error for single error. ` +
          |               ^
      257 |                         `Should consolidate into single console.warn with object:\n` +
      258 |                         `  console.warn('Message', { tabId, errorType, errorMessage, ... });\n\n` +
      259 |                         `Violations:\n${violationDetails}\n\n` +

      at Object.<anonymous> (tests/integration/console-error-crash-detection.test.js:256:15)

  â— Console.error Crash Detection Prevention â€º Regression Prevention â€º should prevent re-introducing console.error for command failures

    expect(received).toBeNull()

    Received: ["console.error('[ChromeDevAssist] Command failed"]

      366 |           // Should NOT have console.error for Command failed
      367 |           if (hasError) {
    > 368 |             expect(hasError).toBeNull();
          |                              ^
      369 |             throw new Error(`Found console.error for command failure (should be console.warn): ${hasError[0].substring(0, 100)}`);
      370 |           }
      371 |         }

      at Object.toBeNull (tests/integration/console-error-crash-detection.test.js:368:30)

FAIL tests/security/websocket-client-security.test.js
  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should have registration timeout mechanism

    expect(received).toContain(expected) // indexOf

    Expected substring: "registrationTimeout"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      35 |     it('should have registration timeout mechanism', () => {
      36 |       // Verify timeout exists (5 seconds)
    > 37 |       expect(backgroundJs).toContain('registrationTimeout');
         |                            ^
      38 |       expect(backgroundJs).toContain('5000'); // 5 second timeout
      39 |
      40 |       // Verify timeout handler exists

      at Object.toContain (tests/security/websocket-client-security.test.js:37:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should clear registration timeout on valid ACK

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      47 |       const clearTimeoutIndex = backgroundJs.indexOf('clearTimeout(registrationTimeout)', ackHandlerIndex);
      48 |
    > 49 |       expect(clearTimeoutIndex).toBeGreaterThan(ackHandlerIndex);
         |                                 ^
      50 |     });
      51 |
      52 |     it('should set registration flags on ACK', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:49:33)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should set registration flags on ACK

    expect(received).toContain(expected) // indexOf

    Expected substring: "isRegistered = true"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      52 |     it('should set registration flags on ACK', () => {
      53 |       // Verify state changes on ACK
    > 54 |       expect(backgroundJs).toContain('isRegistered = true');
         |                            ^
      55 |       expect(backgroundJs).toContain('registrationPending = false');
      56 |     });
      57 |

      at Object.toContain (tests/security/websocket-client-security.test.js:54:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Registration ACK Spoofing â€º should timeout if ACK not received within 5 seconds

    expect(received).toBeTruthy()

    Received: null

      108 |       // Verify timeout mechanism exists
      109 |       const timeoutCode = backgroundJs.match(/setTimeout\([^)]+,\s*5000\)/);
    > 110 |       expect(timeoutCode).toBeTruthy();
          |                           ^
      111 |
      112 |       // Verify reconnection triggered on timeout
      113 |       expect(backgroundJs).toContain('Registration timeout, reconnecting');

      at Object.toBeTruthy (tests/security/websocket-client-security.test.js:110:27)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should enforce MAX_QUEUE_SIZE limit

    expect(received).toContain(expected) // indexOf

    Expected substring: "const MAX_QUEUE_SIZE = 100"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      122 |     it('should enforce MAX_QUEUE_SIZE limit', () => {
      123 |       // Verify MAX_QUEUE_SIZE constant exists
    > 124 |       expect(backgroundJs).toContain('const MAX_QUEUE_SIZE = 100');
          |                            ^
      125 |
      126 |       // Verify bounds check exists
      127 |       expect(backgroundJs).toContain('if (messageQueue.length >= MAX_QUEUE_SIZE)');

      at Object.toContain (tests/security/websocket-client-security.test.js:124:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should drop messages when queue is full

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      134 |       const returnIndex = backgroundJs.indexOf('return false', queueCheckIndex);
      135 |
    > 136 |       expect(returnIndex).toBeGreaterThan(queueCheckIndex);
          |                           ^
      137 |       expect(returnIndex - queueCheckIndex).toBeLessThan(200); // Within ~200 chars
      138 |     });
      139 |

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:136:27)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should clear queue on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "messageQueue.length = 0"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      160 |     it('should clear queue on disconnect', () => {
      161 |       // Verify queue is cleared (security: prevent stale message replay)
    > 162 |       expect(backgroundJs).toContain('messageQueue.length = 0');
          |                            ^
      163 |       expect(backgroundJs).toContain('Clearing');
      164 |     });
      165 |

      at Object.toContain (tests/security/websocket-client-security.test.js:162:28)

  â— Security: WebSocket Client (Extension) â€º P0 CRITICAL: Queue Overflow Attack â€º should handle queue drain errors gracefully

    expect(received).toContain(expected) // indexOf

    Expected substring: "Failed to send queued message"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      166 |     it('should handle queue drain errors gracefully', () => {
      167 |       // Verify error handling during drain
    > 168 |       expect(backgroundJs).toContain('Failed to send queued message');
          |                            ^
      169 |
      170 |       // Verify message put back on error
      171 |       expect(backgroundJs).toContain('messageQueue.unshift(queued)');

      at Object.toContain (tests/security/websocket-client-security.test.js:168:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up timer on withTimeout success

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      182 |       const successCleanup = backgroundJs.indexOf('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success', withTimeoutIndex);
      183 |
    > 184 |       expect(successCleanup).toBeGreaterThan(withTimeoutIndex);
          |                              ^
      185 |     });
      186 |
      187 |     it('should clean up timer on withTimeout error', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:184:30)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up timer on withTimeout error

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      189 |       const errorCleanup = backgroundJs.indexOf('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error', withTimeoutIndex);
      190 |
    > 191 |       expect(errorCleanup).toBeGreaterThan(withTimeoutIndex);
          |                            ^
      192 |     });
      193 |
      194 |     it('should clean up registration timeout on success', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:191:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up registration timeout on success

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      197 |       const clearIndex = backgroundJs.indexOf('clearTimeout(registrationTimeout)', ackIndex);
      198 |
    > 199 |       expect(clearIndex).toBeGreaterThan(ackIndex);
          |                          ^
      200 |     });
      201 |
      202 |     it('should clean up registration timeout on disconnect', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:199:26)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Timer Leak Attack â€º should clean up registration timeout on disconnect

    expect(received).toBeGreaterThan(expected)

    Expected: > 6120
    Received:   -1

      205 |       const clearIndex = backgroundJs.indexOf('clearTimeout(registrationTimeout)', oncloseIndex);
      206 |
    > 207 |       expect(clearIndex).toBeGreaterThan(oncloseIndex);
          |                          ^
      208 |     });
      209 |
      210 |     it.skip('should verify no timer leaks with stress test (NOT IMPLEMENTED)', () => {

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:207:26)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Race Condition - Duplicate Connections â€º should have isConnecting flag to prevent duplicates

    expect(received).toContain(expected) // indexOf

    Expected substring: "let isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      231 |     it('should have isConnecting flag to prevent duplicates', () => {
      232 |       // Verify flag exists
    > 233 |       expect(backgroundJs).toContain('let isConnecting = false');
          |                            ^
      234 |
      235 |       // Verify check exists
      236 |       expect(backgroundJs).toContain('if (isConnecting)');

      at Object.toContain (tests/security/websocket-client-security.test.js:233:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Race Condition - Duplicate Connections â€º should set isConnecting before creating WebSocket

    expect(received).toContain(expected) // indexOf

    Expected substring: "isConnecting = true"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      240 |     it('should set isConnecting before creating WebSocket', () => {
      241 |       // Verify flag set before connection
    > 242 |       expect(backgroundJs).toContain('isConnecting = true');
          |                            ^
      243 |
      244 |       // Verify flag cleared on error
      245 |       expect(backgroundJs).toContain('isConnecting = false');

      at Object.toContain (tests/security/websocket-client-security.test.js:242:28)

  â— Security: WebSocket Client (Extension) â€º P1 HIGH: Message Injection via Queue â€º should validate message structure before queueing

    expect(received).toBeGreaterThan(expected)

    Expected: > -1
    Received:   -1

      272 |       const queuePushIndex = backgroundJs.indexOf('messageQueue.push(message)', safeSendIndex);
      273 |
    > 274 |       expect(queuePushIndex).toBeGreaterThan(safeSendIndex);
          |                              ^
      275 |
      276 |       // âš ï¸  WARNING: No validation between safeSend and push
      277 |       // Gap = queuePushIndex - safeSendIndex

      at Object.toBeGreaterThan (tests/security/websocket-client-security.test.js:274:30)

FAIL tests/integration/adversarial-tests.test.js
  â— Test suite failed to run

    ENOENT: no such file or directory, open '/Users/gadievron/Documents/Claude Code/chrome-dev-assist/.auth-token'

      22 |
      23 | // Read auth token
    > 24 | const AUTH_TOKEN = fs.readFileSync(path.join(__dirname, '../../.auth-token'), 'utf8').trim();
         |                       ^
      25 |
      26 | // ========================================
      27 | // PRE-TEST CHECKLIST (TESTING_QUICK_REFERENCE.md)

      at Object.readFileSync (tests/integration/adversarial-tests.test.js:24:23)

FAIL tests/integration/edge-cases-stress.test.js
  â— Test suite failed to run

    ENOENT: no such file or directory, open '/Users/gadievron/Documents/Claude Code/chrome-dev-assist/.auth-token'

      14 |
      15 | // Read auth token
    > 16 | const AUTH_TOKEN = fs.readFileSync(path.join(__dirname, '../../.auth-token'), 'utf8').trim();
         |                       ^
      17 |
      18 | describe('Edge Cases and Stress Tests', () => {
      19 |   let testTabs = [];

      at Object.readFileSync (tests/integration/edge-cases-stress.test.js:16:23)

FAIL tests/integration/dogfooding.test.js
  â— Dogfooding - Extension Testing Itself â€º Basic Test Fixture â€º opens basic test page and detects test identification

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Console Errors Test Fixture â€º captures expected errors from test page

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Mixed Console Output Test Fixture â€º captures mixed console output (logs, warnings, errors)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Complete Test Workflow â€º opens â†’ reloads â†’ captures â†’ closes test page

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Dogfooding - Extension Testing Itself â€º Concurrent Fixture Testing â€º opens multiple test fixtures simultaneously

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/multi-feature-integration.test.js
  â— Multi-Feature Integration Tests â€º Integration Test 1: Console + Screenshot + Metadata â€º should open page, capture logs, take screenshot, and extract metadata

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Multi-Feature Integration Tests â€º Integration Test 2: Console Level Verification â€º should capture all console levels (log, info, warn, error)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Multi-Feature Integration Tests â€º Integration Test 3: Tab Lifecycle with Capture â€º should open, reload, capture, and close tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Multi-Feature Integration Tests â€º Integration Test 4: Test Orchestration â€º should use test orchestration with auto-cleanup

    TypeError: chromeDevAssist.startTest is not a function

      238 |       // 1. Start test
      239 |       console.log(`ï¿½ï¿½ Starting test: ${testId}`);
    > 240 |       const startResult = await chromeDevAssist.startTest(testId, { autoCleanup: true });
          |                                                 ^
      241 |
      242 |       expect(startResult.testId).toBe(testId);
      243 |       console.log(`âœ… Test started: ${startResult.testId}`);

      at Object.startTest (tests/integration/multi-feature-integration.test.js:240:49)

FAIL tests/integration/edge-cases-complete.test.js
  â— Edge Cases - Complete Coverage â€º Extension Not Found Scenarios â€º should error when extension ID does not exist

    expect(received).rejects.toThrow(expected)

    Expected pattern: /not found/
    Received message: "Invalid extensionId format (must be 32 lowercase letters a-p)"

          326 |   // Chrome extension IDs are lowercase letters a-p
          327 |   if (!/^[a-p]{32}$/.test(extensionId)) {
        > 328 |     throw new Error('Invalid extensionId format (must be 32 lowercase letters a-p)');
              |           ^
          329 |   }
          330 | }
          331 |

      at validateExtensionId (claude-code/index.js:328:11)
      at Object.validateExtensionId [as getExtensionInfo] (claude-code/index.js:100:3)
      at Object.getExtensionInfo (tests/integration/edge-cases-complete.test.js:29:25)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/edge-cases-complete.test.js:30:17)

  â— Edge Cases - Complete Coverage â€º Extension Not Found Scenarios â€º should error when reloading non-existent extension

    expect(received).rejects.toThrow(expected)

    Expected pattern: /not found/
    Received message: "Invalid extensionId format (must be 32 lowercase letters a-p)"

          326 |   // Chrome extension IDs are lowercase letters a-p
          327 |   if (!/^[a-p]{32}$/.test(extensionId)) {
        > 328 |     throw new Error('Invalid extensionId format (must be 32 lowercase letters a-p)');
              |           ^
          329 |   }
          330 | }
          331 |

      at validateExtensionId (claude-code/index.js:328:11)
      at Object.validateExtensionId [as reload] (claude-code/index.js:45:3)
      at Object.reload (tests/integration/edge-cases-complete.test.js:37:25)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/edge-cases-complete.test.js:38:17)

  â— Edge Cases - Complete Coverage â€º Extension Not Found Scenarios â€º should error when enabling non-existent extension

    TypeError: chromeDevAssist.enableExtension is not a function

      43 |
      44 |       await expect(
    > 45 |         chromeDevAssist.enableExtension(fakeId)
         |                         ^
      46 |       ).rejects.toThrow();
      47 |     });
      48 |   });

      at Object.enableExtension (tests/integration/edge-cases-complete.test.js:45:25)

  â— Edge Cases - Complete Coverage â€º Tab Not Found Scenarios â€º should error when getting metadata from non-existent tab

    TypeError: chromeDevAssist.getPageMetadata is not a function

      70 |
      71 |       await expect(
    > 72 |         chromeDevAssist.getPageMetadata(fakeTabId)
         |                         ^
      73 |       ).rejects.toThrow();
      74 |     });
      75 |   });

      at Object.getPageMetadata (tests/integration/edge-cases-complete.test.js:72:25)

  â— Edge Cases - Complete Coverage â€º Tab Already Closed Scenario â€º should handle attempting to close already-closed tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Console Timing Functions â€º should capture console.time and console.timeEnd

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject nested/overlapping tests

    TypeError: chromeDevAssist.startTest is not a function

      136 |
      137 |       // Start first test
    > 138 |       await chromeDevAssist.startTest(testId);
          |                             ^
      139 |
      140 |       // Try to start another - should fail
      141 |       await expect(

      at Object.startTest (tests/integration/edge-cases-complete.test.js:138:29)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should work with autoCleanup disabled

    TypeError: chromeDevAssist.startTest is not a function

      152 |
      153 |       // Start test with cleanup disabled
    > 154 |       await chromeDevAssist.startTest(testId, {
          |                             ^
      155 |         autoCleanup: false
      156 |       });
      157 |

      at Object.startTest (tests/integration/edge-cases-complete.test.js:154:29)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject ending test that is not active

    TypeError: chromeDevAssist.endTest is not a function

      180 |     test('should reject ending test that is not active', async () => {
      181 |       await expect(
    > 182 |         chromeDevAssist.endTest('non-existent-test-id')
          |                         ^
      183 |       ).rejects.toThrow(/No active test/);
      184 |     });
      185 |

      at Object.endTest (tests/integration/edge-cases-complete.test.js:182:25)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject aborting test that is not active

    TypeError: chromeDevAssist.abortTest is not a function

      186 |     test('should reject aborting test that is not active', async () => {
      187 |       await expect(
    > 188 |         chromeDevAssist.abortTest('non-existent-test-id')
          |                         ^
      189 |       ).rejects.toThrow(/No active test/);
      190 |     });
      191 |

      at Object.abortTest (tests/integration/edge-cases-complete.test.js:188:25)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject ending test with wrong ID

    TypeError: chromeDevAssist.startTest is not a function

      193 |       testId = 'test-wrong-id-' + Date.now();
      194 |
    > 195 |       await chromeDevAssist.startTest(testId);
          |                             ^
      196 |
      197 |       // Try to end with different ID
      198 |       await expect(

      at Object.startTest (tests/integration/edge-cases-complete.test.js:195:29)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should validate test ID format

    TypeError: chromeDevAssist.startTest is not a function

      207 |       // Test IDs with invalid characters should be rejected
      208 |       await expect(
    > 209 |         chromeDevAssist.startTest('test with spaces')
          |                         ^
      210 |       ).rejects.toThrow(/invalid characters/);
      211 |
      212 |       await expect(

      at Object.startTest (tests/integration/edge-cases-complete.test.js:209:25)

  â— Edge Cases - Complete Coverage â€º Test Orchestration Edge Cases â€º should reject very long test ID

    TypeError: chromeDevAssist.startTest is not a function

      223 |
      224 |       await expect(
    > 225 |         chromeDevAssist.startTest(longId)
          |                         ^
      226 |       ).rejects.toThrow(/too long/);
      227 |     });
      228 |   });

      at Object.startTest (tests/integration/edge-cases-complete.test.js:225:25)

  â— Edge Cases - Complete Coverage â€º Extension Reload - Cannot Reload Self â€º should prevent reloading Chrome Dev Assist itself

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Console Capture Duration Edge Cases â€º should handle very short capture duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Hard Reload (Cache Bypass) â€º should perform hard reload with cache bypass

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Cleanup Verification Edge Cases â€º should detect all orphaned tabs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Cleanup Verification Edge Cases â€º should verify cleanup when all tabs actually closed

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Permission Checks â€º should include mayDisable in extension info

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Complete Coverage â€º Permission Checks â€º should verify all expected permissions exist

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/meta/test-reality-check.test.js
  â— Test Reality Check - Verify Tests Test Production Code â€º Critical Production Functions â€º should verify withTimeout is tested against production code

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      26 |
      27 |       // Verify production code has withTimeout
    > 28 |       expect(backgroundJs).toContain('async function withTimeout(');
         |                            ^
      29 |
      30 |       // Verify test file has verification tests
      31 |       expect(testFile).toContain('should verify withTimeout exists in background.js');

      at Object.toContain (tests/meta/test-reality-check.test.js:28:28)

  â— Test Reality Check - Verify Tests Test Production Code â€º Critical Production Functions â€º should verify safeSend is tested against production code

    expect(received).toContain(expected) // indexOf

    Expected substring: "function safeSend("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      39 |
      40 |       // Verify safeSend exists in production
    > 41 |       expect(backgroundJs).toContain('function safeSend(');
         |                            ^
      42 |       expect(backgroundJs).toContain('messageQueue'); // Part of Improvement 7
      43 |     });
      44 |

      at Object.toContain (tests/meta/test-reality-check.test.js:41:28)

  â— Test Reality Check - Verify Tests Test Production Code â€º Critical Production Functions â€º should verify registration ACK is tested against production code

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (message.type === 'registration-ack')"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      55 |
      56 |       // Verify registration ACK in extension
    > 57 |       expect(backgroundJs).toContain("if (message.type === 'registration-ack')");
         |                            ^
      58 |
      59 |       // Verify registration ACK in server
      60 |       expect(serverJs).toContain("type: 'registration-ack'");

      at Object.toContain (tests/meta/test-reality-check.test.js:57:28)

  â— Test Reality Check - Verify Tests Test Production Code â€º Verification Test Pattern â€º should verify critical implementations exist in production files

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      166 |
      167 |       // Improvement 8: Timeout wrapper
    > 168 |       expect(backgroundJs).toContain('async function withTimeout(');
          |                            ^
      169 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle)');
      170 |
      171 |       // Improvement 7: Message queuing

      at Object.toContain (tests/meta/test-reality-check.test.js:168:28)

FAIL tests/meta/test-quality.test.js
  â— Testing Expert: Fake Test Detection â€º all test files should import real implementations

    Fake tests detected:
      - tests/crash-recovery.test.js: Only uses mocks, never imports real implementation
      - tests/unit/clean-shutdown-detection.test.js: Defines functions but does not import real implementation
      - tests/unit/clean-shutdown-detection.test.js: Only uses mocks, never imports real implementation
      - tests/unit/smarter-completion-detection.test.js: Only uses mocks, never imports real implementation
      - tests/unit/tab-operations-timeout.test.js: Only uses mocks, never imports real implementation

      57 |       const message = 'Fake tests detected:\n' +
      58 |         fakeTests.map(t => `  - ${t.file}: ${t.reason}`).join('\n');
    > 59 |       throw new Error(message);
         |             ^
      60 |     }
      61 |
      62 |     expect(fakeTests).toEqual([]);

      at Object.<anonymous> (tests/meta/test-quality.test.js:59:13)

  â— Testing Expert: Test Organization â€º test files should be in appropriate directories

    expect(received).toEqual(expected) // deep equality

    - Expected  - 1
    + Received  + 6

    - Array []
    + Array [
    +   Object {
    +     "file": "tests/integration/screenshot-security.test.js",
    +     "shouldBe": "tests/security/",
    +   },
    + ]

      282 |     }
      283 |
    > 284 |     expect(misplaced).toEqual([]);
          |                       ^
      285 |   });
      286 |
      287 |   test('all personas should have test coverage', () => {

      at Object.toEqual (tests/meta/test-quality.test.js:284:23)

FAIL tests/unit/test-orchestration.test.js
  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject missing testId

    TypeError: chromeDevAssist.startTest is not a function

      20 |
      21 |       test('should reject missing testId', async () => {
    > 22 |         await expect(chromeDevAssist.startTest(null))
         |                                      ^
      23 |           .rejects.toThrow('testId is required');
      24 |       });
      25 |

      at Object.startTest (tests/unit/test-orchestration.test.js:22:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject non-string testId

    TypeError: chromeDevAssist.startTest is not a function

      25 |
      26 |       test('should reject non-string testId', async () => {
    > 27 |         await expect(chromeDevAssist.startTest(123))
         |                                      ^
      28 |           .rejects.toThrow('testId is required and must be a string');
      29 |       });
      30 |

      at Object.startTest (tests/unit/test-orchestration.test.js:27:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject testId that is too long

    TypeError: chromeDevAssist.startTest is not a function

      31 |       test('should reject testId that is too long', async () => {
      32 |         const longId = 'a'.repeat(101);
    > 33 |         await expect(chromeDevAssist.startTest(longId))
         |                                      ^
      34 |           .rejects.toThrow('testId too long');
      35 |       });
      36 |

      at Object.startTest (tests/unit/test-orchestration.test.js:33:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should reject testId with invalid characters

    TypeError: chromeDevAssist.startTest is not a function

      36 |
      37 |       test('should reject testId with invalid characters', async () => {
    > 38 |         await expect(chromeDevAssist.startTest('test;DROP TABLE'))
         |                                      ^
      39 |           .rejects.toThrow('testId contains invalid characters');
      40 |       });
      41 |

      at Object.startTest (tests/unit/test-orchestration.test.js:38:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should accept valid testId

    TypeError: chromeDevAssist.startTest is not a function

      42 |       test('should accept valid testId', async () => {
      43 |         // This will fail with WebSocket connection error, but validates parameter handling
    > 44 |         const promise = chromeDevAssist.startTest('test-001');
         |                                         ^
      45 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      46 |       });
      47 |

      at Object.startTest (tests/unit/test-orchestration.test.js:44:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should accept valid testId with underscores

    TypeError: chromeDevAssist.startTest is not a function

      47 |
      48 |       test('should accept valid testId with underscores', async () => {
    > 49 |         const promise = chromeDevAssist.startTest('test_001');
         |                                         ^
      50 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      51 |       });
      52 |

      at Object.startTest (tests/unit/test-orchestration.test.js:49:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º startTest() â€º should accept valid testId with options

    TypeError: chromeDevAssist.startTest is not a function

      52 |
      53 |       test('should accept valid testId with options', async () => {
    > 54 |         const promise = chromeDevAssist.startTest('test-001', { autoCleanup: false });
         |                                         ^
      55 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      56 |       });
      57 |     });

      at Object.startTest (tests/unit/test-orchestration.test.js:54:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should reject missing testId

    TypeError: chromeDevAssist.endTest is not a function

      60 |
      61 |       test('should reject missing testId', async () => {
    > 62 |         await expect(chromeDevAssist.endTest(null)).rejects.toThrow('testId is required');
         |                                      ^
      63 |       });
      64 |
      65 |       test('should reject non-string testId', async () => {

      at Object.endTest (tests/unit/test-orchestration.test.js:62:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should reject non-string testId

    TypeError: chromeDevAssist.endTest is not a function

      64 |
      65 |       test('should reject non-string testId', async () => {
    > 66 |         await expect(chromeDevAssist.endTest(123)).rejects.toThrow('testId is required and must be a string');
         |                                      ^
      67 |       });
      68 |
      69 |       test('should reject invalid result value', async () => {

      at Object.endTest (tests/unit/test-orchestration.test.js:66:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should reject invalid result value

    TypeError: chromeDevAssist.endTest is not a function

      68 |
      69 |       test('should reject invalid result value', async () => {
    > 70 |         await expect(chromeDevAssist.endTest('test-001', 'invalid'))
         |                                      ^
      71 |           .rejects.toThrow('result must be one of: passed, failed, aborted');
      72 |       });
      73 |

      at Object.endTest (tests/unit/test-orchestration.test.js:70:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should accept valid result: passed

    TypeError: chromeDevAssist.endTest is not a function

      73 |
      74 |       test('should accept valid result: passed', async () => {
    > 75 |         const promise = chromeDevAssist.endTest('test-001', 'passed');
         |                                         ^
      76 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      77 |       });
      78 |

      at Object.endTest (tests/unit/test-orchestration.test.js:75:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should accept valid result: failed

    TypeError: chromeDevAssist.endTest is not a function

      78 |
      79 |       test('should accept valid result: failed', async () => {
    > 80 |         const promise = chromeDevAssist.endTest('test-001', 'failed');
         |                                         ^
      81 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      82 |       });
      83 |

      at Object.endTest (tests/unit/test-orchestration.test.js:80:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should accept valid result: aborted

    TypeError: chromeDevAssist.endTest is not a function

      83 |
      84 |       test('should accept valid result: aborted', async () => {
    > 85 |         const promise = chromeDevAssist.endTest('test-001', 'aborted');
         |                                         ^
      86 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      87 |       });
      88 |

      at Object.endTest (tests/unit/test-orchestration.test.js:85:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º endTest() â€º should default to result=passed if not specified

    TypeError: chromeDevAssist.endTest is not a function

      88 |
      89 |       test('should default to result=passed if not specified', async () => {
    > 90 |         const promise = chromeDevAssist.endTest('test-001');
         |                                         ^
      91 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      92 |       });
      93 |     });

      at Object.endTest (tests/unit/test-orchestration.test.js:90:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º getTestStatus() â€º should not require parameters

    TypeError: chromeDevAssist.getTestStatus is not a function

       96 |
       97 |       test('should not require parameters', async () => {
    >  98 |         const promise = chromeDevAssist.getTestStatus();
          |                                         ^
       99 |
      100 |         await expect(promise).rejects.toThrow(); // WebSocket error expected (but params valid)
      101 |       });

      at Object.getTestStatus (tests/unit/test-orchestration.test.js:98:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should reject missing testId

    TypeError: chromeDevAssist.abortTest is not a function

      105 |
      106 |       test('should reject missing testId', async () => {
    > 107 |         await expect(chromeDevAssist.abortTest(null)).rejects.toThrow('testId is required');
          |                                      ^
      108 |       });
      109 |
      110 |       test('should reject non-string testId', async () => {

      at Object.abortTest (tests/unit/test-orchestration.test.js:107:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should reject non-string testId

    TypeError: chromeDevAssist.abortTest is not a function

      109 |
      110 |       test('should reject non-string testId', async () => {
    > 111 |         await expect(chromeDevAssist.abortTest(123)).rejects.toThrow('testId is required and must be a string');
          |                                      ^
      112 |       });
      113 |
      114 |       test('should accept valid testId with reason', async () => {

      at Object.abortTest (tests/unit/test-orchestration.test.js:111:38)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should accept valid testId with reason

    TypeError: chromeDevAssist.abortTest is not a function

      113 |
      114 |       test('should accept valid testId with reason', async () => {
    > 115 |         const promise = chromeDevAssist.abortTest('test-001', 'Test timeout');
          |                                         ^
      116 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      117 |       });
      118 |

      at Object.abortTest (tests/unit/test-orchestration.test.js:115:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º abortTest() â€º should accept valid testId without reason (uses default)

    TypeError: chromeDevAssist.abortTest is not a function

      118 |
      119 |       test('should accept valid testId without reason (uses default)', async () => {
    > 120 |         const promise = chromeDevAssist.abortTest('test-001');
          |                                         ^
      121 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      122 |       });
      123 |     });

      at Object.abortTest (tests/unit/test-orchestration.test.js:120:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º verifyCleanup() â€º should accept empty expectedClosedTabs (defaults to [])

    TypeError: chromeDevAssist.verifyCleanup is not a function

      126 |
      127 |       test('should accept empty expectedClosedTabs (defaults to [])', async () => {
    > 128 |         const promise = chromeDevAssist.verifyCleanup();
          |                                         ^
      129 |
      130 |         await expect(promise).rejects.toThrow(); // WebSocket error expected
      131 |       });

      at Object.verifyCleanup (tests/unit/test-orchestration.test.js:128:41)

  â— Test Orchestration Protocol â€º API Function Validation â€º verifyCleanup() â€º should accept array of tab IDs

    TypeError: chromeDevAssist.verifyCleanup is not a function

      132 |
      133 |       test('should accept array of tab IDs', async () => {
    > 134 |         const promise = chromeDevAssist.verifyCleanup({
          |                                         ^
      135 |           expectedClosedTabs: [123, 456, 789]
      136 |         });
      137 |

      at Object.verifyCleanup (tests/unit/test-orchestration.test.js:134:41)

  â— Test Orchestration Protocol â€º State Machine Tests â€º should export all orchestration functions

    expect(received).toHaveProperty(path)

    Expected path: "startTest"
    Received path: []

    Received value: {"captureLogs": [Function captureLogs], "closeTab": [Function closeTab], "getAllExtensions": [Function getAllExtensions], "getExtensionInfo": [Function getExtensionInfo], "openUrl": [Function openUrl], "reload": [Function reload], "reloadAndCapture": [Function reloadAndCapture], "reloadTab": [Function reloadTab]}

      271 |
      272 |     test('should export all orchestration functions', () => {
    > 273 |       expect(chromeDevAssist).toHaveProperty('startTest');
          |                               ^
      274 |       expect(chromeDevAssist).toHaveProperty('endTest');
      275 |       expect(chromeDevAssist).toHaveProperty('getTestStatus');
      276 |       expect(chromeDevAssist).toHaveProperty('abortTest');

      at Object.toHaveProperty (tests/unit/test-orchestration.test.js:273:31)

FAIL tests/integration/phase-1.1.test.js
  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º returns list of installed extensions

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º filters out self (Chrome Dev Assist)

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º includes extension details

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getAllExtensions â€º count matches array length

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º returns details for valid extension ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º throws error for non-existent extension

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º throws error for missing extension ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º getExtensionInfo â€º includes permissions array

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º opens URL in new tab

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º throws error for missing URL

    expect(received).rejects.toThrow(expected)

    Expected pattern: /required/i
    Received message: "Extension not connected"

          60 |         } else if (response.type === 'error') {
          61 |           ws.close();
        > 62 |           reject(new Error(response.error.message));
             |                  ^
          63 |         }
          64 |       });
          65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/phase-1.1.test.js:250:17)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º supports active option

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º supports captureConsole option

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º openUrl â€º returns tabId

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º reloads tab by ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º supports bypassCache option (hard reload)

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º supports captureConsole option

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º reloadTab â€º throws error for missing tabId

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º closeTab â€º closes tab by ID

    Extension not connected

      60 |         } else if (response.type === 'error') {
      61 |           ws.close();
    > 62 |           reject(new Error(response.error.message));
         |                  ^
      63 |         }
      64 |       });
      65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Discovery & Tab Management â€º closeTab â€º throws error for missing tabId

    expect(received).rejects.toThrow(expected)

    Expected pattern: /required/i
    Received message: "Extension not connected"

          60 |         } else if (response.type === 'error') {
          61 |           ws.close();
        > 62 |           reject(new Error(response.error.message));
             |                  ^
          63 |         }
          64 |       });
          65 |

      at WebSocket.<anonymous> (tests/integration/phase-1.1.test.js:62:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)
      at Object.toThrow (node_modules/expect/build/index.js:218:22)
      at Object.toThrow (tests/integration/phase-1.1.test.js:396:17)

FAIL tests/unit/timeout-wrapper.test.js
  â— Verification: withTimeout implementation in background.js â€º should verify withTimeout exists in background.js

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      230 |
      231 |     // Verify withTimeout function is defined
    > 232 |     expect(backgroundJs).toContain('async function withTimeout(');
          |                          ^
      233 |     expect(backgroundJs).toContain('clearTimeout(timeoutHandle)');
      234 |   });
      235 |

      at Object.toContain (tests/unit/timeout-wrapper.test.js:232:26)

  â— Verification: withTimeout implementation in background.js â€º should verify withTimeout implementation matches test version

    expect(received).toContain(expected) // indexOf

    Expected substring: "Promise.race([promise, timeoutPromise])"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      241 |
      242 |     // Key implementation details that MUST be present
    > 243 |     expect(backgroundJs).toContain('Promise.race([promise, timeoutPromise])');
          |                          ^
      244 |     expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success');
      245 |     expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error');
      246 |   });

      at Object.toContain (tests/unit/timeout-wrapper.test.js:243:26)

FAIL tests/integration/phase-1.1-medium.test.js
  â— Phase 1.1 - Medium Complexity Tests â€º Beginner Developer - Realistic Confusion â€º passes wrong types to functions that expect none

    Should handle extra arguments gracefully: Extension not connected

      36 |       } catch (err) {
      37 |         // Should not error - just ignore extra args
    > 38 |         throw new Error('Should handle extra arguments gracefully: ' + err.message);
         |               ^
      39 |       }
      40 |     }, TEST_TIMEOUT);
      41 |

      at Object.<anonymous> (tests/integration/phase-1.1-medium.test.js:38:15)

  â— Phase 1.1 - Medium Complexity Tests â€º Beginner Developer - Realistic Confusion â€º forgets to await async functions

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Busy Developer - Rapid Workflows â€º opens multiple tabs quickly

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Busy Developer - Rapid Workflows â€º open -> reload -> close workflow

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Busy Developer - Rapid Workflows â€º queries extension info multiple times

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Debugger - Error Details â€º provides clear error for non-existent extension

    expect(received).toMatch(expected)

    Expected pattern: /Extension not found/i
    Received string:  "Extension not connected"

      242 |         throw new Error('Should throw error for non-existent extension');
      243 |       } catch (err) {
    > 244 |         expect(err.message).toMatch(/Extension not found/i);
          |                             ^
      245 |         expect(err.message).toContain(fakeId);
      246 |       }
      247 |     }, TEST_TIMEOUT);

      at Object.toMatch (tests/integration/phase-1.1-medium.test.js:244:29)

  â— Phase 1.1 - Medium Complexity Tests â€º Debugger - Error Details â€º returns detailed extension info including permissions

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Debugger - Error Details â€º openUrl returns tabId for tracking

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Reliability Engineer - Concurrent Operations â€º handles parallel getAllExtensions calls

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Reliability Engineer - Concurrent Operations â€º handles parallel getExtensionInfo calls

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Reliability Engineer - Concurrent Operations â€º opens multiple tabs concurrently

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º getAllExtensions count matches array length

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º getAllExtensions filters out Chrome Dev Assist itself

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º openUrl with active:true focuses tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º openUrl with active:false backgrounds tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º reloadTab with bypassCache option

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Phase 1.1 - Medium Complexity Tests â€º Perfectionist - Consistency and Edge Cases â€º closeTab returns correct response

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/edge-cases.test.js
  â— Edge Cases - Memory & Resource Limits â€º enforces 10,000 log limit per capture

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Memory & Resource Limits â€º truncates very long messages (>10,000 chars)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Memory & Resource Limits â€º handles 10 rapid concurrent captures (cleanup verification)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies 10 concurrent tab-specific captures with isolation

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies openUrl only captures from its own tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies reloadTab only captures from specified tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Tab-Specific Filtering â€º verifies consistent tabId in captured logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles special characters in console output

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles undefined and null in console output

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles deeply nested objects

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles circular references in objects

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Special Data & Error Handling â€º handles empty console output

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Race Conditions & Timing â€º handles overlapping captures on same tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Edge Cases - Race Conditions & Timing â€º handles rapid sequential operations on same tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/complete-system.test.js
  â— Complete System Integration Tests â€º Extension Discovery â€º should get all installed extensions

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension Discovery â€º should get specific extension info

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should enable extension

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should disable and re-enable extension

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should toggle extension state

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension State Management â€º should reject invalid extension ID for enable/disable

    TypeError: chromeDevAssist.enableExtension is not a function

      182 |     test('should reject invalid extension ID for enable/disable', async () => {
      183 |       await expect(
    > 184 |         chromeDevAssist.enableExtension('invalid-id')
          |                         ^
      185 |       ).rejects.toThrow(/32 characters/);
      186 |
      187 |       await expect(

      at Object.enableExtension (tests/integration/complete-system.test.js:184:25)

  â— Complete System Integration Tests â€º Extension Reload â€º should reload extension without console capture

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension Reload â€º should reload extension WITH console capture

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Extension Reload â€º should capture console logs for specified duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Console Log Capture (No Reload) â€º should capture console logs without reloading

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should open URL in new tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should open URL and capture console logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should open URL with autoClose

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should reload tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Tab Management â€º should close tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Page Metadata Extraction â€º should extract metadata from test page

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Page Metadata Extraction â€º should handle page with no metadata gracefully

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Page Metadata Extraction â€º should reject invalid tab ID

    TypeError: chromeDevAssist.getPageMetadata is not a function

      416 |     test('should reject invalid tab ID', async () => {
      417 |       await expect(
    > 418 |         chromeDevAssist.getPageMetadata(999999)
          |                         ^
      419 |       ).rejects.toThrow();
      420 |     });
      421 |   });

      at Object.getPageMetadata (tests/integration/complete-system.test.js:418:25)

  â— Complete System Integration Tests â€º Test Orchestration â€º should start, check status, and end test

    TypeError: chromeDevAssist.startTest is not a function

      440 |
      441 |       // Start test
    > 442 |       const startResult = await chromeDevAssist.startTest(testId, {
          |                                                 ^
      443 |         autoCleanup: true
      444 |       });
      445 |

      at Object.startTest (tests/integration/complete-system.test.js:442:49)

  â— Complete System Integration Tests â€º Test Orchestration â€º should track tabs opened during test

    TypeError: chromeDevAssist.startTest is not a function

      471 |       testId = 'test-tab-tracking-' + Date.now();
      472 |
    > 473 |       await chromeDevAssist.startTest(testId);
          |                             ^
      474 |
      475 |       // Open tabs during test (should be auto-tracked)
      476 |       const tab1 = await chromeDevAssist.openUrl('https://example.com', {

      at Object.startTest (tests/integration/complete-system.test.js:473:29)

  â— Complete System Integration Tests â€º Test Orchestration â€º should abort test

    TypeError: chromeDevAssist.startTest is not a function

      501 |       testId = 'test-abort-' + Date.now();
      502 |
    > 503 |       await chromeDevAssist.startTest(testId);
          |                             ^
      504 |
      505 |       // Open a tab
      506 |       await chromeDevAssist.openUrl('https://example.com', { active: false });

      at Object.startTest (tests/integration/complete-system.test.js:503:29)

  â— Complete System Integration Tests â€º Test Orchestration â€º should reject starting test when one is active

    TypeError: chromeDevAssist.startTest is not a function

      521 |       testId = 'test-duplicate-' + Date.now();
      522 |
    > 523 |       await chromeDevAssist.startTest(testId);
          |                             ^
      524 |
      525 |       // Try to start another test
      526 |       await expect(

      at Object.startTest (tests/integration/complete-system.test.js:523:29)

  â— Complete System Integration Tests â€º Test Orchestration â€º should verify cleanup detects orphans

    TypeError: chromeDevAssist.startTest is not a function

      536 |       testId = 'test-cleanup-verification-' + Date.now();
      537 |
    > 538 |       await chromeDevAssist.startTest(testId);
          |                             ^
      539 |
      540 |       // Open tabs
      541 |       const tab1 = await chromeDevAssist.openUrl('https://example.com', {

      at Object.startTest (tests/integration/complete-system.test.js:538:29)

  â— Complete System Integration Tests â€º Full Integration Workflows â€º complete workflow: reload extension + capture + analyze logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Complete System Integration Tests â€º Full Integration Workflows â€º complete workflow: test with fixture + metadata validation

    TypeError: chromeDevAssist.abortTest is not a function

      634 |       } catch (err) {
      635 |         // Cleanup on error
    > 636 |         await chromeDevAssist.abortTest(testId, err.message);
          |                               ^
      637 |         throw err;
      638 |       }
      639 |     });

      at Object.abortTest (tests/integration/complete-system.test.js:636:31)

  â— Complete System Integration Tests â€º Full Integration Workflows â€º complete workflow: multi-tab test with orchestration

    TypeError: chromeDevAssist.abortTest is not a function

      679 |
      680 |       } catch (err) {
    > 681 |         await chromeDevAssist.abortTest(testId, err.message);
          |                               ^
      682 |         throw err;
      683 |       }
      684 |     });

      at Object.abortTest (tests/integration/complete-system.test.js:681:31)

  â— Complete System Integration Tests â€º Error Handling â€º should handle connection errors gracefully

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/unit/page-metadata.test.js
  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject missing tabId

    TypeError: getPageMetadata is not a function

      23 |   describe('Input Validation', () => {
      24 |     test('should reject missing tabId', async () => {
    > 25 |       await expect(getPageMetadata()).rejects.toThrow('tabId is required');
         |                    ^
      26 |     });
      27 |
      28 |     test('should reject null tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:25:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject null tabId

    TypeError: getPageMetadata is not a function

      27 |
      28 |     test('should reject null tabId', async () => {
    > 29 |       await expect(getPageMetadata(null)).rejects.toThrow('tabId is required');
         |                    ^
      30 |     });
      31 |
      32 |     test('should reject undefined tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:29:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject undefined tabId

    TypeError: getPageMetadata is not a function

      31 |
      32 |     test('should reject undefined tabId', async () => {
    > 33 |       await expect(getPageMetadata(undefined)).rejects.toThrow('tabId is required');
         |                    ^
      34 |     });
      35 |
      36 |     test('should reject non-number tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:33:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject non-number tabId

    TypeError: getPageMetadata is not a function

      35 |
      36 |     test('should reject non-number tabId', async () => {
    > 37 |       await expect(getPageMetadata('123')).rejects.toThrow('tabId must be a number');
         |                    ^
      38 |       await expect(getPageMetadata(true)).rejects.toThrow('tabId must be a number');
      39 |       await expect(getPageMetadata({})).rejects.toThrow('tabId must be a number');
      40 |       await expect(getPageMetadata([])).rejects.toThrow('tabId must be a number');

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:37:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject negative tabId

    TypeError: getPageMetadata is not a function

      42 |
      43 |     test('should reject negative tabId', async () => {
    > 44 |       await expect(getPageMetadata(-1)).rejects.toThrow('tabId must be a positive integer');
         |                    ^
      45 |     });
      46 |
      47 |     test('should reject zero tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:44:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject zero tabId

    TypeError: getPageMetadata is not a function

      46 |
      47 |     test('should reject zero tabId', async () => {
    > 48 |       await expect(getPageMetadata(0)).rejects.toThrow('tabId must be a positive integer');
         |                    ^
      49 |     });
      50 |
      51 |     test('should reject non-integer tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:48:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject non-integer tabId

    TypeError: getPageMetadata is not a function

      50 |
      51 |     test('should reject non-integer tabId', async () => {
    > 52 |       await expect(getPageMetadata(123.45)).rejects.toThrow('tabId must be an integer');
         |                    ^
      53 |     });
      54 |
      55 |     test('should reject tabId exceeding safe integer', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:52:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject tabId exceeding safe integer

    TypeError: getPageMetadata is not a function

      54 |
      55 |     test('should reject tabId exceeding safe integer', async () => {
    > 56 |       await expect(getPageMetadata(Number.MAX_SAFE_INTEGER + 1))
         |                    ^
      57 |         .rejects.toThrow('tabId exceeds safe integer range');
      58 |     });
      59 |

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:56:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject NaN tabId

    TypeError: getPageMetadata is not a function

      59 |
      60 |     test('should reject NaN tabId', async () => {
    > 61 |       await expect(getPageMetadata(NaN)).rejects.toThrow('tabId must be a number');
         |                    ^
      62 |     });
      63 |
      64 |     test('should reject Infinity tabId', async () => {

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:61:20)

  â— DOM Inspection API: getPageMetadata() â€º Input Validation â€º should reject Infinity tabId

    TypeError: getPageMetadata is not a function

      63 |
      64 |     test('should reject Infinity tabId', async () => {
    > 65 |       await expect(getPageMetadata(Infinity)).rejects.toThrow('tabId must be a finite number');
         |                    ^
      66 |     });
      67 |   });
      68 |

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:65:20)

  â— DOM Inspection API: getPageMetadata() â€º Error Handling â€º should reject tab that does not exist

    TypeError: getPageMetadata is not a function

      135 |       const nonExistentTabId = 999999;
      136 |
    > 137 |       await expect(getPageMetadata(nonExistentTabId))
          |                    ^
      138 |         .rejects.toThrow(/No tab with id|Extension not connected|tab.*not found/i);
      139 |     });
      140 |

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:137:20)

  â— DOM Inspection API: getPageMetadata() â€º Error Handling â€º should provide clear error for connection failures

    TypeError: getPageMetadata is not a function

      143 |       // This will fail with "Extension not connected" or "ECONNREFUSED"
      144 |
    > 145 |       await expect(getPageMetadata(1))
          |                    ^
      146 |         .rejects.toThrow(/Extension not connected|ECONNREFUSED|not running/i);
      147 |     });
      148 |   });

      at Object.getPageMetadata (tests/unit/page-metadata.test.js:145:20)

FAIL tests/integration/screenshot-visual-verification.test.js
  â— Screenshot Visual Verification â€º Screenshot Verification Summary â€º should list all screenshots for manual verification

    expect(received).toBe(expected) // Object.is equality

    Expected: 3
    Received: 10

      253 |         console.log('   Use Read tool to analyze screenshot images');
      254 |
    > 255 |         expect(files.length).toBe(3);
          |                              ^
      256 |       }
      257 |     });
      258 |   });

      at Object.toBe (tests/integration/screenshot-visual-verification.test.js:255:30)

FAIL tests/integration/reload-button-fix.test.js
  â— Reload Button Fix Verification â€º Fix #1: WebSocket onerror Handler â€º should use console.warn (not console.error) for WebSocket connection issues

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optio"

      34 |
      35 |       // Verify it uses console.warn for WebSocket connection issue
    > 36 |       expect(handlerBody).toContain('console.warn');
         |                           ^
      37 |       expect(handlerBody).toContain('WebSocket connection issue');
      38 |
      39 |       // Verify it does NOT use console.error for the connection issue

      at Object.toContain (tests/integration/reload-button-fix.test.js:36:27)

  â— Reload Button Fix Verification â€º Fix #1: WebSocket onerror Handler â€º should include explanatory comment about Chrome crash prevention

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { e"

      48 |
      49 |       // Verify fix comment exists
    > 50 |       expect(handlerBody).toContain('âœ… FIX');
         |                           ^
      51 |       expect(handlerBody).toContain('console.warn instead of console.error');
      52 |       expect(handlerBody).toContain('prevent Chrome');
      53 |     });

      at Object.toContain (tests/integration/reload-button-fix.test.js:50:27)

  â— Reload Button Fix Verification â€º Fix #1: WebSocket onerror Handler â€º should still schedule reconnection on error

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', exte"

      58 |
      59 |       // Verify reconnection logic still exists
    > 60 |       expect(handlerBody).toContain('scheduleReconnect');
         |                           ^
      61 |       expect(handlerBody).toContain('reconnectAttempts++');
      62 |     });
      63 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:60:27)

  â— Reload Button Fix Verification â€º Fix #2: Connection Timeout Handler â€º should use console.warn (not console.error) for connection timeout

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   -1

      67 |       // Find connection timeout handler
      68 |       const timeoutIndex = backgroundJs.indexOf('const connectTimeout = setTimeout(');
    > 69 |       expect(timeoutIndex).toBeGreaterThan(0);
         |                            ^
      70 |
      71 |       // Get timeout handler body (next 500 chars)
      72 |       const handlerBody = backgroundJs.substring(timeoutIndex, timeoutIndex + 500);

      at Object.toBeGreaterThan (tests/integration/reload-button-fix.test.js:69:28)

  â— Reload Button Fix Verification â€º Fix #2: Connection Timeout Handler â€º should include explanatory comment

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      85 |       const handlerBody = backgroundJs.substring(timeoutIndex, timeoutIndex + 600);
      86 |
    > 87 |       expect(handlerBody).toContain('âœ… FIX');
         |                           ^
      88 |       expect(handlerBody).toContain('console.warn instead of console.error');
      89 |     });
      90 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:87:27)

  â— Reload Button Fix Verification â€º Fix #3: Registration Timeout Handler â€º should use console.warn (not console.error) for registration timeout

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   -1

      94 |       // Find registration timeout handler
      95 |       const regTimeoutIndex = backgroundJs.indexOf('registrationTimeout = setTimeout(');
    > 96 |       expect(regTimeoutIndex).toBeGreaterThan(0);
         |                               ^
      97 |
      98 |       // Get handler body (next 500 chars)
      99 |       const handlerBody = backgroundJs.substring(regTimeoutIndex, regTimeoutIndex + 500);

      at Object.toBeGreaterThan (tests/integration/reload-button-fix.test.js:96:31)

  â— Reload Button Fix Verification â€º Fix #3: Registration Timeout Handler â€º should include explanatory comment

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      112 |       const handlerBody = backgroundJs.substring(regTimeoutIndex, regTimeoutIndex + 600);
      113 |
    > 114 |       expect(handlerBody).toContain('âœ… FIX');
          |                           ^
      115 |       expect(handlerBody).toContain('console.warn instead of console.error');
      116 |     });
      117 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:114:27)

  â— Reload Button Fix Verification â€º Verify No console.error for Expected Conditions â€º should not use console.error for WebSocket state issues in safeSend

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.error"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    /"

      126 |
      127 |       // console.error for null is OK (programming error)
    > 128 |       expect(safeSendBody).toContain('console.error');
          |                            ^
      129 |       expect(safeSendBody).toContain('WebSocket is null');
      130 |
      131 |       // But should use console.warn for state-based issues

      at Object.toContain (tests/integration/reload-button-fix.test.js:128:28)

  â— Reload Button Fix Verification â€º Verify No console.error for Expected Conditions â€º should document why connection failures are expected

    expect(received).toMatch(expected)

    Expected pattern: /expected/i
    Received string:  "d(json.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'extension_error'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[chromedevassist] websocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[chromedevassist] disconnected from server, reconnecting in 1s...');
        ws = null;
        settimeout(connecttoserver, 1000);
      };
    }Â·
    // connect on startup (only in chrome extension context)
    if (typeof chrome !== 'undefined' && typeof websocket !== 'undefined') {
      connecttoserver();
    }Â·
    /**
     * handle reload command
     * disables and re-enables the target extension, optionally capturing console logs
     */
    async function handlereloadcommand(commandid, params) {
      const { e"

      141 |
      142 |       // Should explain that failures are EXPECTED
    > 143 |       expect(handlerSection.toLowerCase()).toMatch(/expected/i);
          |                                            ^
      144 |     });
      145 |   });
      146 |

      at Object.toMatch (tests/integration/reload-button-fix.test.js:143:44)

  â— Reload Button Fix Verification â€º Fix #4: Command Error Handler â€º should use console.warn (not console.error) for command failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws."

      155 |
      156 |       // Verify it uses console.warn for command failures
    > 157 |       expect(handlerBody).toContain('console.warn');
          |                           ^
      158 |       expect(handlerBody).toContain('Command failed');
      159 |
      160 |       // Verify it does NOT use console.error for command failures

      at Object.toContain (tests/integration/reload-button-fix.test.js:157:27)

  â— Reload Button Fix Verification â€º Fix #4: Command Error Handler â€º should include explanatory comment about expected errors

    expect(received).toContain(expected) // indexOf

    Expected substring: "âœ… FIX"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclos"

      168 |
      169 |       // Verify fix comment exists
    > 170 |       expect(handlerBody).toContain('âœ… FIX');
          |                           ^
      171 |       expect(handlerBody).toContain('console.warn instead of console.error');
      172 |       expect(handlerBody).toContain('Command failures are EXPECTED');
      173 |     });

      at Object.toContain (tests/integration/reload-button-fix.test.js:170:27)

  â— Reload Button Fix Verification â€º Fix #4: Command Error Handler â€º should still send error response to server

    expect(received).toContain(expected) // indexOf

    Expected substring: "safeSend"
    Received string:    "} catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome ex"

      179 |       // Verify error response sent
      180 |       expect(handlerBody).toContain("type: 'error'");
    > 181 |       expect(handlerBody).toContain('safeSend');
          |                           ^
      182 |     });
      183 |   });
      184 |

      at Object.toContain (tests/integration/reload-button-fix.test.js:181:27)

  â— Reload Button Fix Verification â€º Impact Verification â€º should have exactly 4 console.error â†’ console.warn fixes

    expect(received).toBeTruthy()

    Received: null

      187 |       // Count fix comments
      188 |       const fixComments = backgroundJs.match(/âœ… FIX.*console\.warn instead of console\.error/g);
    > 189 |       expect(fixComments).toBeTruthy();
          |                           ^
      190 |       expect(fixComments.length).toBe(4);
      191 |     });
      192 |

      at Object.toBeTruthy (tests/integration/reload-button-fix.test.js:189:27)

  â— Reload Button Fix Verification â€º Impact Verification â€º should preserve all reconnection logic

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect()"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      193 |     it('should preserve all reconnection logic', () => {
      194 |       // Verify reconnection logic still intact
    > 195 |       expect(backgroundJs).toContain('scheduleReconnect()');
          |                            ^
      196 |       expect(backgroundJs).toContain('exponential backoff');
      197 |       expect(backgroundJs).toContain('reconnectAttempts++');
      198 |       expect(backgroundJs).toContain('isConnecting = false');

      at Object.toContain (tests/integration/reload-button-fix.test.js:195:28)

  â— Reload Button Fix Verification â€º Impact Verification â€º should preserve all error handling paths

    expect(received).toContain(expected) // indexOf

    Expected substring: "connectTimeout"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      203 |       expect(backgroundJs).toContain('ws.onerror');
      204 |       expect(backgroundJs).toContain('ws.onclose');
    > 205 |       expect(backgroundJs).toContain('connectTimeout');
          |                            ^
      206 |       expect(backgroundJs).toContain('registrationTimeout');
      207 |     });
      208 |   });

      at Object.toContain (tests/integration/reload-button-fix.test.js:205:28)

FAIL tests/unit/screenshot.test.js
  â— Screenshot Capture â€º Basic Screenshot Capture â€º should capture screenshot of a tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Basic Screenshot Capture â€º should return PNG format by default

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Basic Screenshot Capture â€º should include base64 image data

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Basic Screenshot Capture â€º should include timestamp

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Format Options â€º should capture PNG when format is "png"

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Format Options â€º should capture JPEG when format is "jpeg"

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Format Options â€º should reject invalid format

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should accept quality parameter for JPEG

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should default to quality 90 for JPEG

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should reject quality < 0

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should reject quality > 100

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Quality Options (JPEG) â€º should ignore quality parameter for PNG

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject invalid tab ID (non-number)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject invalid tab ID (negative)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject invalid tab ID (non-existent)

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject null tab ID

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Validation â€º should reject undefined tab ID

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Error Handling â€º should handle extension disconnection gracefully

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Error Handling â€º should provide clear error message for invalid options

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Multiple Screenshots â€º should capture multiple screenshots of same tab

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Multiple Screenshots â€º should capture screenshots of different tabs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Different Page Content â€º should capture different content for different pages

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Integration with Test Orchestration â€º should work within a test context

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Capture â€º Performance â€º should capture screenshot in reasonable time

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/chrome-crash-prevention.test.js
  â— Chrome Crash Prevention â€º Expected Errors Use console.warn â€º should use console.warn for WebSocket connection failures

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', exte"

      29 |       );
      30 |
    > 31 |       expect(onerrorHandler).toContain('console.warn');
         |                              ^
      32 |       expect(onerrorHandler).toContain('WebSocket connection issue');
      33 |       expect(onerrorHandler).not.toMatch(/console\.error.*WebSocket.*connection/i);
      34 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:31:30)

  â— Chrome Crash Prevention â€º Expected Errors Use console.warn â€º should use console.warn for connection timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      41 |       );
      42 |
    > 43 |       expect(timeoutHandler).toContain('console.warn');
         |                              ^
      44 |       expect(timeoutHandler).toContain('Connection timeout after 5s');
      45 |       expect(timeoutHandler).not.toMatch(/console\.error.*timeout/i);
      46 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:43:30)

  â— Chrome Crash Prevention â€º Expected Errors Use console.warn â€º should use console.warn for registration timeouts

    expect(received).toContain(expected) // indexOf

    Expected substring: "console.warn"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Max"

      53 |       );
      54 |
    > 55 |       expect(regTimeoutHandler).toContain('console.warn');
         |                                 ^
      56 |       expect(regTimeoutHandler).toContain('Registration acknowledgment not received');
      57 |       expect(regTimeoutHandler).not.toMatch(/console\.error.*[Rr]egistration/);
      58 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:55:33)

  â— Chrome Crash Prevention â€º Unexpected Errors Use console.error â€º should use console.error for programming errors

    expect(received).toBeTruthy()

    Received: null

      66 |       // Verify we still have console.error for actual bugs
      67 |       const nullCheckErrors = backgroundJs.match(/console\.error.*WebSocket is null/g);
    > 68 |       expect(nullCheckErrors).toBeTruthy();
         |                               ^
      69 |       expect(nullCheckErrors.length).toBeGreaterThan(0);
      70 |     });
      71 |

      at Object.toBeTruthy (tests/integration/chrome-crash-prevention.test.js:68:31)

  â— Chrome Crash Prevention â€º Unexpected Errors Use console.error â€º should use console.error for unknown WebSocket states

    expect(received).toContain(expected) // indexOf

    Expected substring: "Unknown WebSocket state"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      73 |       // Unknown states are programming errors
      74 |       expect(backgroundJs).toContain('console.error');
    > 75 |       expect(backgroundJs).toContain('Unknown WebSocket state');
         |                            ^
      76 |     });
      77 |
      78 |     it('should use console.error for command failures', () => {

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:75:28)

  â— Chrome Crash Prevention â€º Crash Prevention Patterns â€º should have explanatory comments for all console.warn usages

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 3
    Received:    0

      88 |
      89 |       // Should have at least 3 fix comments (for the 3 main fixes)
    > 90 |       expect(fixComments.length).toBeGreaterThanOrEqual(3);
         |                                  ^
      91 |     });
      92 |
      93 |     it('should explain why connection failures are expected', () => {

      at Object.toBeGreaterThanOrEqual (tests/integration/chrome-crash-prevention.test.js:90:34)

  â— Chrome Crash Prevention â€º Crash Prevention Patterns â€º should explain why connection failures are expected

    expect(received).toContain(expected) // indexOf

    Expected substring: "Connection failures are EXPECTED"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      93 |     it('should explain why connection failures are expected', () => {
      94 |       // Check for explanatory comments
    > 95 |       expect(backgroundJs).toContain('Connection failures are EXPECTED');
         |                            ^
      96 |       expect(backgroundJs).toContain('server not running');
      97 |       expect(backgroundJs).toContain('server restart');
      98 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:95:28)

  â— Chrome Crash Prevention â€º Crash Prevention Patterns â€º should still handle errors gracefully

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      100 |     it('should still handle errors gracefully', () => {
      101 |       // Verify all error paths have recovery logic
    > 102 |       expect(backgroundJs).toContain('scheduleReconnect');
          |                            ^
      103 |       expect(backgroundJs).toContain('exponential backoff');
      104 |       expect(backgroundJs).toContain('reconnectAttempts');
      105 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:102:28)

  â— Chrome Crash Prevention â€º Chrome Extension Health Indicators â€º should not have patterns that trigger Chrome crash detection

    expect(received).toMatch(expected)

    Expected pattern: /scheduleReconnect|reconnectAttempts|ws\.close\(\)/
    Received string:  "ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`)"

      131 |
      132 |         // Should have recovery logic (either direct scheduleReconnect() or ws.close() which triggers ws.onclose)
    > 133 |         expect(handlerCode).toMatch(/scheduleReconnect|reconnectAttempts|ws\.close\(\)/);
          |                             ^
      134 |       });
      135 |     });
      136 |

      at toMatch (tests/integration/chrome-crash-prevention.test.js:133:29)
          at Array.forEach (<anonymous>)
      at Object.forEach (tests/integration/chrome-crash-prevention.test.js:123:21)

  â— Chrome Crash Prevention â€º Chrome Extension Health Indicators â€º should have bounded reconnection attempts

    expect(received).toContain(expected) // indexOf

    Expected substring: "Math.min"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      137 |     it('should have bounded reconnection attempts', () => {
      138 |       // Verify exponential backoff has max limit
    > 139 |       expect(backgroundJs).toContain('Math.min');
          |                            ^
      140 |       expect(backgroundJs).toContain('Math.pow(2,');
      141 |
      142 |       // Should have max reconnection delay (30 seconds)

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:139:28)

  â— Chrome Crash Prevention â€º Chrome Extension Health Indicators â€º should prevent infinite connection loops

    expect(received).toContain(expected) // indexOf

    Expected substring: "let isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      146 |     it('should prevent infinite connection loops', () => {
      147 |       // Verify isConnecting flag prevents duplicates
    > 148 |       expect(backgroundJs).toContain('let isConnecting = false');
          |                            ^
      149 |       expect(backgroundJs).toContain('if (isConnecting)');
      150 |       expect(backgroundJs).toContain('Already connecting');
      151 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:148:28)

  â— Chrome Crash Prevention â€º Error Message Quality â€º should distinguish between transient and permanent errors

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 3
    Received:    0

      179 |       // Count console.warn for transient issues (connection, timeout, registration)
      180 |       const warnCount = (backgroundJs.match(/console\.warn.*connection|console\.warn.*timeout|console\.warn.*Registration/gi) || []).length;
    > 181 |       expect(warnCount).toBeGreaterThanOrEqual(3);
          |                         ^
      182 |
      183 |       // Count console.error for programming issues
      184 |       const errorCount = (backgroundJs.match(/console\.error.*null|Unknown|failed/gi) || []).length;

      at Object.toBeGreaterThanOrEqual (tests/integration/chrome-crash-prevention.test.js:181:25)

  â— Chrome Crash Prevention â€º Service Worker Stability â€º should have keep-alive mechanism

    expect(received).toContain(expected) // indexOf

    Expected substring: "keep-alive"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      190 |     it('should have keep-alive mechanism', () => {
      191 |       // Verify keep-alive alarm exists
    > 192 |       expect(backgroundJs).toContain('keep-alive');
          |                            ^
      193 |       expect(backgroundJs).toContain('periodInMinutes');
      194 |       expect(backgroundJs).toContain('0.25'); // 15 seconds
      195 |     });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:192:28)

  â— Chrome Crash Prevention â€º Service Worker Stability â€º should handle alarm errors gracefully

    expect(received).toContain(expected) // indexOf

    Expected substring: "chrome.alarms.onAlarm.addListener"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      197 |     it('should handle alarm errors gracefully', () => {
      198 |       // Verify alarm handler exists
    > 199 |       expect(backgroundJs).toContain('chrome.alarms.onAlarm.addListener');
          |                            ^
      200 |
      201 |       // Should check connection state before reconnecting
      202 |       expect(backgroundJs).toContain('ws.readyState');

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:199:28)

  â— Chrome Crash Prevention â€º Service Worker Stability â€º should prevent duplicate alarms

    expect(received).toContain(expected) // indexOf

    Expected substring: "chrome.alarms.clear"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      205 |     it('should prevent duplicate alarms', () => {
      206 |       // Verify alarm clearing before creating new one
    > 207 |       expect(backgroundJs).toContain('chrome.alarms.clear');
          |                            ^
      208 |       expect(backgroundJs).toContain('reconnect-websocket');
      209 |     });
      210 |   });

      at Object.toContain (tests/integration/chrome-crash-prevention.test.js:207:28)

FAIL tests/integration/improvements-verification.test.js
  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have withTimeout function defined

    expect(received).toContain(expected) // indexOf

    Expected substring: "async function withTimeout("
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      25 |   describe('Improvement 8: Timeout Wrapper (P0 CRITICAL)', () => {
      26 |     it('should have withTimeout function defined', () => {
    > 27 |       expect(backgroundJs).toContain('async function withTimeout(');
         |                            ^
      28 |       expect(backgroundJs).toContain('Promise.race([promise, timeoutPromise])');
      29 |     });
      30 |

      at Object.toContain (tests/integration/improvements-verification.test.js:27:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have timer cleanup on success

    expect(received).toContain(expected) // indexOf

    Expected substring: "clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      30 |
      31 |     it('should have timer cleanup on success', () => {
    > 32 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success');
         |                            ^
      33 |     });
      34 |
      35 |     it('should have timer cleanup on error', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:32:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have timer cleanup on error

    expect(received).toContain(expected) // indexOf

    Expected substring: "clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      34 |
      35 |     it('should have timer cleanup on error', () => {
    > 36 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error');
         |                            ^
      37 |     });
      38 |
      39 |     it('should have timeout error message format', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:36:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 8: Timeout Wrapper (P0 CRITICAL) â€º should have timeout error message format

    expect(received).toContain(expected) // indexOf

    Expected substring: "${operation} timeout after ${timeoutMs}ms"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      38 |
      39 |     it('should have timeout error message format', () => {
    > 40 |       expect(backgroundJs).toContain('${operation} timeout after ${timeoutMs}ms');
         |                            ^
      41 |     });
      42 |
      43 |     // Check if chrome.* calls are wrapped (this will initially fail)

      at Object.toContain (tests/integration/improvements-verification.test.js:40:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have message queue array

    expect(received).toContain(expected) // indexOf

    Expected substring: "const messageQueue = []"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      57 |   describe('Improvement 7: Message Queuing (P1 HIGH)', () => {
      58 |     it('should have message queue array', () => {
    > 59 |       expect(backgroundJs).toContain('const messageQueue = []');
         |                            ^
      60 |     });
      61 |
      62 |     it('should have MAX_QUEUE_SIZE constant', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:59:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have MAX_QUEUE_SIZE constant

    expect(received).toContain(expected) // indexOf

    Expected substring: "const MAX_QUEUE_SIZE = 100"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      61 |
      62 |     it('should have MAX_QUEUE_SIZE constant', () => {
    > 63 |       expect(backgroundJs).toContain('const MAX_QUEUE_SIZE = 100');
         |                            ^
      64 |     });
      65 |
      66 |     it('should have queue bounds check', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:63:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have queue bounds check

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (messageQueue.length >= MAX_QUEUE_SIZE)"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      65 |
      66 |     it('should have queue bounds check', () => {
    > 67 |       expect(backgroundJs).toContain('if (messageQueue.length >= MAX_QUEUE_SIZE)');
         |                            ^
      68 |       expect(backgroundJs).toContain('Queue full, dropping message');
      69 |     });
      70 |

      at Object.toContain (tests/integration/improvements-verification.test.js:67:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should queue messages during CONNECTING state

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (ws.readyState === WebSocket.CONNECTING)"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      70 |
      71 |     it('should queue messages during CONNECTING state', () => {
    > 72 |       expect(backgroundJs).toContain('if (ws.readyState === WebSocket.CONNECTING)');
         |                            ^
      73 |       expect(backgroundJs).toContain('messageQueue.push(message)');
      74 |     });
      75 |

      at Object.toContain (tests/integration/improvements-verification.test.js:72:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should drain queue when connection opens

    expect(received).toContain(expected) // indexOf

    Expected substring: "while (messageQueue.length > 0)"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      75 |
      76 |     it('should drain queue when connection opens', () => {
    > 77 |       expect(backgroundJs).toContain('while (messageQueue.length > 0)');
         |                            ^
      78 |       expect(backgroundJs).toContain('const queued = messageQueue.shift()');
      79 |     });
      80 |

      at Object.toContain (tests/integration/improvements-verification.test.js:77:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should have error handling during queue drain

    expect(received).toContain(expected) // indexOf

    Expected substring: "Failed to send queued message"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      80 |
      81 |     it('should have error handling during queue drain', () => {
    > 82 |       expect(backgroundJs).toContain('Failed to send queued message');
         |                            ^
      83 |       expect(backgroundJs).toContain('messageQueue.unshift(queued)');
      84 |     });
      85 |

      at Object.toContain (tests/integration/improvements-verification.test.js:82:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 7: Message Queuing (P1 HIGH) â€º should clear queue on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "messageQueue.length = 0"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      85 |
      86 |     it('should clear queue on disconnect', () => {
    > 87 |       expect(backgroundJs).toContain('messageQueue.length = 0');
         |                            ^
      88 |       expect(backgroundJs).toContain('Clearing');
      89 |     });
      90 |   });

      at Object.toContain (tests/integration/improvements-verification.test.js:87:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have registrationPending flag

    expect(received).toContain(expected) // indexOf

    Expected substring: "let registrationPending = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      92 |   describe('Improvement 6: Registration ACK (P2 MEDIUM)', () => {
      93 |     it('should have registrationPending flag', () => {
    > 94 |       expect(backgroundJs).toContain('let registrationPending = false');
         |                            ^
      95 |     });
      96 |
      97 |     it('should have registrationTimeout handle', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:94:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have registrationTimeout handle

    expect(received).toContain(expected) // indexOf

    Expected substring: "let registrationTimeout = null"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

       96 |
       97 |     it('should have registrationTimeout handle', () => {
    >  98 |       expect(backgroundJs).toContain('let registrationTimeout = null');
          |                            ^
       99 |     });
      100 |
      101 |     it('should set registration pending on connection', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:98:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should set registration pending on connection

    expect(received).toContain(expected) // indexOf

    Expected substring: "registrationPending = true"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      100 |
      101 |     it('should set registration pending on connection', () => {
    > 102 |       expect(backgroundJs).toContain('registrationPending = true');
          |                            ^
      103 |     });
      104 |
      105 |     it('should have registration timeout (5 seconds)', () => {

      at Object.toContain (tests/integration/improvements-verification.test.js:102:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have registration timeout (5 seconds)

    expect(received).toContain(expected) // indexOf

    Expected substring: "Registration timeout, reconnecting"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      104 |
      105 |     it('should have registration timeout (5 seconds)', () => {
    > 106 |       expect(backgroundJs).toContain('Registration timeout, reconnecting');
          |                            ^
      107 |       expect(backgroundJs).toContain('5000'); // 5 second timeout
      108 |     });
      109 |

      at Object.toContain (tests/integration/improvements-verification.test.js:106:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should handle registration-ack message

    expect(received).toContain(expected) // indexOf

    Expected substring: "if (message.type === 'registration-ack')"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      109 |
      110 |     it('should handle registration-ack message', () => {
    > 111 |       expect(backgroundJs).toContain("if (message.type === 'registration-ack')");
          |                            ^
      112 |       expect(backgroundJs).toContain('clearTimeout(registrationTimeout)');
      113 |       expect(backgroundJs).toContain('isRegistered = true');
      114 |     });

      at Object.toContain (tests/integration/improvements-verification.test.js:111:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should reset registration state on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "isRegistered = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      115 |
      116 |     it('should reset registration state on disconnect', () => {
    > 117 |       expect(backgroundJs).toContain('isRegistered = false');
          |                            ^
      118 |       expect(backgroundJs).toContain('registrationPending = false');
      119 |     });
      120 |

      at Object.toContain (tests/integration/improvements-verification.test.js:117:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Improvement 6: Registration ACK (P2 MEDIUM) â€º should have server sending registration-ack

    expect(received).toContain(expected) // indexOf

    Expected substring: "type: 'registration-ack'"
    Received string:    "#!/usr/bin/env nodeÂ·
    /**
     * Chrome Dev Assist - WebSocket Server + HTTP Static File Server
     * Routes messages between Chrome extension and Node.js API
     * Serves test fixtures over HTTP for reliable testing
     *
     * Persona Requirements Implemented:
     * - JSON validation (Persona 6)
     * - Duplicate extension registration (Persona 3, 6)
     * - Clear error messages (Persona 5, 6)
     * - Debug logging (Persona 4)
     *
     * HTTP Server Features:
     * - Serves test fixtures from /fixtures path
     * - CORS enabled for extension access
     * - Same port as WebSocket (9876)
     *
     * Security Documentation:
     * - Architecture: docs/SECURITY.md
     * - Decisions: docs/decisions/README.md
     * - Why HTTP (not HTTPS): docs/decisions/002-http-vs-https-for-localhost.md
     * - Token Auth: docs/decisions/001-test-infrastructure-authentication.md
     */Â·
    const http = require('http');
    const fs = require('fs');
    const path = require('path');
    const crypto = require('crypto');
    const WebSocket = require('ws');
    const HealthManager = require('../src/health/health-manager');Â·
    const PORT = 9876;
    const HOST = '127.0.0.1'; // localhost only for security
    const DEBUG = process.env.DEBUG === 'true';Â·
    // Path to test fixtures
    const FIXTURES_PATH = path.join(__dirname, '../tests/fixtures');Â·
    // BUG #3 FIX: Prevent multiple server instances
    // PID file for single-instance enforcement
    const PID_FILE = path.join(__dirname, '../.server-pid');Â·
    /**
     * Check if another server instance is running and handle it
     * Auto-recovery: Kills stale instances before starting new one
     */
    function ensureSingleInstance() {
      if (fs.existsSync(PID_FILE)) {
        const oldPid = parseInt(fs.readFileSync(PID_FILE, 'utf8').trim(), 10);Â·
        // Check if process is still running
        try {
          process.kill(oldPid, 0); // Signal 0 = just check if process existsÂ·
          // Process exists - kill it
          console.log(`[Server] Detected existing server instance (PID ${oldPid})`);
          console.log(`[Server] Killing old instance to prevent port conflict...`);Â·
          try {
            process.kill(oldPid, 'SIGTERM');
            // Wait a moment for graceful shutdown
            const start = Date.now();
            while (Date.now() - start < 1000) {
              try {
                process.kill(oldPid, 0);
                // Still running, wait a bit
              } catch {
                // Process died, good
                break;
              }
            }Â·
            // If still alive, force kill
            try {
              process.kill(oldPid, 0);
              console.log(`[Server] Forcing kill of old instance...`);
              process.kill(oldPid, 'SIGKILL');
            } catch {
              // Already dead
            }Â·
            console.log(`[Server] Old instance terminated successfully`);
          } catch (err) {
            console.log(`[Server] Could not kill old instance: ${err.message}`);
            console.log(`[Server] Cleaning up stale PID file`);
          }
        } catch {
          // Process doesn't exist - stale PID file
          console.log(`[Server] Removing stale PID file (process ${oldPid} not running)`);
        }Â·
        // Remove old PID file
        try {
          fs.unlinkSync(PID_FILE);
        } catch (err) {
          console.error(`[Server] Failed to remove PID file: ${err.message}`);
        }
      }Â·
      // Write our PID
      try {
        fs.writeFileSync(PID_FILE, String(process.pid), 'utf8');
        console.log(`[Server] PID ${process.pid} written to ${PID_FILE}`);
      } catch (err) {
        console.error(`[Server] Failed to write PID file: ${err.message}`);
        process.exit(1);
      }
    }Â·
    // Enforce single instance before doing anything else
    ensureSingleInstance();Â·
    // Authentication token (generated at startup for defense-in-depth)
    const AUTH_TOKEN = crypto.randomBytes(32).toString('hex');
    const TOKEN_FILE = path.join(__dirname, '../.auth-token');Â·
    // Write auth token to file for client access
    try {
      fs.writeFileSync(TOKEN_FILE, AUTH_TOKEN, 'utf8');
      console.log(`[Server] Auth token generated and saved to ${TOKEN_FILE}`);
    } catch (err) {
      console.error(`[Server] Failed to write auth token: ${err.message}`);
      process.exit(1);
    }Â·
    // State
    let extensionSocket = null;
    const apiSockets = new Map(); // commandId -> socket
    const healthManager = new HealthManager();Â·
    // Logging helper
    function log(...args) {
      if (DEBUG) {
        console.log('[Server]', ...args);
      }
    }Â·
    function logError(...args) {
      console.error('[Server ERROR]', ...args);
    }Â·
    /**
     * Handle HTTP requests - serve static files from /fixtures path
     * This allows tests to load fixtures via HTTP instead of file:// URLs
     *
     * Security:
     * - Server bound to 127.0.0.1 (localhost only)
     * - Validates Host header for additional protection
     * - Directory traversal protection on file paths
     */
    function handleHttpRequest(req, res) {
      log(`HTTP ${req.method} ${req.url} from ${req.socket.remoteAddress}`);Â·
      // Security Layer 1: Validate Host header (defense-in-depth)
      // Even though server is bound to 127.0.0.1, validate the Host header
      const host = req.headers.host || '';
      const isLocalhost = host.startsWith('localhost:') ||
                          host.startsWith('127.0.0.1:') ||
                          host === 'localhost' ||
                          host === '127.0.0.1';Â·
      if (!isLocalhost) {
        logError(`Rejected request from non-localhost Host: ${host}`);
        res.writeHead(403, { 'Content-Type': 'text/plain' });
        res.end('Forbidden: Server only accepts localhost connections');
        return;
      }Â·
      // Security Layer 2: Validate auth token (defense-in-depth)
      // Prevents other localhost applications from accessing the server
      let clientToken = req.headers['x-auth-token'];
      if (!clientToken && req.url.includes('?token=')) {
        const url = new URL(req.url, `http://${host}`);
        clientToken = url.searchParams.get('token');
      }Â·
      // Allow root path without auth (for debugging/listing)
      const requiresAuth = req.url.startsWith('/fixtures/');Â·
      if (requiresAuth && clientToken !== AUTH_TOKEN) {
        logError(`Rejected request with invalid auth token from ${req.socket.remoteAddress}`);
        res.writeHead(401, { 'Content-Type': 'text/plain' });
        res.end('Unauthorized: Invalid or missing auth token');
        return;
      }Â·
      // Enable CORS for extension access (localhost only)
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type');Â·
      // Handle OPTIONS preflight
      if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
      }Â·
      // Only handle GET requests
      if (req.method !== 'GET') {
        res.writeHead(405, { 'Content-Type': 'text/plain' });
        res.end('Method Not Allowed');
        return;
      }Â·
      // Serve test fixtures from /fixtures path
      if (req.url.startsWith('/fixtures/')) {
        // Parse URL to remove query parameters
        const url = new URL(req.url, `http://${host}`);
        const filename = url.pathname.substring('/fixtures/'.length);
        const filepath = path.join(FIXTURES_PATH, filename);Â·
        // Security: prevent directory traversal
        if (!filepath.startsWith(FIXTURES_PATH)) {
          res.writeHead(403, { 'Content-Type': 'text/plain' });
          res.end('Forbidden');
          return;
        }Â·
        // Check if file exists
        fs.stat(filepath, (err, stats) => {
          if (err || !stats.isFile()) {
            res.writeHead(404, { 'Content-Type': 'text/plain' });
            res.end('Not Found');
            return;
          }Â·
          // Determine content type
          const ext = path.extname(filepath).toLowerCase();
          const contentTypes = {
            '.html': 'text/html',
            '.js': 'application/javascript',
            '.css': 'text/css',
            '.json': 'application/json',
            '.txt': 'text/plain'
          };
          const contentType = contentTypes[ext] || 'application/octet-stream';Â·
          // Serve file
          fs.readFile(filepath, (err, data) => {
            if (err) {
              res.writeHead(500, { 'Content-Type': 'text/plain' });
              res.end('Internal Server Error');
              return;
            }Â·
            res.writeHead(200, { 'Content-Type': contentType });
            res.end(data);
            log(`Served ${filename} (${data.length} bytes)`);
          });
        });
        return;
      }Â·
      // Root path - show available fixtures
      if (req.url === '/' || req.url === '/fixtures') {
        fs.readdir(FIXTURES_PATH, (err, files) => {
          if (err) {
            res.writeHead(500, { 'Content-Type': 'text/plain' });
            res.end('Error reading fixtures directory');
            return;
          }Â·
          const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Chrome Dev Assist - Test Fixtures</title>
      <style>
        body { font-family: system-ui; margin: 40px; }
        h1 { color: #1a73e8; }
        ul { line-height: 1.8; }
        a { color: #1a73e8; text-decoration: none; }
        a:hover { text-decoration: underline; }
      </style>
    </head>
    <body>
      <h1>Chrome Dev Assist - Test Fixtures</h1>
      <p>Available test fixtures:</p>
      <ul>
        ${files.filter(f => f.endsWith('.html')).map(f =>
          `<li><a href=\"/fixtures/${f}\">${f}</a></li>`
        ).join('\\n    ')}
      </ul>
      <hr>
      <p><small>Server: ${HOST}:${PORT}</small></p>
    </body>
    </html>`;Â·
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end(html);
        });
        return;
      }Â·
      // 404 for other paths
      res.writeHead(404, { 'Content-Type': 'text/plain' });
      res.end('Not Found');
    }Â·
    // Create HTTP server first
    const httpServer = http.createServer((req, res) => {
      handleHttpRequest(req, res);
    });Â·
    // Attach WebSocket server to HTTP server
    const server = new WebSocket.Server({ server: httpServer });Â·
    // Start HTTP server
    httpServer.listen(PORT, HOST, () => {
      console.log(`[Server] HTTP server on http://${HOST}:${PORT}`);
      console.log(`[Server] WebSocket server on ws://${HOST}:${PORT}`);
      console.log(`[Server] Test fixtures at http://${HOST}:${PORT}/fixtures/`);
    });Â·
    server.on('connection', (socket) => {
      log('Client connected');Â·
      socket.on('message', (data) => {
        // REQUIREMENT #1: JSON validation (Persona 6)
        let msg;
        try {
          msg = JSON.parse(data.toString());
        } catch (err) {
          logError('Invalid JSON received:', err.message);
          socket.send(JSON.stringify({
            type: 'error',
            error: {
              message: 'Invalid JSON',
              code: 'PARSE_ERROR'
            }
          }));
          return;
        }Â·
        // Validate message has type field
        if (!msg.type) {
          logError('Message missing type field:', msg);
          socket.send(JSON.stringify({
            type: 'error',
            error: {
              message: 'Message must have type field',
              code: 'INVALID_MESSAGE'
            }
          }));
          return;
        }Â·
        log('Received:', msg.type, msg.id || '');Â·
        // Handle different message types
        if (msg.type === 'register') {
          handleRegister(socket, msg);
        } else if (msg.type === 'command') {
          handleCommand(socket, msg);
        } else if (msg.type === 'response' || msg.type === 'error') {
          handleResponse(socket, msg);
        } else {
          logError('Unknown message type:', msg.type);
          socket.send(JSON.stringify({
            type: 'error',
            error: {
              message: `Unknown message type: ${msg.type}`,
              code: 'UNKNOWN_MESSAGE_TYPE'
            }
          }));
        }
      });Â·
      socket.on('close', () => {
        // Clean up on disconnect
        if (socket === extensionSocket) {
          log('Extension disconnected');
          extensionSocket = null;
          healthManager.setExtensionSocket(null);
        }Â·
        // Remove from API sockets
        for (const [commandId, apiSocket] of apiSockets.entries()) {
          if (apiSocket === socket) {
            apiSockets.delete(commandId);
            log(`API client disconnected (command ${commandId})`);
          }
        }
      });Â·
      socket.on('error', (err) => {
        logError('Socket error:', err.message);
      });
    });Â·
    // REQUIREMENT #3: Port conflict handling (Persona 5)
    httpServer.on('error', (err) => {
      if (err.code === 'EADDRINUSE') {
        console.error('');
        console.error('ERROR: Port 9876 is already in use.');
        console.error('');
        console.error('This usually means:');
        console.error('  1. The server is already running (check other terminals)');
        console.error('  2. Another application is using port 9876');
        console.error('');
        console.error('To fix:');
        console.error('  - Stop the other process using port 9876');
        console.error('  - Or kill existing server: pkill -f websocket-server');
        console.error('');
        process.exit(1);
      } else {
        logError('Server error:', err);
        process.exit(1);
      }
    });Â·
    // WebSocket server error handling
    server.on('error', (err) => {
      logError('WebSocket error:', err);
    });Â·
    console.log('[Server] Ready - waiting for connections');
    if (DEBUG) {
      console.log('[Server] Debug logging enabled');
    }Â·
    /**
     * Handle extension registration
     */
    function handleRegister(socket, msg) {
      // REQUIREMENT #2: Duplicate extension registration (Persona 3, 6)
      if (extensionSocket !== null && extensionSocket !== socket) {
        logError('Extension already registered, rejecting duplicate');
        socket.send(JSON.stringify({
          type: 'error',
          error: {
            message: 'Extension already registered. Only one extension can connect at a time.',
            code: 'DUPLICATE_REGISTRATION'
          }
        }));
        socket.close();
        return;
      }Â·
      extensionSocket = socket;
      healthManager.setExtensionSocket(socket);
      log('Extension registered:', msg.extensionId || '(no ID provided)');
    }Â·
    /**
     * Handle command from API - route to extension
     */
    function handleCommand(socket, msg) {
      // Validate command has ID
      if (!msg.id) {
        logError('Command missing ID field');
        socket.send(JSON.stringify({
          type: 'error',
          error: {
            message: 'Command must have id field',
            code: 'INVALID_COMMAND'
          }
        }));
        return;
      }Â·
      // Store API socket for response routing
      apiSockets.set(msg.id, socket);
      log(`Command ${msg.id} from API`);Â·
      // Check if extension is connected (using health-manager)
      if (!healthManager.isExtensionConnected()) {
        logError('Extension not connected, cannot route command');
        const healthStatus = healthManager.getHealthStatus();
        socket.send(JSON.stringify({
          type: 'error',
          id: msg.id,
          error: {
            message: healthStatus.issues.join(' ') || 'Extension not connected. Please ensure Chrome Dev Assist extension is loaded and running.',
            code: 'EXTENSION_NOT_CONNECTED'
          }
        }));
        apiSockets.delete(msg.id);
        return;
      }Â·
      // Route command to extension
      log(`Routing command ${msg.id} to extension`);
      try {
        extensionSocket.send(JSON.stringify(msg));
      } catch (err) {
        logError(`Failed to send to extension:`, err.message);
        socket.send(JSON.stringify({
          type: 'error',
          id: msg.id,
          error: {
            message: 'Failed to send command to extension',
            code: 'SEND_FAILED'
          }
        }));
        apiSockets.delete(msg.id);
      }
    }Â·
    /**
     * Handle response from extension - route to API
     */
    function handleResponse(socket, msg) {
      // Validate response has ID
      if (!msg.id) {
        logError('Response missing ID field');
        return;
      }Â·
      log(`Response ${msg.id} from extension`);Â·
      // Find API socket for this command
      const apiSocket = apiSockets.get(msg.id);Â·
      if (!apiSocket) {
        logError(`No API socket found for command ${msg.id}`);
        return;
      }Â·
      if (apiSocket.readyState !== WebSocket.OPEN) {
        logError(`API socket for command ${msg.id} is closed`);
        apiSockets.delete(msg.id);
        return;
      }Â·
      // Route response to API
      log(`Routing response ${msg.id} to API`);
      try {
        apiSocket.send(JSON.stringify(msg));
        apiSockets.delete(msg.id); // Clean up
      } catch (err) {
        logError(`Failed to send to API:`, err.message);
        apiSockets.delete(msg.id);
      }
    }Â·
    // Graceful shutdown
    function cleanup() {
      // Remove PID file (Bug #3 fix)
      try {
        if (fs.existsSync(PID_FILE)) {
          fs.unlinkSync(PID_FILE);
          console.log('[Server] PID file removed');
        }
      } catch (err) {
        console.error('[Server] Failed to remove PID file:', err.message);
      }Â·
      // Remove auth token file on shutdown (security cleanup)
      try {
        if (fs.existsSync(TOKEN_FILE)) {
          fs.unlinkSync(TOKEN_FILE);
          console.log('[Server] Auth token file removed');
        }
      } catch (err) {
        console.error('[Server] Failed to remove auth token:', err.message);
      }
    }Â·
    process.on('SIGINT', () => {
      console.log('\\n[Server] Shutting down...');
      server.close(() => {
        httpServer.close(() => {
          cleanup();
          console.log('[Server] Closed');
          process.exit(0);
        });
      });
    });Â·
    process.on('SIGTERM', () => {
      console.log('\\n[Server] Shutting down...');
      server.close(() => {
        httpServer.close(() => {
          cleanup();
          console.log('[Server] Closed');
          process.exit(0);
        });
      });
    });
    "

      120 |
      121 |     it('should have server sending registration-ack', () => {
    > 122 |       expect(serverJs).toContain("type: 'registration-ack'");
          |                        ^
      123 |       expect(serverJs).toContain('Sent registration-ack');
      124 |     });
      125 |   });

      at Object.toContain (tests/integration/improvements-verification.test.js:122:24)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Bug Fixes Verification â€º should have all Improvement 8 bug fixes

    expect(received).toContain(expected) // indexOf

    Expected substring: "clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      128 |     it('should have all Improvement 8 bug fixes', () => {
      129 |       // Timer cleanup on success
    > 130 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on success');
          |                            ^
      131 |
      132 |       // Timer cleanup on error
      133 |       expect(backgroundJs).toContain('clearTimeout(timeoutHandle); // âœ… FIX: Clean up timer on error');

      at Object.toContain (tests/integration/improvements-verification.test.js:130:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Bug Fixes Verification â€º should have all Improvement 7 bug fixes

    expect(received).toContain(expected) // indexOf

    Expected substring: "// âœ… IMPROVEMENT 7 FIX: Clear message queue"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      136 |     it('should have all Improvement 7 bug fixes', () => {
      137 |       // Fix 1: Clear queue on disconnect
    > 138 |       expect(backgroundJs).toContain('// âœ… IMPROVEMENT 7 FIX: Clear message queue');
          |                            ^
      139 |
      140 |       // Fix 2: Error handling during drain
      141 |       expect(backgroundJs).toContain('Failed to send queued message');

      at Object.toContain (tests/integration/improvements-verification.test.js:138:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Bug Fixes Verification â€º should have all Improvement 6 bug fixes

    expect(received).toContain(expected) // indexOf

    Expected substring: "// âœ… IMPROVEMENT 6: Set registration timeout"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      147 |     it('should have all Improvement 6 bug fixes', () => {
      148 |       // Fix 1: Registration timeout
    > 149 |       expect(backgroundJs).toContain('// âœ… IMPROVEMENT 6: Set registration timeout');
          |                            ^
      150 |
      151 |       // Fix 2: Reset state on disconnect
      152 |       expect(backgroundJs).toContain('// âœ… IMPROVEMENT 6 FIX: Reset registration state');

      at Object.toContain (tests/integration/improvements-verification.test.js:149:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Integration Points â€º should have all improvements working together

    expect(received).toContain(expected) // indexOf

    Expected substring: "registrationPending"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      157 |     it('should have all improvements working together', () => {
      158 |       // All three flags should exist
    > 159 |       expect(backgroundJs).toContain('registrationPending');
          |                            ^
      160 |       expect(backgroundJs).toContain('messageQueue');
      161 |       expect(backgroundJs).toContain('withTimeout');
      162 |

      at Object.toContain (tests/integration/improvements-verification.test.js:159:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Code Quality Checks â€º should have logging for all improvements

    expect(received).toContain(expected) // indexOf

    Expected substring: "Registration confirmed by server"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      184 |     it('should have logging for all improvements', () => {
      185 |       // Improvement 6: Registration logs
    > 186 |       expect(backgroundJs).toContain('Registration confirmed by server');
          |                            ^
      187 |       expect(backgroundJs).toContain('Registration timeout');
      188 |
      189 |       // Improvement 7: Queue logs

      at Object.toContain (tests/integration/improvements-verification.test.js:186:28)

  â— Verification: Improvements 6, 7, 8 Implementation â€º Code Quality Checks â€º should have consistent comment markers

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      201 |       const improvement8Markers = (backgroundJs.match(/âœ… IMPROVEMENT 8/g) || []).length;
      202 |
    > 203 |       expect(improvement6Markers).toBeGreaterThan(0);
          |                                   ^
      204 |       expect(improvement7Markers).toBeGreaterThan(0);
      205 |       // Improvement 8 might not have markers in every use
      206 |     });

      at Object.toBeGreaterThan (tests/integration/improvements-verification.test.js:203:35)

FAIL tests/integration/improvements-6-7-8.test.js
  â— Test suite failed to run

    Cannot find module '../../api/index' from 'tests/integration/improvements-6-7-8.test.js'

       9 |  */
      10 |
    > 11 | const ChromeDevAssist = require('../../api/index');
         |                         ^
      12 |
      13 | describe('Integration: Improvements 6, 7, 8', () => {
      14 |   let api;

      at Resolver._throwModNotFoundError (node_modules/jest-resolve/build/resolver.js:427:11)
      at Object.require (tests/integration/improvements-6-7-8.test.js:11:25)

FAIL tests/integration/service-worker-api.test.js
  â— Service Worker API - New Features â€º wakeServiceWorker() â€º should wake the service worker by sending a ping

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      13 |   describe('wakeServiceWorker()', () => {
      14 |     it('should wake the service worker by sending a ping', async () => {
    > 15 |       const result = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      16 |
      17 |       expect(result).toBeDefined();
      18 |       expect(result.success).toBe(true);

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:15:44)

  â— Service Worker API - New Features â€º wakeServiceWorker() â€º should return metadata about the service worker

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      22 |
      23 |     it('should return metadata about the service worker', async () => {
    > 24 |       const result = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      25 |
      26 |       expect(result.extensionId).toBeDefined();
      27 |       expect(result.version).toBeDefined();

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:24:44)

  â— Service Worker API - New Features â€º wakeServiceWorker() â€º should work multiple times in succession

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      29 |
      30 |     it('should work multiple times in succession', async () => {
    > 31 |       const result1 = await chromeDevAssist.wakeServiceWorker();
         |                                             ^
      32 |       const result2 = await chromeDevAssist.wakeServiceWorker();
      33 |       const result3 = await chromeDevAssist.wakeServiceWorker();
      34 |

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:31:45)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should return service worker running status

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      45 |   describe('getServiceWorkerStatus()', () => {
      46 |     it('should return service worker running status', async () => {
    > 47 |       const status = await chromeDevAssist.getServiceWorkerStatus();
         |                                            ^
      48 |
      49 |       expect(status).toBeDefined();
      50 |       expect(typeof status.running).toBe('boolean');

      at Object.getServiceWorkerStatus (tests/integration/service-worker-api.test.js:47:44)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should return true for running and connected after wake

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      54 |     it('should return true for running and connected after wake', async () => {
      55 |       // Wake first to ensure it's running
    > 56 |       await chromeDevAssist.wakeServiceWorker();
         |                             ^
      57 |
      58 |       const status = await chromeDevAssist.getServiceWorkerStatus();
      59 |

      at Object.wakeServiceWorker (tests/integration/service-worker-api.test.js:56:29)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should include metadata when service worker is running

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      63 |
      64 |     it('should include metadata when service worker is running', async () => {
    > 65 |       const status = await chromeDevAssist.getServiceWorkerStatus();
         |                                            ^
      66 |
      67 |       if (status.running) {
      68 |         expect(status.extensionId).toBeDefined();

      at Object.getServiceWorkerStatus (tests/integration/service-worker-api.test.js:65:44)

  â— Service Worker API - New Features â€º getServiceWorkerStatus() â€º should have reasonable response time

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      74 |     it('should have reasonable response time', async () => {
      75 |       const startTime = Date.now();
    > 76 |       await chromeDevAssist.getServiceWorkerStatus();
         |                             ^
      77 |       const endTime = Date.now();
      78 |
      79 |       const responseTime = endTime - startTime;

      at Object.getServiceWorkerStatus (tests/integration/service-worker-api.test.js:76:29)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should return a manual helper object

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      86 |   describe('captureServiceWorkerLogs() - Manual Helper', () => {
      87 |     it('should return a manual helper object', () => {
    > 88 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
         |                                      ^
      89 |
      90 |       expect(helper).toBeDefined();
      91 |       expect(helper.manual).toBe(true);

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:88:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should provide instructions

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      94 |
      95 |     it('should provide instructions', () => {
    > 96 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
         |                                      ^
      97 |
      98 |       expect(helper.instructions).toBeDefined();
      99 |       expect(typeof helper.instructions).toBe('string');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:96:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should provide URLs for manual access

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      103 |
      104 |     it('should provide URLs for manual access', () => {
    > 105 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      106 |
      107 |       expect(helper.urls).toBeDefined();
      108 |       expect(helper.urls.extensions).toBe('chrome://extensions');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:105:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should include the duration in instructions

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      111 |
      112 |     it('should include the duration in instructions', () => {
    > 113 |       const helper = chromeDevAssist.captureServiceWorkerLogs(7500);
          |                                      ^
      114 |
      115 |       expect(helper.instructions).toContain('7500');
      116 |     });

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:113:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should have a printInstructions method

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      117 |
      118 |     it('should have a printInstructions method', () => {
    > 119 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      120 |
      121 |       expect(helper.printInstructions).toBeDefined();
      122 |       expect(typeof helper.printInstructions).toBe('function');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:119:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should provide troubleshooting guidance

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      127 |
      128 |     it('should provide troubleshooting guidance', () => {
    > 129 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      130 |
      131 |       expect(helper.troubleshooting).toBeDefined();
      132 |       expect(typeof helper.troubleshooting).toBe('object');

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:129:38)

  â— Service Worker API - New Features â€º captureServiceWorkerLogs() - Manual Helper â€º should include expected log format information

    TypeError: chromeDevAssist.captureServiceWorkerLogs is not a function

      135 |
      136 |     it('should include expected log format information', () => {
    > 137 |       const helper = chromeDevAssist.captureServiceWorkerLogs(5000);
          |                                      ^
      138 |
      139 |       expect(helper.expectedFormat).toBeDefined();
      140 |       expect(helper.expectedFormat.levels).toBeDefined();

      at Object.captureServiceWorkerLogs (tests/integration/service-worker-api.test.js:137:38)

  â— Service Worker API - New Features â€º External Logging Capability â€º should provide enableExternalLogging function

    expect(received).toBeDefined()

    Received: undefined

      147 |   describe('External Logging Capability', () => {
      148 |     it('should provide enableExternalLogging function', () => {
    > 149 |       expect(chromeDevAssist.enableExternalLogging).toBeDefined();
          |                                                     ^
      150 |       expect(typeof chromeDevAssist.enableExternalLogging).toBe('function');
      151 |     });
      152 |

      at Object.toBeDefined (tests/integration/service-worker-api.test.js:149:53)

  â— Service Worker API - New Features â€º External Logging Capability â€º should enable external logging with endpoint

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      152 |
      153 |     it('should enable external logging with endpoint', async () => {
    > 154 |       const result = await chromeDevAssist.enableExternalLogging({
          |                                            ^
      155 |         endpoint: 'http://localhost:9999/logs',
      156 |         levels: ['error', 'warn']
      157 |       });

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:154:44)

  â— Service Worker API - New Features â€º External Logging Capability â€º should disable external logging

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      164 |     it('should disable external logging', async () => {
      165 |       // Enable first
    > 166 |       await chromeDevAssist.enableExternalLogging({
          |                             ^
      167 |         endpoint: 'http://localhost:9999/logs'
      168 |       });
      169 |

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:166:29)

  â— Service Worker API - New Features â€º External Logging Capability â€º should get external logging status

    TypeError: chromeDevAssist.getExternalLoggingStatus is not a function

      176 |
      177 |     it('should get external logging status', async () => {
    > 178 |       const status = await chromeDevAssist.getExternalLoggingStatus();
          |                                            ^
      179 |
      180 |       expect(status).toBeDefined();
      181 |       expect(typeof status.enabled).toBe('boolean');

      at Object.getExternalLoggingStatus (tests/integration/service-worker-api.test.js:178:44)

  â— Service Worker API - New Features â€º External Logging Capability â€º should reject invalid endpoint URLs

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      184 |     it('should reject invalid endpoint URLs', async () => {
      185 |       await expect(
    > 186 |         chromeDevAssist.enableExternalLogging({ endpoint: 'not-a-url' })
          |                         ^
      187 |       ).rejects.toThrow();
      188 |     }, 10000);
      189 |

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:186:25)

  â— Service Worker API - New Features â€º External Logging Capability â€º should accept valid log levels only

    TypeError: chromeDevAssist.enableExternalLogging is not a function

      189 |
      190 |     it('should accept valid log levels only', async () => {
    > 191 |       const result = await chromeDevAssist.enableExternalLogging({
          |                                            ^
      192 |         endpoint: 'http://localhost:9999/logs',
      193 |         levels: ['log', 'error', 'warn', 'info', 'debug']
      194 |       });

      at Object.enableExternalLogging (tests/integration/service-worker-api.test.js:191:44)

FAIL tests/unit/level4-reload-cdp.test.js
  â— Test suite failed to run

    Jest encountered an unexpected token

    Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.

    Out of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.

    By default "node_modules" folder is ignored by transformers.

    Here's what you can do:
     â€¢ If you are trying to use ECMAScript Modules, see https://jestjs.io/docs/ecmascript-modules for how to enable it.
     â€¢ If you are trying to use TypeScript, see https://jestjs.io/docs/getting-started#using-typescript
     â€¢ To have some of your "node_modules" files transformed, you can specify a custom "transformIgnorePatterns" in your config.
     â€¢ If you need a custom transformation specify a "transform" option in your config.
     â€¢ If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the "moduleNameMapper" config option.

    You'll find more details and examples of these config options in the docs:
    https://jestjs.io/docs/configuration
    For information about custom transformations, see:
    https://jestjs.io/docs/code-transformation

    Details:

    SyntaxError: /Users/gadievron/Documents/Claude Code/chrome-dev-assist/tests/unit/level4-reload-cdp.test.js: Missing semicolon. (32:6)

      30 |       // const result = await level4ReloadCDP(TEST_EXTENSION_ID, { port: CDP_PORT });
      31 |       // expect(result.method).toBe('cdp');
    > 32 | - will fail when implementing
         |       ^
      33 |     });
      34 |
      35 |     // TODO: INCOMPLETE - CDP testing requires debug mode

      at constructor (node_modules/@babel/parser/src/parse-error.ts:95:45)
      at Parser.toParseError [as raise] (node_modules/@babel/parser/src/tokenizer/index.ts:1507:19)
      at Parser.raise [as semicolon] (node_modules/@babel/parser/src/parser/util.ts:149:10)
      at Parser.semicolon [as parseExpressionStatement] (node_modules/@babel/parser/src/parser/statement.ts:1363:10)
      at Parser.parseExpressionStatement [as parseStatementContent] (node_modules/@babel/parser/src/parser/statement.ts:702:19)
      at Parser.parseStatementContent [as parseStatementLike] (node_modules/@babel/parser/src/parser/statement.ts:482:17)
      at Parser.parseStatementLike [as parseStatementListItem] (node_modules/@babel/parser/src/parser/statement.ts:431:17)
      at Parser.parseStatementListItem [as parseBlockOrModuleBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1444:16)
      at Parser.parseBlockOrModuleBlockBody [as parseBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1417:10)
      at Parser.parseBlockBody [as parseBlock] (node_modules/@babel/parser/src/parser/statement.ts:1385:10)
      at Parser.parseBlock [as parseFunctionBody] (node_modules/@babel/parser/src/parser/expression.ts:2626:24)
      at Parser.parseFunctionBody [as parseArrowExpression] (node_modules/@babel/parser/src/parser/expression.ts:2563:10)
      at Parser.parseArrowExpression [as parseAsyncArrowFromCallExpression] (node_modules/@babel/parser/src/parser/expression.ts:1067:10)
      at Parser.parseAsyncArrowFromCallExpression [as parseCoverCallAndAsyncArrowHead] (node_modules/@babel/parser/src/parser/expression.ts:942:27)
      at Parser.parseCoverCallAndAsyncArrowHead [as parseSubscript] (node_modules/@babel/parser/src/parser/expression.ts:804:19)
      at Parser.parseSubscript [as parseSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:763:19)
      at Parser.parseSubscripts [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:748:17)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at parseMaybeAssign (node_modules/@babel/parser/src/parser/expression.ts:257:12)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3202:12)
      at Parser.allowInAnd [as parseMaybeAssignAllowIn] (node_modules/@babel/parser/src/parser/expression.ts:256:17)
      at Parser.parseMaybeAssignAllowIn [as parseMaybeAssignAllowInOrVoidPattern] (node_modules/@babel/parser/src/parser/expression.ts:3316:17)
      at Parser.parseMaybeAssignAllowInOrVoidPattern [as parseExprListItem] (node_modules/@babel/parser/src/parser/expression.ts:2798:18)
      at Parser.parseExprListItem [as parseCallExpressionArguments] (node_modules/@babel/parser/src/parser/expression.ts:1042:14)
      at Parser.parseCallExpressionArguments [as parseCoverCallAndAsyncArrowHead] (node_modules/@babel/parser/src/parser/expression.ts:922:29)
      at Parser.parseCoverCallAndAsyncArrowHead [as parseSubscript] (node_modules/@babel/parser/src/parser/expression.ts:804:19)
      at Parser.parseSubscript [as parseSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:763:19)
      at Parser.parseSubscripts [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:748:17)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at Parser.parseMaybeAssign [as parseExpressionBase] (node_modules/@babel/parser/src/parser/expression.ts:226:23)
      at parseExpressionBase (node_modules/@babel/parser/src/parser/expression.ts:217:39)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3197:16)
      at Parser.allowInAnd [as parseExpression] (node_modules/@babel/parser/src/parser/expression.ts:217:17)
      at Parser.parseExpression [as parseStatementContent] (node_modules/@babel/parser/src/parser/statement.ts:688:23)
      at Parser.parseStatementContent [as parseStatementLike] (node_modules/@babel/parser/src/parser/statement.ts:482:17)
      at Parser.parseStatementLike [as parseStatementListItem] (node_modules/@babel/parser/src/parser/statement.ts:431:17)
      at Parser.parseStatementListItem [as parseBlockOrModuleBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1444:16)
      at Parser.parseBlockOrModuleBlockBody [as parseBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1417:10)
      at Parser.parseBlockBody [as parseBlock] (node_modules/@babel/parser/src/parser/statement.ts:1385:10)
      at Parser.parseBlock [as parseFunctionBody] (node_modules/@babel/parser/src/parser/expression.ts:2626:24)
      at Parser.parseFunctionBody [as parseArrowExpression] (node_modules/@babel/parser/src/parser/expression.ts:2563:10)
      at Parser.parseArrowExpression [as parseParenAndDistinguishExpression] (node_modules/@babel/parser/src/parser/expression.ts:1847:12)
      at Parser.parseParenAndDistinguishExpression [as parseExprAtom] (node_modules/@babel/parser/src/parser/expression.ts:1170:21)
      at Parser.parseExprAtom [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:742:23)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at parseMaybeAssign (node_modules/@babel/parser/src/parser/expression.ts:257:12)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3202:12)
      at Parser.allowInAnd [as parseMaybeAssignAllowIn] (node_modules/@babel/parser/src/parser/expression.ts:256:17)
      at Parser.parseMaybeAssignAllowIn [as parseMaybeAssignAllowInOrVoidPattern] (node_modules/@babel/parser/src/parser/expression.ts:3316:17)
      at Parser.parseMaybeAssignAllowInOrVoidPattern [as parseExprListItem] (node_modules/@babel/parser/src/parser/expression.ts:2798:18)
      at Parser.parseExprListItem [as parseCallExpressionArguments] (node_modules/@babel/parser/src/parser/expression.ts:1042:14)
      at Parser.parseCallExpressionArguments [as parseCoverCallAndAsyncArrowHead] (node_modules/@babel/parser/src/parser/expression.ts:922:29)
      at Parser.parseCoverCallAndAsyncArrowHead [as parseSubscript] (node_modules/@babel/parser/src/parser/expression.ts:804:19)
      at Parser.parseSubscript [as parseSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:763:19)
      at Parser.parseSubscripts [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:748:17)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at Parser.parseMaybeAssign [as parseExpressionBase] (node_modules/@babel/parser/src/parser/expression.ts:226:23)
      at parseExpressionBase (node_modules/@babel/parser/src/parser/expression.ts:217:39)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3197:16)
      at Parser.allowInAnd [as parseExpression] (node_modules/@babel/parser/src/parser/expression.ts:217:17)
      at Parser.parseExpression [as parseStatementContent] (node_modules/@babel/parser/src/parser/statement.ts:688:23)
      at Parser.parseStatementContent [as parseStatementLike] (node_modules/@babel/parser/src/parser/statement.ts:482:17)
      at Parser.parseStatementLike [as parseStatementListItem] (node_modules/@babel/parser/src/parser/statement.ts:431:17)
      at Parser.parseStatementListItem [as parseBlockOrModuleBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1444:16)
      at Parser.parseBlockOrModuleBlockBody [as parseBlockBody] (node_modules/@babel/parser/src/parser/statement.ts:1417:10)
      at Parser.parseBlockBody [as parseBlock] (node_modules/@babel/parser/src/parser/statement.ts:1385:10)
      at Parser.parseBlock [as parseFunctionBody] (node_modules/@babel/parser/src/parser/expression.ts:2626:24)
      at Parser.parseFunctionBody [as parseArrowExpression] (node_modules/@babel/parser/src/parser/expression.ts:2563:10)
      at Parser.parseArrowExpression [as parseParenAndDistinguishExpression] (node_modules/@babel/parser/src/parser/expression.ts:1847:12)
      at Parser.parseParenAndDistinguishExpression [as parseExprAtom] (node_modules/@babel/parser/src/parser/expression.ts:1170:21)
      at Parser.parseExprAtom [as parseExprSubscripts] (node_modules/@babel/parser/src/parser/expression.ts:742:23)
      at Parser.parseExprSubscripts [as parseUpdate] (node_modules/@babel/parser/src/parser/expression.ts:721:21)
      at Parser.parseUpdate [as parseMaybeUnary] (node_modules/@babel/parser/src/parser/expression.ts:683:23)
      at Parser.parseMaybeUnary [as parseMaybeUnaryOrPrivate] (node_modules/@babel/parser/src/parser/expression.ts:417:14)
      at Parser.parseMaybeUnaryOrPrivate [as parseExprOps] (node_modules/@babel/parser/src/parser/expression.ts:429:23)
      at Parser.parseExprOps [as parseMaybeConditional] (node_modules/@babel/parser/src/parser/expression.ts:384:23)
      at Parser.parseMaybeConditional [as parseMaybeAssign] (node_modules/@babel/parser/src/parser/expression.ts:301:21)
      at parseMaybeAssign (node_modules/@babel/parser/src/parser/expression.ts:257:12)
      at Parser.callback [as allowInAnd] (node_modules/@babel/parser/src/parser/expression.ts:3202:12)
      at Parser.allowInAnd [as parseMaybeAssignAllowIn] (node_modules/@babel/parser/src/parser/expression.ts:256:17)

FAIL tests/integration/screenshot-security.test.js
  â— Screenshot Security Restrictions â€º Allowed: localhost:9876 only â€º should allow screenshots from localhost:9876

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Blocked: External websites â€º should block screenshots from google.com

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Blocked: External websites â€º should block screenshots from github.com

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Blocked: Different localhost ports â€º should block screenshots from localhost:3000

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Security Error Messages â€º should provide clear error message with allowed origin

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Screenshot Security Restrictions â€º Security Principle: Least Privilege â€º should document why restriction exists

    expect(received).toBe(expected) // Object.is equality

    Expected: "function"
    Received: "undefined"

      148 |
      149 |       // Real assertion: Verify security constants are defined
    > 150 |       expect(typeof chromeDevAssist.captureScreenshot).toBe('function');
          |                                                        ^
      151 |     });
      152 |   });
      153 | });

      at Object.toBe (tests/integration/screenshot-security.test.js:150:56)

FAIL tests/integration/service-worker-lifecycle.test.js
  â— Keep-Alive Mechanisms â€º WebSocket Ping Mechanism â€º should send ping messages when connection is active

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      17 |     it('should send ping messages when connection is active', async () => {
      18 |       // Wake service worker to ensure connection
    > 19 |       const status = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      20 |       expect(status.success).toBe(true);
      21 |       expect(status.running).toBe(true);
      22 |

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:19:44)

  â— Keep-Alive Mechanisms â€º WebSocket Ping Mechanism â€º should reconnect if connection lost during keep-alive

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      36 |       // In production, if WebSocket closes, the alarm will trigger reconnection
      37 |
    > 38 |       const status = await chromeDevAssist.getServiceWorkerStatus();
         |                                            ^
      39 |       expect(status.running).toBe(true);
      40 |     }, 10000);
      41 |   });

      at Object.getServiceWorkerStatus (tests/integration/service-worker-lifecycle.test.js:38:44)

  â— Keep-Alive Mechanisms â€º Connection Resilience â€º should maintain connection for extended periods

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      44 |     it('should maintain connection for extended periods', async () => {
      45 |       // Verify connection persists beyond service worker idle timeout (30s)
    > 46 |       const initialStatus = await chromeDevAssist.wakeServiceWorker();
         |                                                   ^
      47 |       expect(initialStatus.success).toBe(true);
      48 |
      49 |       const initialTime = initialStatus.timestamp;

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:46:51)

  â— Keep-Alive Mechanisms â€º Connection Resilience â€º should handle multiple rapid status checks

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      63 |       // Rapid API calls should not break connection
      64 |       const results = await Promise.all([
    > 65 |         chromeDevAssist.getServiceWorkerStatus(),
         |                         ^
      66 |         chromeDevAssist.getServiceWorkerStatus(),
      67 |         chromeDevAssist.getServiceWorkerStatus(),
      68 |         chromeDevAssist.wakeServiceWorker(),

      at Object.getServiceWorkerStatus (tests/integration/service-worker-lifecycle.test.js:65:25)

  â— Keep-Alive Mechanisms â€º Service Worker Lifecycle â€º should have alarm configured for keep-alive

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      83 |       // which implies alarms are working
      84 |
    > 85 |       const status = await chromeDevAssist.wakeServiceWorker();
         |                                            ^
      86 |       expect(status.success).toBe(true);
      87 |
      88 |       // If alarm wasn't configured, service worker would be idle

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:85:44)

  â— Keep-Alive Mechanisms â€º Service Worker Lifecycle â€º should respond immediately to wake requests

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

       96 |     it('should respond immediately to wake requests', async () => {
       97 |       const startTime = Date.now();
    >  98 |       const result = await chromeDevAssist.wakeServiceWorker();
          |                                            ^
       99 |       const endTime = Date.now();
      100 |
      101 |       const responseTime = endTime - startTime;

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:98:44)

  â— Keep-Alive Mechanisms â€º Error Recovery â€º should recover from temporary disconnections

    TypeError: chromeDevAssist.wakeServiceWorker is not a function

      110 |     it('should recover from temporary disconnections', async () => {
      111 |       // Initial connection
    > 112 |       const status1 = await chromeDevAssist.wakeServiceWorker();
          |                                             ^
      113 |       expect(status1.success).toBe(true);
      114 |
      115 |       // Simulate work

      at Object.wakeServiceWorker (tests/integration/service-worker-lifecycle.test.js:112:45)

  â— Keep-Alive Mechanisms â€º Error Recovery â€º should handle server restart gracefully

    TypeError: chromeDevAssist.getServiceWorkerStatus is not a function

      126 |       // If server is down, API will auto-start it
      127 |
    > 128 |       const status = await chromeDevAssist.getServiceWorkerStatus();
          |                                            ^
      129 |       expect(status).toBeDefined();
      130 |
      131 |       // Even if connection was lost, it should recover

      at Object.getServiceWorkerStatus (tests/integration/service-worker-lifecycle.test.js:128:44)

FAIL tests/api/index.test.js
  â— Chrome Dev Assist API â€º reloadAndCapture() â€º should return console logs after reload

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º reloadAndCapture() â€º should accept options for duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º reload() â€º should reload extension without capturing logs

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º captureLogs() â€º should capture console logs for specified duration

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Chrome Dev Assist API â€º captureLogs() â€º should default to 5000ms if no duration specified

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

FAIL tests/integration/resource-cleanup.test.js
  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should detect Chrome test instances

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh 2>&1 | grep -i chrome



  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should detect server processes

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh 2>&1 | grep -i server



  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should detect debug logging in code

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh 2>&1 | grep -i debug



  â— Resource Cleanup Verification â€º Cleanup Script Functionality â€º should verify cleanup completion

    Command failed: bash /Users/gadievron/Documents/Claude Code/chrome-dev-assist/scripts/cleanup-test-session.sh
    bash: /Users/gadievron/Documents/Claude: No such file or directory



  â— Resource Cleanup Verification â€º Process Detection â€º should detect background test processes

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: undefined

      104 |       } catch (err) {
      105 |         // No processes found (grep returns non-zero) - this is good
    > 106 |         expect(err.code).toBe(1);
          |                          ^
      107 |       }
      108 |     });
      109 |   });

      at Object.toBe (tests/integration/resource-cleanup.test.js:106:26)

  â— Resource Cleanup Verification â€º PID File Management â€º should clean up PID file when server stops

    ReferenceError: fail is not defined

      170 |         } catch (err) {
      171 |           // Process doesn't exist but PID file does - cleanup needed
    > 172 |           fail(`Stale PID file found. Process ${pid} not running. Run cleanup script.`);
          |           ^
      173 |         }
      174 |       }
      175 |     });

      at Object.fail (tests/integration/resource-cleanup.test.js:172:11)

  â— Resource Cleanup Verification â€º Verification After Test Run â€º should verify no leaked resources after test suite

    ReferenceError: fail is not defined

      223 |           '\n   Run: ./scripts/cleanup-test-session.sh';
      224 |
    > 225 |         fail(message);
          |         ^
      226 |       }
      227 |
      228 |       expect(issues).toEqual([]);

      at Object.fail (tests/integration/resource-cleanup.test.js:225:9)

FAIL tests/unit/console-capture-race-condition.test.js
  â— Console Capture Race Condition Fix â€º should capture console messages from inline <head> scripts

    Dangerous URL protocol not allowed: data

      398 |   const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      399 |   if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
    > 400 |     throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
          |           ^
      401 |   }
      402 |
      403 |   // Security: Validate duration parameter

      at handleOpenUrlCommand (extension/background.js:400:11)
      at Object.handleOpenUrlCommand (tests/unit/console-capture-race-condition.test.js:80:26)

  â— Console Capture Race Condition Fix â€º should register capture BEFORE creating tab

    expect(received).toBeLessThan(expected)

    Matcher error: received value must be a number or bigint

    Received has value: undefined

      125 |
      126 |     // ASSERTION: Capture registered BEFORE tab created
    > 127 |     expect(captureTimestamps[0]).toBeLessThan(tabTimestamps[0]);
          |                                  ^
      128 |   });
      129 |
      130 |   /**

      at Object.toBeLessThan (tests/unit/console-capture-race-condition.test.js:127:34)

  â— Console Capture Race Condition Fix â€º should buffer messages that arrive before tab ID is set

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      170 |
      171 |     // ASSERTION: Buffered message should be in final logs
    > 172 |     expect(result.consoleLogs.some(log => log.message === 'EARLY-MESSAGE')).toBe(true);
          |                                                                             ^
      173 |   });
      174 |
      175 |   /**

      at Object.toBe (tests/unit/console-capture-race-condition.test.js:172:77)

  â— Console Capture Race Condition Fix â€º should capture console from fast-loading local file

    Dangerous URL protocol not allowed: file

      398 |   const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      399 |   if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
    > 400 |     throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
          |           ^
      401 |   }
      402 |
      403 |   // Security: Validate duration parameter

      at handleOpenUrlCommand (extension/background.js:400:11)
      at Object.handleOpenUrlCommand (tests/unit/console-capture-race-condition.test.js:312:26)

FAIL tests/crash-recovery.test.js
  â— Test suite failed to run

    Jest worker encountered 4 child process exceptions, exceeding retry limit

      at ChildProcessWorker.initialize (node_modules/jest-worker/build/workers/ChildProcessWorker.js:181:21)

FAIL tests/integration/level4-reload.test.js (5.117 s)
  â— Level 4 Reload - Integration Tests â€º Code Reload Verification â€º should reload code from disk using toggle method

    thrown: "Exceeded timeout of 5000 ms for a test.
    Add a timeout value to this test to increase the timeout, if this is a long-running test. See https://jestjs.io/docs/api#testname-fn-timeout."

      72 |     });
      73 |
    > 74 |     it('should reload code from disk using toggle method', async () => {
         |     ^
      75 |       // This test works with normal Chrome (no debug mode required)
      76 |
      77 |       // 1. Get current extension info

      at it (tests/integration/level4-reload.test.js:74:5)
      at describe (tests/integration/level4-reload.test.js:35:3)
      at Object.describe (tests/integration/level4-reload.test.js:16:1)

  â— Level 4 Reload - Integration Tests â€º Code Reload Verification â€º should auto-detect and use best available method

    TypeError: chromeDevAssist.level4Reload is not a function

      108 |       // Test auto-detection logic
      109 |
    > 110 |       const result = await chromeDevAssist.level4Reload(TEST_EXTENSION_ID);
          |                                            ^
      111 |
      112 |       // Should use either CDP or toggle depending on what's available
      113 |       expect(result.reloaded).toBe(true);

      at Object.level4Reload (tests/integration/level4-reload.test.js:110:44)

  â— Level 4 Reload - Integration Tests â€º Service Worker Restart Verification â€º should restart service worker completely

    Extension not connected

      245 |         } else if (response.type === 'error') {
      246 |           ws.close();
    > 247 |           reject(new Error(response.error.message || 'Command failed'));
          |                  ^
      248 |         }
      249 |       });
      250 |

      at WebSocket.<anonymous> (claude-code/index.js:247:18)
      at Receiver.receiverOnMessage (node_modules/ws/lib/websocket.js:1220:20)
      at Receiver.dataMessage (node_modules/ws/lib/receiver.js:596:14)
      at Receiver.getData (node_modules/ws/lib/receiver.js:496:10)
      at Receiver.startLoop (node_modules/ws/lib/receiver.js:167:16)
      at Receiver._write (node_modules/ws/lib/receiver.js:94:10)
      at Socket.socketOnData (node_modules/ws/lib/websocket.js:1355:35)

  â— Level 4 Reload - Integration Tests â€º Phase 0 Registration After Reload â€º should re-register with Phase 0 metadata after reload

    TypeError: chromeDevAssist.level4Reload is not a function

      150 |     it('should re-register with Phase 0 metadata after reload', async () => {
      151 |       // 1. Perform level4Reload
    > 152 |       await chromeDevAssist.level4Reload(TEST_EXTENSION_ID);
          |                             ^
      153 |
      154 |       // 2. Wait for reconnection and re-registration
      155 |       await new Promise(r => setTimeout(r, 3000));

      at Object.level4Reload (tests/integration/level4-reload.test.js:152:29)

  â— Level 4 Reload - Integration Tests â€º Error Recovery â€º should handle reload failure gracefully

    TypeError: chromeDevAssist.level4Reload is not a function

      173 |       // Test with invalid extension ID
      174 |       await expect(
    > 175 |         chromeDevAssist.level4Reload('invalid-extension-id')
          |                         ^
      176 |       ).rejects.toThrow();
      177 |     });
      178 |

      at Object.level4Reload (tests/integration/level4-reload.test.js:175:25)

  â— Level 4 Reload - Integration Tests â€º Performance â€º should complete reload in under 5 seconds

    TypeError: chromeDevAssist.level4Reload is not a function

      193 |       const startTime = Date.now();
      194 |
    > 195 |       await chromeDevAssist.level4Reload(TEST_EXTENSION_ID);
          |                             ^
      196 |
      197 |       const duration = Date.now() - startTime;
      198 |       expect(duration).toBeLessThan(5000);

      at Object.level4Reload (tests/integration/level4-reload.test.js:195:29)

FAIL tests/integration/console-capture-refactored.test.js (6.595 s)
  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º reloadAndCapture() uses ConsoleCapture class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º captureLogs() uses ConsoleCapture class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º openUrl() with captureConsole uses class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Capture Functions â€º reloadTab() with captureConsole uses class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Tab-Specific vs Global Captures â€º Tab-specific capture only captures from that tab

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Tab-Specific vs Global Captures â€º Global capture (tabId=null) captures from all tabs

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º 10K Log Limit Enforcement â€º 10K log limit enforced via class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º 10K Log Limit Enforcement â€º Warning added at limit via class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º 10K Log Limit Enforcement â€º Logs dropped after limit via class

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Cleanup Functions â€º Periodic cleanup runs via consoleCapture.cleanupStale()

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Cleanup Functions â€º Error cleanup calls consoleCapture.cleanup()

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Cleanup Functions â€º getCommandLogs cleanup calls consoleCapture.cleanup()

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

  â— ConsoleCapture Integration - Refactored background.js â€º Multiple Captures â€º Multiple captures can coexist for same tab

    Extension not loaded

      42 |     } catch (err) {
      43 |       console.error('âŒ Extension not loaded. Please load extension first.');
    > 44 |       throw new Error('Extension not loaded');
         |             ^
      45 |     }
      46 |   });
      47 |

      at Object.<anonymous> (tests/integration/console-capture-refactored.test.js:44:13)

FAIL tests/integration/reconnection-behavior.test.js (30.115 s)
  â— Extension Reconnection Behavior (ISSUE-012) â€º Server Restart Scenario â€º should detect when server is restarted

    Server failed to start within timeout

      45 |       setTimeout(() => {
      46 |         if (!started) {
    > 47 |           reject(new Error('Server failed to start within timeout'));
         |                  ^
      48 |         }
      49 |       }, 10000);
      50 |     });

      at Timeout._onTimeout (tests/integration/reconnection-behavior.test.js:47:18)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Server Restart Scenario â€º should reconnect extension after server restart

    Server failed to start within timeout

      45 |       setTimeout(() => {
      46 |         if (!started) {
    > 47 |           reject(new Error('Server failed to start within timeout'));
         |                  ^
      48 |         }
      49 |       }, 10000);
      50 |     });

      at Timeout._onTimeout (tests/integration/reconnection-behavior.test.js:47:18)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Reconnection Logic Verification â€º should verify ws.onclose is called when server stops

    expect(received).toContain(expected) // indexOf

    Expected substring: "scheduleReconnect"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      274 |
      275 |       // Verify scheduleReconnect is called
    > 276 |       expect(backgroundJs).toContain('scheduleReconnect');
          |                            ^
      277 |
      278 |       // Verify state is reset
      279 |       expect(backgroundJs).toContain('isRegistered = false');

      at Object.toContain (tests/integration/reconnection-behavior.test.js:276:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Reconnection Logic Verification â€º should verify scheduleReconnect uses exponential backoff

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      293 |         (backgroundJs.includes('Math.pow(2,') || backgroundJs.includes('2 **'));
      294 |
    > 295 |       expect(hasExponentialBackoff).toBe(true);
          |                                     ^
      296 |     });
      297 |
      298 |     it('should verify reconnection is scheduled after disconnect', () => {

      at Object.toBe (tests/integration/reconnection-behavior.test.js:295:37)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Reconnection Logic Verification â€º should verify reconnection is scheduled after disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "function scheduleReconnect()"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      303 |
      304 |       // Verify scheduleReconnect is defined
    > 305 |       expect(backgroundJs).toContain('function scheduleReconnect()');
          |                            ^
      306 |
      307 |       // Verify it's called in onclose
      308 |       const oncloseIndex = backgroundJs.indexOf('ws.onclose');

      at Object.toContain (tests/integration/reconnection-behavior.test.js:305:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Connection State Management â€º should verify isConnecting flag prevents multiple connections

    expect(received).toContain(expected) // indexOf

    Expected substring: "let isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      321 |
      322 |       // Verify isConnecting flag exists and is used
    > 323 |       expect(backgroundJs).toContain('let isConnecting = false');
          |                            ^
      324 |       expect(backgroundJs).toContain('if (isConnecting)');
      325 |       expect(backgroundJs).toContain('isConnecting = true');
      326 |       expect(backgroundJs).toContain('isConnecting = false');

      at Object.toContain (tests/integration/reconnection-behavior.test.js:323:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Connection State Management â€º should verify connection state is properly reset on disconnect

    expect(received).toContain(expected) // indexOf

    Expected substring: "isConnecting = false"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      334 |
      335 |       // In onclose, verify state is reset
    > 336 |       expect(backgroundJs).toContain('isConnecting = false');
          |                            ^
      337 |       expect(backgroundJs).toContain('ws = null');
      338 |     });
      339 |   });

      at Object.toContain (tests/integration/reconnection-behavior.test.js:336:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Exponential Backoff Implementation â€º should verify reconnection attempts are tracked

    expect(received).toContain(expected) // indexOf

    Expected substring: "reconnectAttempts"
    Received string:    "/**
     * Chrome Dev Assist - Background Service Worker
     * Handles native messaging and extension testing operations
     */Â·
    // State - command-specific capture to avoid race conditions
    // Map<commandId, {logs: Array, active: boolean, timeout: number, endTime: number, tabId: number|null}>
    const captureState = new Map();Â·
    // Index for fast O(1) lookup by tabId to prevent race conditions in high-concurrency scenarios
    // Map<tabId, Set<commandId>> - tracks which command IDs are capturing for each tab
    const capturesByTab = new Map();Â·
    // Memory leak prevention
    const MAX_LOGS_PER_CAPTURE = 10000; // Maximum logs per command to prevent memory exhaustion
    const CLEANUP_INTERVAL_MS = 60000;   // Run cleanup every 60 seconds
    const MAX_CAPTURE_AGE_MS = 300000;   // Keep captures for max 5 minutes after completionÂ·
    console.log('[ChromeDevAssist] Background service worker started');Â·
    // Periodic cleanup of old captures to prevent memory leaks
    setInterval(() => {
      const now = Date.now();
      let cleanedCount = 0;Â·
      for (const [commandId, state] of captureState.entries()) {
        // Clean up inactive captures older than MAX_CAPTURE_AGE_MS
        if (!state.active && state.endTime && (now - state.endTime) > MAX_CAPTURE_AGE_MS) {
          cleanupCapture(commandId); // Use consolidated cleanup helper
          cleanedCount++;
        }
      }Â·
      if (cleanedCount > 0) {
        console.log(`[ChromeDevAssist] Cleaned up ${cleanedCount} old capture(s). Active captures: ${captureState.size}`);
      }
    }, CLEANUP_INTERVAL_MS);Â·
    // Register console capture script to run in MAIN world at document_start
    // This ensures it runs BEFORE page scripts and can intercept console.log
    //
    // IMPORTANT: Check if already registered to prevent \"Duplicate script ID\" errors
    // Chrome service workers can restart, causing re-registration attempts
    async function registerConsoleCaptureScript() {
      try {
        // Check if script is already registered
        const registered = await chrome.scripting.getRegisteredContentScripts();
        const alreadyExists = registered.some(script => script.id === 'console-capture');Â·
        if (alreadyExists) {
          console.log('[ChromeDevAssist] Console capture script already registered, skipping');
          return;
        }Â·
        // Register the script
        await chrome.scripting.registerContentScripts([{
          id: 'console-capture',
          matches: ['<all_urls>'],
          js: ['inject-console-capture.js'],
          runAt: 'document_start',
          world: 'MAIN',
          allFrames: true
        }]);
        console.log('[ChromeDevAssist] Console capture script registered in MAIN world');
      } catch (err) {
        // If duplicate error despite our check, unregister and retry
        if (err.message && err.message.includes('Duplicate')) {
          console.log('[ChromeDevAssist] Duplicate detected, unregistering and retrying...');
          await chrome.scripting.unregisterContentScripts({ ids: ['console-capture'] });
          await chrome.scripting.registerContentScripts([{
            id: 'console-capture',
            matches: ['<all_urls>'],
            js: ['inject-console-capture.js'],
            runAt: 'document_start',
            world: 'MAIN',
            allFrames: true
          }]);
          console.log('[ChromeDevAssist] Console capture script re-registered successfully');
        } else {
          console.error('[ChromeDevAssist] Failed to register console capture script:', err);
        }
      }
    }Â·
    // Call registration function (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && chrome.scripting) {
      registerConsoleCaptureScript();
    }Â·
    // WebSocket connection to server
    let ws = null;Â·
    function connectToServer() {
      ws = new WebSocket('ws://localhost:9876');Â·
      ws.onopen = () => {
        console.log('[ChromeDevAssist] Connected to server');Â·
        // Register as extension
        ws.send(JSON.stringify({
          type: 'register',
          client: 'extension',
          extensionId: chrome.runtime.id
        }));
      };Â·
      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);Â·
        // Only process commands
        if (message.type !== 'command') {
          return;
        }Â·
        console.log('[ChromeDevAssist] Received command:', message.command?.type);Â·
        try {
          // Validate command
          if (!message.command || !message.command.type) {
            throw new Error('Invalid command: missing type');
          }Â·
          let result;Â·
          // Process command based on type
          switch (message.command.type) {
            case 'reload':
              result = await handleReloadCommand(message.id, message.command.params);
              break;Â·
            case 'capture':
              result = await handleCaptureCommand(message.id, message.command.params);
              break;Â·
            case 'getAllExtensions':
              result = await handleGetAllExtensionsCommand(message.id, message.command.params);
              break;Â·
            case 'getExtensionInfo':
              result = await handleGetExtensionInfoCommand(message.id, message.command.params);
              break;Â·
            case 'openUrl':
              result = await handleOpenUrlCommand(message.id, message.command.params);
              break;Â·
            case 'reloadTab':
              result = await handleReloadTabCommand(message.id, message.command.params);
              break;Â·
            case 'closeTab':
              result = await handleCloseTabCommand(message.id, message.command.params);
              break;Â·
            default:
              throw new Error(`Unknown command type: ${message.command.type}`);
          }Â·
          // Send success response
          ws.send(JSON.stringify({
            type: 'response',
            id: message.id,
            data: result
          }));Â·
        } catch (error) {
          console.error('[ChromeDevAssist] Command failed:', error);Â·
          // Clean up any capture state on error using consolidated helper
          if (message.id && captureState.has(message.id)) {
            cleanupCapture(message.id);
          }Â·
          // Send error response
          ws.send(JSON.stringify({
            type: 'error',
            id: message.id,
            error: {
              message: error.message,
              code: error.code || 'EXTENSION_ERROR'
            }
          }));
        }
      };Â·
      ws.onerror = (err) => {
        console.error('[ChromeDevAssist] WebSocket error:', err);
      };Â·
      ws.onclose = () => {
        console.log('[ChromeDevAssist] Disconnected from server, reconnecting in 1s...');
        ws = null;
        setTimeout(connectToServer, 1000);
      };
    }Â·
    // Connect on startup (only in Chrome extension context)
    if (typeof chrome !== 'undefined' && typeof WebSocket !== 'undefined') {
      connectToServer();
    }Â·
    /**
     * Handle reload command
     * Disables and re-enables the target extension, optionally capturing console logs
     */
    async function handleReloadCommand(commandId, params) {
      const { extensionId, captureConsole = false, duration = 5000 } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading extension:', extensionId);Â·
      // Get extension info first
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      if (!extension) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      // Check if we can manage this extension
      if (extension.id === chrome.runtime.id) {
        throw new Error('Cannot reload self');
      }Â·
      // Disable extension
      try {
        await chrome.management.setEnabled(extensionId, false);
      } catch (err) {
        throw new Error(`Failed to disable extension: ${err.message}`);
      }Â·
      // Wait a bit for clean disable
      await sleep(100);Â·
      // Re-enable extension
      try {
        await chrome.management.setEnabled(extensionId, true);
      } catch (err) {
        throw new Error(`Failed to enable extension: ${err.message}`);
      }Â·
      console.log('[ChromeDevAssist] Extension reloaded:', extension.name);Â·
      // Start console capture if requested (captures from ALL tabs since extension reload affects all)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, null);
      }Â·
      // Get command-specific logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        extensionId,
        extensionName: extension.name,
        reloadSuccess: true,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle capture-only command
     * Captures console logs without reloading any extension
     */
    async function handleCaptureCommand(commandId, params) {
      const { duration = 5000 } = params;Â·
      console.log('[ChromeDevAssist] Capturing console logs for', duration, 'ms');Â·
      // Capture from ALL tabs (tabId = null means no filter)
      await startConsoleCapture(commandId, duration, null);Â·
      // Get command-specific logs
      const logs = getCommandLogs(commandId);Â·
      return {
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle getAllExtensions command
     * Returns list of all installed extensions (excluding self and apps)
     */
    async function handleGetAllExtensionsCommand(commandId, params) {
      console.log('[ChromeDevAssist] Getting all extensions');Â·
      const extensions = await chrome.management.getAll();Â·
      // Filter out self and apps (only return extensions)
      const filtered = extensions
        .filter(ext => ext.type === 'extension' && ext.id !== chrome.runtime.id)
        .map(ext => ({
          id: ext.id,
          name: ext.name,
          version: ext.version,
          enabled: ext.enabled,
          description: ext.description,
          installType: ext.installType
        }));Â·
      return {
        extensions: filtered,
        count: filtered.length
      };
    }Â·
    /**
     * Handle getExtensionInfo command
     * Returns detailed information for a specific extension
     */
    async function handleGetExtensionInfoCommand(commandId, params) {
      const { extensionId } = params;Â·
      if (!extensionId) {
        throw new Error('extensionId is required');
      }Â·
      console.log('[ChromeDevAssist] Getting info for extension:', extensionId);Â·
      let extension;
      try {
        extension = await chrome.management.get(extensionId);
      } catch (err) {
        throw new Error(`Extension not found: ${extensionId}`);
      }Â·
      return {
        id: extension.id,
        name: extension.name,
        version: extension.version,
        enabled: extension.enabled,
        description: extension.description,
        permissions: extension.permissions,
        hostPermissions: extension.hostPermissions,
        installType: extension.installType,
        mayDisable: extension.mayDisable
      };
    }Â·
    /**
     * Handle openUrl command
     * Opens a URL in a new tab, optionally capturing console logs
     *
     * NEW: Supports autoClose option to automatically close tab after capture
     * This prevents tab leaks in automated testing scenarios
     */
    async function handleOpenUrlCommand(commandId, params) {
      // Safe JSON stringify (handles circular references)
      const safeStringify = (obj) => {
        try {
          const seen = new WeakSet();
          return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
              if (seen.has(value)) {
                return '[Circular]';
              }
              seen.add(value);
            }
            return value;
          }, 2);
        } catch (err) {
          return '[Unable to stringify]';
        }
      };Â·
      console.log('[ChromeDevAssist] handleOpenUrlCommand called with params:', safeStringify(params));Â·
      const {
        url,
        active = true,
        captureConsole = false,
        duration = 5000,
        autoClose = false  // NEW: Automatic tab cleanup (default: false for backward compatibility)
      } = params;Â·
      console.log('[ChromeDevAssist] Extracted parameters:', {
        url: url ? url.substring(0, 100) : url,  // Truncate long URLs in logs
        active,
        captureConsole,
        duration,
        autoClose
      });Â·
      // Security: Validate URL parameter
      if (!url || url === '' || url === null || url === undefined) {
        throw new Error('url is required');
      }Â·
      // Security: Block dangerous URL protocols
      const urlLower = url.toLowerCase().trim();
      const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
      if (dangerousProtocols.some(protocol => urlLower.startsWith(protocol))) {
        throw new Error(`Dangerous URL protocol not allowed: ${urlLower.split(':')[0]}`);
      }Â·
      // Security: Validate duration parameter
      if (typeof duration !== 'number') {
        throw new Error(`Invalid duration type: expected number, got ${typeof duration}`);
      }Â·
      if (!isFinite(duration)) {
        throw new Error('Invalid duration: must be finite');
      }Â·
      if (duration < 0) {
        throw new Error('Invalid duration: must be non-negative');
      }Â·
      if (isNaN(duration)) {
        throw new Error('Invalid duration: NaN not allowed');
      }Â·
      // Security: Reject durations exceeding reasonable maximum (10 minutes)
      const MAX_DURATION = 600000; // 10 minutes
      if (duration > MAX_DURATION) {
        throw new Error(`Invalid duration: exceeds maximum allowed (${MAX_DURATION}ms)`);
      }Â·
      const safeDuration = duration;Â·
      console.log('[ChromeDevAssist] Opening URL:', url.substring(0, 100), autoClose ? '(will auto-close)' : '');Â·
      // Create new tab (returns immediately with tab.id, page hasn't loaded yet)
      const tab = await chrome.tabs.create({
        url: url,
        active: active
      });Â·
      let logs = [];
      let tabClosed = false;Â·
      try {
        // Start console capture for this specific tab (if requested)
        // Tab is created but page is still loading, so we'll catch all console logs
        if (captureConsole) {
          await startConsoleCapture(commandId, duration, tab.id);Â·
          // Wait for capture duration
          await sleep(duration);
        }Â·
        // Get captured logs
        logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      } finally {
        // IMPORTANT: Cleanup happens in finally block to ensure it runs even on errors
        console.log('[ChromeDevAssist] Entering finally block, autoClose =', autoClose);Â·
        if (autoClose) {
          console.log('[ChromeDevAssist] Attempting to close tab:', tab.id);Â·
          try {
            // Check if tab still exists before attempting to close
            const tabExists = await chrome.tabs.get(tab.id).catch(() => null);
            console.log('[ChromeDevAssist] Tab exists check:', tabExists ? 'YES' : 'NO');Â·
            if (!tabExists) {
              console.warn('[ChromeDevAssist] Tab already closed:', tab.id);
              tabClosed = false;
            } else {
              // Attempt to remove the tab
              const removeResult = chrome.tabs.remove(tab.id);
              console.log('[ChromeDevAssist] chrome.tabs.remove returned:', typeof removeResult);
              console.log('[ChromeDevAssist] Is Promise?:', removeResult instanceof Promise);Â·
              if (removeResult && typeof removeResult.then === 'function') {
                await removeResult;
                console.log('[ChromeDevAssist] Tab removal awaited successfully');
              } else {
                console.warn('[ChromeDevAssist] chrome.tabs.remove did NOT return Promise!');
              }Â·
              tabClosed = true;
              console.log('[ChromeDevAssist] âœ… Successfully closed tab:', tab.id);
            }
          } catch (err) {
            // Don't silently ignore - log with more detail
            console.error('[ChromeDevAssist] âš ï¸ TAB CLEANUP FAILED âš ï¸');
            console.error('[ChromeDevAssist] Tab ID:', tab.id);
            console.error('[ChromeDevAssist] Error type:', err.constructor.name);
            console.error('[ChromeDevAssist] Error message:', err.message);
            console.error('[ChromeDevAssist] Error code:', err.code);
            console.error('[ChromeDevAssist] Stack:', err.stack);Â·
            // Keep tabClosed as false to indicate failure
            tabClosed = false;
          }
        } else {
          console.log('[ChromeDevAssist] autoClose=false, skipping tab cleanup');
        }
      }Â·
      // Return after cleanup completes
      return {
        tabId: tab.id,
        url: tab.url,
        consoleLogs: logs,
        tabClosed: tabClosed
      };
    }Â·
    /**
     * Handle reloadTab command
     * Reloads a specific tab, optionally with cache bypass (hard reload)
     */
    async function handleReloadTabCommand(commandId, params) {
      const { tabId, bypassCache = false, captureConsole = false, duration = 5000 } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Reloading tab:', tabId, bypassCache ? '(hard reload)' : '');Â·
      // Start console capture for this specific tab (if requested)
      if (captureConsole) {
        await startConsoleCapture(commandId, duration, tabId);
      }Â·
      // Reload tab (console capture script will be auto-injected at document_start)
      await chrome.tabs.reload(tabId, { bypassCache: bypassCache });Â·
      // Wait for capture duration if capturing
      if (captureConsole) {
        await sleep(duration);
      }Â·
      // Get captured logs
      const logs = captureConsole ? getCommandLogs(commandId) : [];Â·
      return {
        tabId: tabId,
        bypassCache: bypassCache,
        consoleLogs: logs
      };
    }Â·
    /**
     * Handle closeTab command
     * Closes a specific tab
     */
    async function handleCloseTabCommand(commandId, params) {
      const { tabId } = params;Â·
      if (tabId === undefined) {
        throw new Error('tabId is required');
      }Â·
      console.log('[ChromeDevAssist] Closing tab:', tabId);Â·
      await chrome.tabs.remove(tabId);Â·
      return {
        tabId: tabId,
        closed: true
      };
    }Â·
    /**
     * Start capturing console logs for specified duration
     * Each command gets its own isolated log collection
     * Returns immediately - capture runs in background
     *
     * @param {string} commandId - Unique command identifier
     * @param {number} duration - Capture duration in milliseconds
     * @param {number|null} tabId - Tab ID to filter logs (null = capture all tabs)
     */
    function startConsoleCapture(commandId, duration, tabId = null) {
      // Initialize command-specific capture state
      captureState.set(commandId, {
        logs: [],
        active: true,
        timeout: null,
        tabId: tabId  // null = capture all tabs, number = specific tab only
      });Â·
      // Add to tab-specific index for O(1) lookup (prevents race conditions)
      if (tabId !== null) {
        if (!capturesByTab.has(tabId)) {
          capturesByTab.set(tabId, new Set());
        }
        capturesByTab.get(tabId).add(commandId);
      }Â·
      console.log(`[ChromeDevAssist] Console capture started for command ${commandId}${tabId ? ` (tab ${tabId})` : ' (all tabs)'}`);Â·
      // Set timeout to stop capture
      const timeout = setTimeout(() => {
        const state = captureState.get(commandId);
        if (state) {
          state.active = false;
          state.endTime = Date.now(); // Track when capture ended for cleanup
          console.log(`[ChromeDevAssist] Console capture complete for command ${commandId}:`, state.logs.length, 'logs');
        }
      }, duration);Â·
      // Store timeout reference for cleanup
      captureState.get(commandId).timeout = timeout;Â·
      // Return immediately (don't wait for duration)
      return Promise.resolve();
    }Â·
    /**
     * CLEANUP HELPER: Remove capture state and maintain index integrity
     * Architectural purpose: Ensures captureState and capturesByTab stay synchronized
     * Used by: periodic cleanup, error handlers, normal completion
     */
    function cleanupCapture(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return; // Already cleaned up
      }Â·
      // Clear timeout if exists
      if (state.timeout) {
        clearTimeout(state.timeout);
      }Â·
      // Remove from tab-specific index (prevents orphaned entries)
      if (state.tabId !== null) {
        const tabSet = capturesByTab.get(state.tabId);
        if (tabSet) {
          tabSet.delete(commandId);
          // Clean up empty sets to prevent memory leaks
          if (tabSet.size === 0) {
            capturesByTab.delete(state.tabId);
          }
        }
      }Â·
      // Remove from main state
      captureState.delete(commandId);
    }Â·
    /**
     * Get logs for a specific command
     * Returns logs and cleans up completed captures
     */
    function getCommandLogs(commandId) {
      const state = captureState.get(commandId);
      if (!state) {
        return [];
      }Â·
      const logs = [...state.logs]; // Copy logsÂ·
      // Clean up using consolidated helper
      cleanupCapture(commandId);Â·
      return logs;
    }Â·
    /**
     * Receive console logs from content scripts
     * Content scripts intercept console methods and send logs here
     * Logs are distributed to ALL active captures
     *
     * Only runs in Chrome extension context (not in tests)
     */
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Only process console messages
      if (message.type === 'console') {
        // Validate sender - must be from a content script in a tab
        if (!sender.tab) {
          console.warn('[ChromeDevAssist] Rejected console message from non-tab source');
          sendResponse({ received: false });
          return true;
        }Â·
        // Validate message structure - must have required fields
        if (!message.level || !message.message || !message.timestamp) {
          console.warn('[ChromeDevAssist] Rejected malformed console message (missing required fields)');
          sendResponse({ received: false });
          return true;
        }Â·
        // Truncate very long messages to prevent memory exhaustion
        const MAX_MESSAGE_LENGTH = 10000;
        let truncatedMessage = message.message;
        if (typeof message.message === 'string' && message.message.length > MAX_MESSAGE_LENGTH) {
          truncatedMessage = message.message.substring(0, MAX_MESSAGE_LENGTH) + '... [truncated]';
        }Â·
        const logEntry = {
          level: message.level,
          message: truncatedMessage,
          timestamp: message.timestamp,
          source: message.source || 'unknown',
          url: sender.url || 'unknown',
          tabId: sender.tab.id,
          frameId: sender.frameId
        };Â·
        // Add log to active captures that match this tab (with limit enforcement)
        // Uses O(1) direct lookup instead of O(n) iteration to prevent race conditions
        let addedToAny = false;
        const tabId = sender.tab.id;
        const relevantCommandIds = new Set();Â·
        // 1. Get tab-specific captures via O(1) lookup
        if (capturesByTab.has(tabId)) {
          for (const cmdId of capturesByTab.get(tabId)) {
            relevantCommandIds.add(cmdId);
          }
        }Â·
        // 2. Get global captures (tabId === null) via iteration
        for (const [commandId, state] of captureState.entries()) {
          if (state.active && state.tabId === null) {
            relevantCommandIds.add(commandId);
          }
        }Â·
        // 3. Add log to all relevant captures
        for (const commandId of relevantCommandIds) {
          const state = captureState.get(commandId);
          if (state && state.active) {
            // Enforce max logs limit to prevent memory exhaustion
            if (state.logs.length < MAX_LOGS_PER_CAPTURE) {
              state.logs.push(logEntry);
              addedToAny = true;
            } else if (state.logs.length === MAX_LOGS_PER_CAPTURE) {
              // Add warning message once when limit is reached
              state.logs.push({
                level: 'warn',
                message: `[ChromeDevAssist] Log limit reached (${MAX_LOGS_PER_CAPTURE}). Further logs will be dropped.`,
                timestamp: new Date().toISOString(),
                source: 'chrome-dev-assist',
                url: 'internal',
                tabId: logEntry.tabId,
                frameId: 0
              });
              addedToAny = true;
            }
            // else: silently drop logs exceeding limit
          }
        }Â·
        sendResponse({ received: addedToAny });
      }Â·
      return true; // Keep message channel open for async response
      });
    }Â·
    /**
     * Utility: sleep
     */
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }Â·
    /**
     * Set extension status (only in Chrome extension context)
     */
    if (typeof chrome !== 'undefined' && chrome.storage) {
      chrome.storage.local.set({
        status: {
          running: true,
          version: '1.0.0',
          lastUpdate: new Date().toISOString()
        }
      });
      console.log('[ChromeDevAssist] Ready for commands');
    }Â·
    /**
     * Export functions for testing (only in Node.js context)
     */
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        handleOpenUrlCommand,
        handleReloadTabCommand,
        registerConsoleCaptureScript,
        sleep
      };
    }
    "

      346 |       );
      347 |
    > 348 |       expect(backgroundJs).toContain('reconnectAttempts');
          |                            ^
      349 |     });
      350 |
      351 |     it('should verify backoff has maximum limit', () => {

      at Object.toContain (tests/integration/reconnection-behavior.test.js:348:28)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Exponential Backoff Implementation â€º should verify backoff has maximum limit

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      360 |         backgroundJs.includes('maxReconnectDelay');
      361 |
    > 362 |       expect(hasMaxBackoff).toBe(true);
          |                             ^
      363 |     });
      364 |
      365 |     it('should verify reconnection attempts are reset on successful connection', () => {

      at Object.toBe (tests/integration/reconnection-behavior.test.js:362:29)

  â— Extension Reconnection Behavior (ISSUE-012) â€º Exponential Backoff Implementation â€º should verify reconnection attempts are reset on successful connection

    expect(received).toBeGreaterThan(expected)

    Expected: > 3620
    Received:   -1

      373 |       const resetIndex = backgroundJs.indexOf('reconnectAttempts = 0', onopenIndex);
      374 |
    > 375 |       expect(resetIndex).toBeGreaterThan(onopenIndex);
          |                          ^
      376 |     });
      377 |   });
      378 | });

      at Object.toBeGreaterThan (tests/integration/reconnection-behavior.test.js:375:26)


Test Suites: 34 failed, 27 passed, 61 total
Tests:       330 failed, 71 skipped, 564 passed, 965 total
Snapshots:   0 total
Time:        33.164 s
Ran all test suites.
